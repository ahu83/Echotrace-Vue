import { createClass as _createClass, classCallCheck as _classCallCheck } from "../_virtual/_rollupPluginBabelHelpers.js";
import { MP4 } from "./mp4.js";
import { concatUint8Array } from "../utils/index.js";
import { Logger } from "./logger.js";
var FMP4Remuxer = /* @__PURE__ */ function() {
  function FMP4Remuxer2(videoTrack, audioTrack, options) {
    _classCallCheck(this, FMP4Remuxer2);
    this.videoTrack = videoTrack;
    this.audioTrack = audioTrack;
    var browserVersions = /Chrome\/([^.]+)/.exec(navigator.userAgent);
    this.forceFirstIDR = browserVersions && Number(browserVersions[1]) < 50;
    this.log = new Logger("FMP4Remuxer", options && options.openLog ? !options.openLog : true);
  }
  _createClass(FMP4Remuxer2, [{
    key: "remux",
    value: function remux() {
      var createInit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var videoTrack = this.videoTrack;
      var audioTrack = this.audioTrack;
      var hasVideo = videoTrack.exist();
      var hasAudio = audioTrack.exist();
      var videoInitSegment;
      var audioInitSegment;
      var initSegment;
      var tracks = [];
      if (createInit) {
        if (options && options.initMerge) {
          if (hasVideo) {
            tracks.push(this.videoTrack);
          }
          if (hasAudio) {
            tracks.push(this.audioTrack);
          }
          initSegment = MP4.initSegment(tracks);
        } else {
          if (hasVideo)
            videoInitSegment = MP4.initSegment([this.videoTrack]);
          if (hasAudio)
            audioInitSegment = MP4.initSegment([this.audioTrack]);
        }
      }
      var videoSegment;
      var audioSegment;
      if (hasVideo && videoTrack.hasSample()) {
        videoSegment = this._remuxVideo();
      }
      if (hasAudio && audioTrack.hasSample()) {
        audioSegment = this._remuxAudio();
      }
      videoTrack.samples = [];
      audioTrack.samples = [];
      return {
        initSegment,
        videoInitSegment,
        audioInitSegment,
        videoSegment,
        audioSegment
      };
    }
  }, {
    key: "_remuxVideo",
    value: function _remuxVideo() {
      var track = this.videoTrack;
      if (this.forceFirstIDR) {
        track.samples[0].flag = {
          dependsOn: 2,
          isNonSyncSample: 0
        };
      }
      var samples = track.samples;
      var isAV01 = /av01/.test(track.codec);
      var mdatSize = 0;
      if (isAV01) {
        samples.forEach(function(s) {
          mdatSize += s.data.byteLength;
        });
      } else {
        samples.forEach(function(s) {
          mdatSize += s.units.reduce(function(t, c) {
            return t + c.byteLength;
          }, 0);
          mdatSize += s.units.length * 4;
        });
      }
      var mdata = new Uint8Array(mdatSize);
      if (isAV01) {
        for (var i = 0, l = samples.length, offset = 0, sample; i < l; i++) {
          sample = samples[i];
          mdata.set(sample.data, offset);
          sample.size = sample.data.byteLength;
          offset += sample.size;
        }
      } else {
        var mdatView = new DataView(mdata.buffer);
        var _loop = function _loop2(_offset2, _sample2) {
          _sample2 = samples[_i];
          var sampleSize = 0;
          _sample2.units.forEach(function(u) {
            mdatView.setUint32(_offset2, u.byteLength);
            _offset2 += 4;
            mdata.set(u, _offset2);
            _offset2 += u.byteLength;
            sampleSize += 4 + u.byteLength;
          });
          _sample2.size = sampleSize;
          _offset = _offset2, _sample = _sample2;
        };
        for (var _i = 0, _l = samples.length, _offset = 0, _sample; _i < _l; _i++) {
          _loop(_offset, _sample);
        }
      }
      var mdat = MP4.mdat(mdata);
      var moof = MP4.moof([track]);
      return concatUint8Array(moof, mdat);
    }
  }, {
    key: "_remuxAudio",
    value: function _remuxAudio() {
      var track = this.audioTrack;
      var mdata = new Uint8Array(track.samples.reduce(function(t, c) {
        return t + c.size;
      }, 0));
      track.samples.reduce(function(offset, s) {
        mdata.set(s.data, offset);
        return offset + s.size;
      }, 0);
      var mdat = MP4.mdat(mdata);
      var moof = MP4.moof([track]);
      return concatUint8Array(moof, mdat);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.videoTrack.reset();
      this.audioTrack.reset();
    }
  }]);
  return FMP4Remuxer2;
}();
export { FMP4Remuxer };
