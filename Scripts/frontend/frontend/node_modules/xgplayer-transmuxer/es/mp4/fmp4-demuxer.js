import { createClass as _createClass, classCallCheck as _classCallCheck, defineProperty as _defineProperty, toConsumableArray as _toConsumableArray, createForOfIteratorHelper as _createForOfIteratorHelper } from "../_virtual/_rollupPluginBabelHelpers.js";
import { VideoTrack } from "../model/video-track.js";
import { AudioTrack } from "../model/audio-track.js";
import { VideoSample } from "../model/video-sample.js";
import { AudioSample } from "../model/audio-sample.js";
import { MetadataTrack } from "../model/metadata-track.js";
import { concatUint8Array, readBig32 } from "../utils/index.js";
import { MP4Parser } from "./mp4-parser.js";
var FMP4Demuxer = /* @__PURE__ */ function() {
  function FMP4Demuxer2(videoTrack, audioTrack, metadataTrack) {
    _classCallCheck(this, FMP4Demuxer2);
    _defineProperty(this, "__loadedMoofWraps", []);
    _defineProperty(this, "__lastRemainData", null);
    _defineProperty(this, "__lastRemainDataStart", 0);
    _defineProperty(this, "__nextMoofStart", -1);
    this.videoTrack = videoTrack || new VideoTrack();
    this.audioTrack = audioTrack || new AudioTrack();
    this.metadataTrack = metadataTrack || new MetadataTrack();
  }
  _createClass(FMP4Demuxer2, [{
    key: "demuxPart",
    value: function demuxPart(partData, partDataStart, moov) {
      var _this = this;
      var videoTrack = this.videoTrack, audioTrack = this.audioTrack;
      var videoExist = videoTrack.exist();
      var audioExist = audioTrack.exist();
      var isAV01 = /av01/.test(videoTrack.codec);
      videoTrack.samples = [];
      audioTrack.samples = [];
      var data = partData;
      var dataStart = partDataStart;
      if (this.__lastRemainData) {
        var lastRemainDataEnd = this.__lastRemainDataStart + this.__lastRemainData.byteLength;
        var continuous = partDataStart <= lastRemainDataEnd && partDataStart > this.__lastRemainDataStart && partDataStart + partData.byteLength > lastRemainDataEnd;
        if (continuous) {
          var noDuplicateData = partData.subarray(this.__lastRemainData.byteLength + this.__lastRemainDataStart - partDataStart);
          data = concatUint8Array(this.__lastRemainData, noDuplicateData);
          dataStart = this.__lastRemainDataStart;
          this.__lastRemainData = null;
        } else {
          this.__lastRemainData = null;
          this.__lastRemainDataStart = 0;
          this.__nextMoofStart = -1;
        }
      }
      if (!moov) {
        var moovBox = MP4Parser.findBox(data, ["moov"])[0];
        if (!moovBox)
          throw new Error("cannot found moov box");
        moov = MP4Parser.moov(moovBox);
      }
      if (data) {
        var dataEnd = dataStart + data.byteLength;
        if (!videoExist && !audioExist) {
          MP4Parser.moovToTrack(moov, videoTrack, audioTrack);
        }
        var moofBoxes = [];
        if (this.__nextMoofStart < 0) {
          MP4Parser.findBox(data, ["moof"], dataStart).forEach(function(v) {
            return moofBoxes.push(v);
          });
        } else if (this.__nextMoofStart >= dataStart && this.__nextMoofStart <= dataEnd - 8) {
          MP4Parser.findBox(data.subarray(this.__nextMoofStart - dataStart), ["moof"], this.__nextMoofStart).forEach(function(v) {
            return moofBoxes.push(v);
          });
        }
        moofBoxes.filter(function(moofBox) {
          return moofBox.size <= moofBox.data.length;
        }).forEach(function(moofBox) {
          var moof = MP4Parser.moof(moofBox);
          _this.__nextMoofStart = moof.start + Math.max.apply(Math, _toConsumableArray(moof.traf.map(function(v) {
            return v.trun.samples.reduce(function(ret, w) {
              return ret + w.size;
            }, v.trun.dataOffset || 0);
          })));
          _this.__loadedMoofWraps.push({
            start: moof.start,
            nextMoofStart: _this.__nextMoofStart,
            moof
          });
          _this.__loadedMoofWraps.sort(function(p, n) {
            return p.start - n.start;
          });
        });
        var _iterator = _createForOfIteratorHelper(this.__loadedMoofWraps), _step;
        try {
          var _loop = function _loop2() {
            var moofWrap = _step.value;
            if (moofWrap.start > dataEnd || moofWrap.nextMoofStart < dataStart) {
              return "continue";
            }
            var moofStart = moofWrap.start;
            var tracks = MP4Parser.moofToSamples(moofWrap.moof, videoTrack, audioTrack);
            var videoBaseMediaDecodeTime = videoTrack.baseMediaDecodeTime;
            var audioBaseMediaDecodeTime = audioTrack.baseMediaDecodeTime;
            var nalSize;
            Object.keys(tracks).forEach(function(k) {
              if (videoTrack.id == k) {
                tracks[k].some(function(x) {
                  var xStart = x.offset += moofStart;
                  if (xStart < dataStart) {
                    return;
                  }
                  if (xStart + x.size > dataEnd) {
                    return true;
                  }
                  var sample = new VideoSample((x.pts || x.dts) + videoBaseMediaDecodeTime, x.dts + videoBaseMediaDecodeTime);
                  sample.duration = x.duration;
                  sample.gopId = x.gopId;
                  if (x.keyframe)
                    sample.setToKeyframe();
                  var sampleData = data.subarray(xStart - dataStart, xStart - dataStart + x.size);
                  sample.data = sampleData;
                  if (!isAV01) {
                    var start = 0;
                    var len = sampleData.length - 1;
                    while (start < len) {
                      nalSize = readBig32(sampleData, start);
                      start += 4;
                      sample.units.push(sampleData.subarray(start, start + nalSize));
                      start += nalSize;
                    }
                  }
                  _this.__lastRemainDataStart = xStart + x.size;
                  videoTrack.samples.push(sample);
                });
              } else if (audioTrack.id == k) {
                tracks[k].some(function(x) {
                  var xStart = x.offset + moofStart;
                  if (xStart < dataStart) {
                    return;
                  }
                  if (xStart + x.size > dataEnd) {
                    return true;
                  }
                  var sampleData = data.subarray(xStart - dataStart, xStart - dataStart + x.size);
                  audioTrack.samples.push(new AudioSample(x.dts + audioBaseMediaDecodeTime, sampleData, x.duration));
                  _this.__lastRemainDataStart = xStart + x.size;
                });
              }
            });
          };
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _ret = _loop();
            if (_ret === "continue")
              continue;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      if (this.__lastRemainDataStart > dataStart && this.__lastRemainDataStart < data.byteLength + dataStart) {
        this.__lastRemainData = data.subarray(this.__lastRemainDataStart - dataStart);
      } else {
        this.__lastRemainData = data;
        this.__lastRemainDataStart = dataStart;
      }
      if (videoTrack.samples.length) {
        videoTrack.baseMediaDecodeTime = videoTrack.samples[0].pts;
      }
      if (audioTrack.samples.length) {
        audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts;
      }
      return {
        videoTrack,
        audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "demux",
    value: function demux(videoData, audioData) {
      var videoTrack = this.videoTrack, audioTrack = this.audioTrack;
      var videoExist = videoTrack.exist();
      var audioExist = audioTrack.exist();
      videoTrack.samples = [];
      audioTrack.samples = [];
      if (audioData) {
        if (!audioExist) {
          var moovBox = MP4Parser.findBox(audioData, ["moov"])[0];
          if (!moovBox)
            throw new Error("cannot found moov box");
          MP4Parser.moovToTrack(MP4Parser.moov(moovBox), null, audioTrack);
        }
        var moofBox = MP4Parser.findBox(audioData, ["moof"])[0];
        if (moofBox) {
          var samples = MP4Parser.moofToSamples(MP4Parser.moof(moofBox), null, audioTrack)[audioTrack.id];
          var baseMediaDecodeTime = audioTrack.baseMediaDecodeTime;
          if (samples) {
            var baseOffset = moofBox.start;
            samples.map(function(x) {
              x.offset += baseOffset;
              var sampleData = audioData.subarray(x.offset, x.offset + x.size);
              audioTrack.samples.push(new AudioSample(x.dts + baseMediaDecodeTime, sampleData, x.duration));
            });
          }
        }
      }
      if (videoData) {
        if (!videoExist && !audioExist) {
          var _moovBox = MP4Parser.findBox(videoData, ["moov"])[0];
          if (!_moovBox)
            throw new Error("cannot found moov box");
          MP4Parser.moovToTrack(MP4Parser.moov(_moovBox), videoTrack, audioTrack);
        }
        var _moofBox = MP4Parser.findBox(videoData, ["moof"])[0];
        if (_moofBox) {
          var tracks = MP4Parser.moofToSamples(MP4Parser.moof(_moofBox), videoTrack, audioTrack);
          var videoBaseMediaDecodeTime = videoTrack.baseMediaDecodeTime;
          var audioBaseMediaDecodeTime = audioTrack.baseMediaDecodeTime;
          var _baseOffset = _moofBox.start;
          var nalSize;
          Object.keys(tracks).forEach(function(k) {
            if (videoTrack.id == k) {
              tracks[k].map(function(x) {
                x.offset += _baseOffset;
                var sample = new VideoSample((x.pts || x.dts) + videoBaseMediaDecodeTime, x.dts + videoBaseMediaDecodeTime);
                sample.duration = x.duration;
                sample.gopId = x.gopId;
                if (x.keyframe)
                  sample.setToKeyframe();
                var sampleData = videoData.subarray(x.offset, x.offset + x.size);
                sample.data = sampleData;
                var start = 0;
                var len = sampleData.length - 1;
                while (start < len) {
                  nalSize = readBig32(sampleData, start);
                  start += 4;
                  sample.units.push(sampleData.subarray(start, start + nalSize));
                  start += nalSize;
                }
                videoTrack.samples.push(sample);
              });
            } else if (audioTrack.id == k) {
              tracks[k].map(function(x) {
                x.offset += _baseOffset;
                var sampleData = videoData.subarray(x.offset, x.offset + x.size);
                audioTrack.samples.push(new AudioSample(x.dts + audioBaseMediaDecodeTime, sampleData, x.duration));
              });
            }
          });
        }
      }
      return {
        videoTrack,
        audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "reset",
    value: function reset() {
      this.videoTrack.reset();
      this.audioTrack.reset();
      this.metadataTrack.reset();
    }
  }], [{
    key: "probe",
    value: function probe(data) {
      return MP4Parser.probe(data);
    }
  }]);
  return FMP4Demuxer2;
}();
export { FMP4Demuxer };
