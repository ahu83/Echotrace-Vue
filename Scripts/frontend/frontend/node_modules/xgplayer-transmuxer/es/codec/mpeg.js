import { createClass as _createClass, classCallCheck as _classCallCheck } from "../_virtual/_rollupPluginBabelHelpers.js";
import "../utils/logger.js";
import { isFirefox } from "../utils/env.js";
var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
var FREQ = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3];
var SamplesCoefficients = [
  [
    0,
    72,
    144,
    12
  ],
  [
    0,
    0,
    0,
    0
  ],
  [
    0,
    72,
    144,
    12
  ],
  [
    0,
    144,
    144,
    12
  ]
];
var BytesInSlot = [
  0,
  1,
  1,
  4
];
var chromeVersion = null;
var MPEG = /* @__PURE__ */ function() {
  function MPEG2() {
    _classCallCheck(this, MPEG2);
  }
  _createClass(MPEG2, null, [{
    key: "isHeader",
    value: function isHeader(data, offset) {
      return offset + 1 < data.length && data[offset] === 255 && (data[offset + 1] & 224) === 224 && (data[offset + 1] & 6) !== 0;
    }
  }, {
    key: "appendFrame",
    value: function appendFrame(track, data, offset, pts, frameIndex) {
      if (offset + 24 > data.length) {
        return;
      }
      var header = MPEG2.parseHeader(data, offset);
      if (header && offset + header.frameLength <= data.length) {
        var frameDuration = header.samplesPerFrame * 9e4 / header.sampleRate;
        var stamp = pts + frameIndex * frameDuration;
        var sample = {
          data: data.subarray(offset, offset + header.frameLength),
          pts: stamp,
          dts: stamp
        };
        sample.size = sample.data.byteLength;
        track.config = [];
        track.channelCount = header.channelCount;
        track.sampleRate = header.sampleRate;
        if (isFirefox) {
          track.codec = "mp3";
        } else {
          track.container = "audio/mpeg";
        }
        track.samples.push(sample);
        return {
          length: header.frameLength
        };
      }
    }
  }, {
    key: "parseHeader",
    value: function parseHeader(data, offset) {
      var mpegVersion = data[offset + 1] >> 3 & 3;
      var mpegLayer = data[offset + 1] >> 1 & 3;
      var bitRateIndex = data[offset + 2] >> 4 & 15;
      var sampleRateIndex = data[offset + 2] >> 2 & 3;
      if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {
        var paddingBit = data[offset + 2] >> 1 & 1;
        var channelMode = data[offset + 3] >> 6;
        var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;
        var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1e3;
        var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;
        var sampleRate = FREQ[columnInSampleRates * 3 + sampleRateIndex];
        var channelCount = channelMode === 3 ? 1 : 2;
        var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];
        var bytesInSlot = BytesInSlot[mpegLayer];
        var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
        var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;
        if (chromeVersion === null) {
          var userAgent = navigator.userAgent || "";
          var result = userAgent.match(/Chrome\/(\d+)/i);
          chromeVersion = result ? parseInt(result[1]) : 0;
        }
        var needChromeFix = !!chromeVersion && chromeVersion <= 87;
        if (needChromeFix && mpegLayer === 2 && bitRate >= 224e3 && channelMode === 0) {
          data[offset + 3] = data[offset + 3] | 128;
        }
        return {
          sampleRate,
          channelCount,
          frameLength,
          samplesPerFrame
        };
      }
    }
  }]);
  return MPEG2;
}();
export { MPEG };
