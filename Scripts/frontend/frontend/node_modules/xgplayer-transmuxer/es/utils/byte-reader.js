import { createClass as _createClass, classCallCheck as _classCallCheck } from "../_virtual/_rollupPluginBabelHelpers.js";
var ByteReader = /* @__PURE__ */ function() {
  function ByteReader2(buf, offset, len) {
    _classCallCheck(this, ByteReader2);
    this.dv = new DataView(buf);
    this.start = this.offset = offset || this.dv.byteOffset;
    this.end = len ? this.start + len : this.start + this.dv.byteLength;
  }
  _createClass(ByteReader2, [{
    key: "buffer",
    get: function get() {
      return this.dv.buffer;
    }
  }, {
    key: "unreadLength",
    get: function get() {
      return Math.max(this.end - this.offset, 0);
    }
  }, {
    key: "size",
    get: function get() {
      return this.end - this.start;
    }
  }, {
    key: "readFloat",
    value: function readFloat(byteNum) {
      var val = 0;
      switch (byteNum) {
        case 4:
          val = this.dv.getFloat32(this.offset);
          break;
        case 8:
          val = this.dv.getFloat64(this.offset);
          break;
        default:
          throw new Error("read ".concat(byteNum, "-byte float is not supported"));
      }
      this.offset += byteNum;
      return val;
    }
  }, {
    key: "back",
    value: function back(byteNum) {
      this.offset -= byteNum;
    }
  }, {
    key: "skip",
    value: function skip(byteNum) {
      this.offset += byteNum;
    }
  }, {
    key: "readInt",
    value: function readInt(byteNum) {
      var offset = this.offset;
      this.offset += byteNum;
      switch (byteNum) {
        case 1:
          return this.dv.getInt8(offset);
        case 2:
          return this.dv.getInt16(offset);
        case 4:
          return this.dv.getInt32(offset);
        default:
          throw new Error("read ".concat(byteNum, "-byte integers is not supported"));
      }
    }
  }, {
    key: "read",
    value: function read(byteNum) {
      var offset = this.offset;
      this.offset += byteNum;
      switch (byteNum) {
        case 1:
          return this.dv.getUint8(offset);
        case 2:
          return this.dv.getUint16(offset);
        case 3:
          return (this.dv.getUint16(offset) << 8) + this.dv.getUint8(offset + 2);
        case 4:
          return this.dv.getUint32(offset);
        default:
          this.back(byteNum - 4);
          return this.read(byteNum - 4) + this.dv.getUint32(offset) * Math.pow(256, byteNum - 4);
      }
    }
  }, {
    key: "write",
    value: function write(byteNum, val) {
      var offset = this.offset;
      this.offset += byteNum;
      switch (byteNum) {
        case 1:
          return this.dv.setUint8(offset, val);
        case 2:
          return this.dv.setUint16(offset, val);
        case 3:
          return this.dv.setUint8(offset, val >>> 16), this.dv.setUint16(offset + 1, 65535 & val);
        case 4:
          return this.dv.setUint32(offset, val);
        default:
          throw new Error("write ".concat(byteNum, "-byte integers is not supported"));
      }
    }
  }, {
    key: "readToBuffer",
    value: function readToBuffer(len) {
      var buffer;
      if (this.offset || len) {
        buffer = this.dv.buffer.slice(this.offset, len ? this.offset + len : this.end);
      } else {
        buffer = this.dv.buffer;
      }
      this.offset += buffer.byteLength;
      return buffer;
    }
  }, {
    key: "readToUint8",
    value: function readToUint8(len) {
      var uint8 = new Uint8Array(this.dv.buffer, this.offset, len || this.unreadLength);
      this.offset += uint8.byteLength;
      return uint8;
    }
  }, {
    key: "readString",
    value: function readString(len) {
      var i = 0, str = "";
      for (; i < len; i++) {
        str += String.fromCharCode(this.dv.getUint8(this.offset));
        this.offset++;
      }
      return str;
    }
  }], [{
    key: "fromUint8",
    value: function fromUint8(uint8) {
      return new ByteReader2(uint8.buffer, uint8.byteOffset, uint8.byteLength);
    }
  }, {
    key: "concatUint8s",
    value: function concatUint8s(args) {
      var uint8 = new Uint8Array(args.reduce(function(ret, v) {
        return ret + v.byteLength;
      }, 0));
      var offset = 0;
      args.forEach(function(v) {
        uint8.set(v, offset);
        offset += v.byteLength;
      });
      return uint8;
    }
  }, {
    key: "concatUint8",
    value: function concatUint8() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.concatUint8s(args);
    }
  }]);
  return ByteReader2;
}();
export { ByteReader };
