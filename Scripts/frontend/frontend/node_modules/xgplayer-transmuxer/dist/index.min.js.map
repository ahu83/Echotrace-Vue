{"version":3,"file":"index.min.js","sources":["../src/model/types.js","../src/model/video-track.js","../src/model/audio-track.js","../src/model/video-sample.js","../src/model/audio-sample.js","../src/model/metadata-track.js","../src/utils/exp-golomb.js","../src/utils/logger.js","../src/utils/utf8.js","../src/utils/env.js","../src/utils/index.js","../src/codec/aac.js","../src/codec/nalu.js","../src/codec/avc.js","../src/codec/hevc.js","../src/codec/opus.js","../src/codec/mpeg.js","../src/flv/fixer.js","../src/flv/amf.js","../src/flv/soundFormat.js","../src/flv/index.js","../src/mpeg-ts/fixer.js","../src/mpeg-ts/index.js","../src/utils/byte-reader.ts","../src/utils/bit-reader.ts","../src/mp4/mp4-parser.js","../src/mp4/fmp4-demuxer.js","../src/mp4/buffer.js","../src/mp4/mp4.js","../src/mp4/logger.js","../../../node_modules/crypto-es/lib/md5.js","../src/mp4/fmp4-remuxer.js","../../../node_modules/crypto-es/lib/core.js","../../../node_modules/crypto-es/lib/enc-base64.js","../../../node_modules/crypto-es/lib/evpkdf.js","../../../node_modules/crypto-es/lib/cipher-core.js","../../../node_modules/crypto-es/lib/aes.js","../../../node_modules/crypto-es/lib/mode-ctr.js","../../../node_modules/crypto-es/lib/pad-nopadding.js","../src/mp4/crypto/crypto.js","../src/mp4/mp4-demuxer.js","../src/mp4/mp4-remuxer.js","../src/index.umd.js"],"sourcesContent":["/** @enum {string} */\nexport const TrackType = {\n  VIDEO: 'video',\n  AUDIO: 'audio',\n  METADATA: 'metadata'\n}\n\n/** @enum {string} */\nexport const VideoCodecType = {\n  AV1: 'av1',\n  AVC: 'avc',\n  HEVC: 'hevc'\n}\n\n/** @enum {string} */\nexport const AudioCodecType = {\n  AAC: 'aac',\n  G711PCMA: 'g7110a',\n  G711PCMU: 'g7110m',\n  OPUS: 'opus',\n  MP3: 'mp3'\n}\n\n/** @enum {string} */\nexport const WarningType = {\n  LARGE_AV_SHIFT: 'LARGE_AV_SHIFT',\n  LARGE_VIDEO_GAP: 'LARGE_VIDEO_GAP',\n  LARGE_VIDEO_GAP_BETWEEN_CHUNK: 'LARGE_VIDEO_GAP_BETWEEN_CHUNK',\n  LARGE_AUDIO_GAP: 'LARGE_AUDIO_GAP',\n  AUDIO_FILLED: 'AUDIO_FILLED',\n  AUDIO_DROPPED: 'AUDIO_DROPPED'\n}\n","import { TrackType, VideoCodecType } from './types'\n\nexport class VideoTrack {\n  id = 1\n\n  /** @readonly */\n  type = TrackType.VIDEO\n\n  codecType = VideoCodecType.AVC\n\n  pid = -1 // ts use\n\n  /** @type {Uint8Array | Object} */\n  hvcC = undefined\n\n  codec = ''\n\n  timescale = 0\n\n  formatTimescale = 0\n\n  sequenceNumber = 0\n\n  baseMediaDecodeTime = 0\n\n  baseDts = 0\n\n  duration = 0\n\n  warnings = []\n\n  /** @type {import('./video-sample').VideoSample[]} */\n  samples = []\n\n  /** @type {Uint8Array[]} */\n  pps = []\n\n  /** @type {Uint8Array[]} */\n  sps = []\n\n  /** @type {Uint8Array[]} */\n  vps = []\n\n  fpsNum = 0\n\n  fpsDen = 0\n\n  /** @type {[number, number]} */\n  sarRatio = [] // [hSpacing, vSpacing]\n\n  width = 0\n\n  height = 0\n\n  nalUnitSize = 4\n\n  present = false\n\n  isVideoEncryption = false\n\n  isAudioEncryption = false\n\n  isVideo = true\n\n  lastKeyFrameDts = 0\n\n  kid = null\n\n  pssh = null\n\n  /** @type {any} */\n  ext\n\n  reset () {\n    this.sequenceNumber =\n    this.width =\n    this.height =\n    this.fpsDen =\n    this.fpsNum =\n    this.duration =\n    this.baseMediaDecodeTime =\n    this.timescale = 0\n    this.codec = ''\n    this.present = false\n    this.pid = -1\n    this.pps = []\n    this.sps = []\n    this.vps = []\n    this.sarRatio = []\n    this.samples = []\n    this.warnings = []\n    this.hvcC = null\n  }\n\n  get firstDts () {\n    return this.samples.length ? this.samples[0].dts : null\n  }\n\n  get firstPts () {\n    return this.samples.length ? this.samples[0].pts : null\n  }\n\n  get samplesDuration () {\n    if (this.samples.length > 0) {\n      const first = this.samples[0]\n      const last = this.samples[this.samples.length - 1]\n      return last.dts - first.dts + last.duration\n    }\n    return 0\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  exist () {\n    if (/av01/.test(this.codec)) {\n      return true\n    }\n    return !!(this.pps.length && this.sps.length && this.codec)\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasSample () {\n    return !!this.samples.length\n  }\n\n  get isEncryption (){\n    return this.isVideoEncryption\n  }\n}\n","import { TrackType, AudioCodecType } from './types'\n\nexport class AudioTrack {\n  id = 2\n\n  /** @readonly */\n  type = TrackType.AUDIO\n\n  codecType = AudioCodecType.AAC\n\n  pid = -1\n\n  codec = ''\n\n  container = ''\n\n  sequenceNumber = 0\n\n  sampleDuration = 0\n\n  timescale = 0\n\n  formatTimescale = 0\n\n  baseMediaDecodeTime = 0\n\n  duration = 0\n\n  warnings = []\n\n  /** @type {import('./audio-sample').AudioSample[]} */\n  samples = []\n\n  baseDts = 0\n\n  sampleSize = 16\n\n  sampleRate = 0\n\n  channelCount = 0\n\n  objectType = 0\n\n  sampleRateIndex = 0\n\n  /** @type {number[]} */\n  config = []\n\n  present = false\n\n  isVideoEncryption = false\n\n  isAudioEncryption = false\n\n  kid = null\n\n  /** @type {any} */\n  ext\n\n  reset () {\n    this.sequenceNumber = 0\n    this.timescale = 0\n    this.sampleDuration = 0\n    this.sampleRate = 0\n    this.channelCount = 0\n    this.baseMediaDecodeTime = 0\n    this.present = false\n    this.pid = -1\n    this.codec = ''\n    this.samples = []\n    this.config = []\n    this.warnings = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  exist () {\n    return !!(\n      this.sampleRate &&\n      this.channelCount &&\n      (this.codec || this.container) &&\n      (this.codecType === AudioCodecType.AAC ||\n        this.codecType === AudioCodecType.G711PCMA ||\n        this.codecType === AudioCodecType.G711PCMU ||\n        this.codecType === AudioCodecType.OPUS || this.codecType === AudioCodecType.MP3)\n    )\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasSample () {\n    return !!this.samples.length\n  }\n\n  get isEncryption () {\n    return this.isAudioEncryption\n  }\n\n  get firstDts () {\n    return this.samples.length ? this.samples[0].dts : null\n  }\n\n  get firstPts () {\n    return this.samples.length ? this.samples[0].pts : null\n  }\n\n  get samplesDuration () {\n    if (this.samples.length > 0) {\n      const first = this.samples[0]\n      const last = this.samples[this.samples.length - 1]\n      return last.dts - first.dts + last.duration\n    }\n    return 0\n  }\n}\n","/**\n * @typedef {Object} VideoFlag\n * @property {number} [isLeading=0]\n * @property {number} [dependsOn=1]\n * @property {number} [isDependedOn=0]\n * @property {number} [hasRedundancy=0]\n * @property {number} [paddingValue=0]\n * @property {number} [degradationPriority=0]\n * @property {number} [isNonSyncSample=1]\n */\n\nexport class VideoSample {\n  /** @type {VideoFlag} */\n  flag = {}\n\n  keyframe = false\n\n  gopId = 0\n\n  duration = 0\n\n  size = 0\n\n  units = []\n\n  chromaFormat = 420\n\n  // sampleOffset = 0\n\n  /**\n   * @param {number} pts\n   * @param {number} dts\n   * @param {Uint8Array[]} [units]\n   */\n  constructor (pts, dts, units) {\n    this.originPts = this.pts = pts\n    this.originDts = this.dts = dts\n    if (units) this.units = units\n  }\n\n  /**\n   * @returns {number}\n   */\n  get cts () {\n    return this.pts - this.dts\n  }\n\n  setToKeyframe () {\n    this.keyframe = true\n    this.flag.dependsOn = 2\n    this.flag.isNonSyncSample = 0\n  }\n}\n","export class AudioSample {\n  duration = 1024\n\n  flag = { dependsOn: 2, isNonSyncSample: 0 }\n  keyframe = true\n\n  /**\n   * @param {number} pts\n   * @param {Uint8Array} data\n   * @param {number} [duration=1024]\n   */\n  constructor (pts, data, duration, sampleOffset) {\n    this.originPts = this.pts = this.dts = pts\n    this.data = data\n    this.size = data.byteLength\n    this.sampleOffset = sampleOffset\n    if (duration) this.duration = duration\n  }\n}\n","import { TrackType } from './types'\n\nclass Sample {\n  time = 0 // second\n\n  /**\n   * @param {Object} data\n   * @param {number} pts\n   */\n  constructor (data, pts) {\n    this.data = data\n    this.originPts = this.pts = pts\n  }\n}\n\nexport class FlvScriptSample extends Sample {}\n\nexport class SeiSample extends Sample {}\n\nexport class MetadataTrack {\n  /** @readonly */\n  id = 3\n\n  /** @readonly */\n  type = TrackType.METADATA\n\n  timescale = 0\n\n  /** @type {FlvScriptSample[]} */\n  flvScriptSamples = []\n\n  /** @type {SeiSample[]} */\n  seiSamples = []\n\n  /**\n   * @returns {boolean}\n   */\n  exist () {\n    return !!((this.flvScriptSamples.length || this.seiSamples.length) && this.timescale)\n  }\n\n  reset () {\n    this.timescale = 0\n    this.flvScriptSamples = []\n    this.seiSamples = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasSample () {\n    return !!(this.flvScriptSamples.length || this.seiSamples.length)\n  }\n}\n","export class ExpGolomb {\n  _bytesAvailable\n\n  _bitsAvailable = 0\n\n  _word = 0\n\n  constructor (data) {\n    if (!data) throw new Error('ExpGolomb data params is required')\n    this._data = data\n    this._bytesAvailable = data.byteLength\n    if (this._bytesAvailable) this._loadWord()\n  }\n\n  get bitsAvailable () {\n    return this._bitsAvailable\n  }\n\n  _loadWord () {\n    const position = this._data.byteLength - this._bytesAvailable\n    const availableBytes = Math.min(4, this._bytesAvailable)\n    if (availableBytes === 0) throw new Error('No bytes available')\n\n    const workingBytes = new Uint8Array(4)\n    workingBytes.set(this._data.subarray(position, position + availableBytes))\n\n    this._word = new DataView(workingBytes.buffer).getUint32(0)\n    this._bitsAvailable = availableBytes * 8\n    this._bytesAvailable -= availableBytes\n  }\n\n  skipBits (count) {\n    if (this._bitsAvailable > count) {\n      this._word <<= count\n      this._bitsAvailable -= count\n    } else {\n      count -= this._bitsAvailable\n      const skipBytes = Math.floor(count / 8)\n      count -= (skipBytes * 8)\n      this._bytesAvailable -= skipBytes\n      this._loadWord()\n      this._word <<= count\n      this._bitsAvailable -= count\n    }\n  }\n\n  readBits (size) {\n    if (size > 32) {\n      throw new Error('Cannot read more than 32 bits')\n    }\n\n    let bits = Math.min(this._bitsAvailable, size)\n    const val = this._word >>> (32 - bits)\n\n    this._bitsAvailable -= bits\n    if (this._bitsAvailable > 0) {\n      this._word <<= bits\n    } else if (this._bytesAvailable > 0) {\n      this._loadWord()\n    }\n\n    bits = size - bits\n    if (bits > 0 && this._bitsAvailable) {\n      return (val << bits) | this.readBits(bits)\n    }\n    return val\n  }\n\n  skipLZ () {\n    let leadingZeroCount\n    for (\n      leadingZeroCount = 0;\n      leadingZeroCount < this._bitsAvailable;\n      ++leadingZeroCount\n    ) {\n      if ((this._word & (0x80000000 >>> leadingZeroCount)) !== 0) {\n        this._word <<= leadingZeroCount\n        this._bitsAvailable -= leadingZeroCount\n        return leadingZeroCount\n      }\n    }\n    this._loadWord()\n    return leadingZeroCount + this.skipLZ()\n  }\n\n  skipUEG () {\n    this.skipBits(1 + this.skipLZ())\n  }\n\n  readUEG () {\n    const clz = this.skipLZ()\n    return this.readBits(clz + 1) - 1\n  }\n\n  readEG () {\n    const val = this.readUEG()\n    if (1 & val) {\n      return (1 + val) >>> 1\n    }\n    return -1 * (val >>> 1)\n  }\n\n  readBool () {\n    return this.readBits(1) === 1\n  }\n\n  readUByte () {\n    return this.readBits(8)\n  }\n\n  skipScalingList (count) {\n    let lastScale = 8\n    let nextScale = 8\n    let deltaScale\n    for (let j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = this.readEG()\n        nextScale = (lastScale + deltaScale + 256) % 256\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale\n    }\n  }\n}\n","export class Logger {\n  constructor (name) {\n    this.name = name || ''\n    this._prefix = `[${this.name}]`\n  }\n\n  warn (...args) {\n    if (Logger.disabled) return\n    console.warn(this._prefix, ...args)\n  }\n\n  static disabled = true\n\n  static enable () {\n    Logger.disabled = false\n  }\n\n  static disable () {\n    Logger.disabled = true\n  }\n}\n","export class UTF8 {\n  /**\n   *\n   * @param {Uint8Array} uint8array\n   * @return {string}\n   */\n  static decode (uint8array) {\n    const out = []\n    const input = uint8array\n    let i = 0\n    const length = uint8array.length\n\n    while (i < length) {\n      if (input[i] < 0x80) {\n        out.push(String.fromCharCode(input[i]))\n        ++i\n        continue\n      } else if (input[i] < 0xC0) {\n        // fallthrough\n      } else if (input[i] < 0xE0) {\n        if (UTF8._checkContinuation(input, i, 1)) {\n          const ucs4 = (input[i] & 0x1F) << 6 | (input[i + 1] & 0x3F)\n          if (ucs4 >= 0x80) {\n            out.push(String.fromCharCode(ucs4 & 0xFFFF))\n            i += 2\n            continue\n          }\n        }\n      } else if (input[i] < 0xF0) {\n        if (UTF8._checkContinuation(input, i, 2)) {\n          const ucs4 = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F\n          if (ucs4 >= 0x800 && (ucs4 & 0xF800) !== 0xD800) {\n            out.push(String.fromCharCode(ucs4 & 0xFFFF))\n            i += 3\n            continue\n          }\n        }\n      } else if (input[i] < 0xF8) {\n        if (UTF8._checkContinuation(input, i, 3)) {\n          let ucs4 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 |\n                    (input[i + 2] & 0x3F) << 6 | (input[i + 3] & 0x3F)\n          if (ucs4 > 0x10000 && ucs4 < 0x110000) {\n            ucs4 -= 0x10000\n            out.push(String.fromCharCode((ucs4 >>> 10) | 0xD800))\n            out.push(String.fromCharCode((ucs4 & 0x3FF) | 0xDC00))\n            i += 4\n            continue\n          }\n        }\n      }\n      out.push(String.fromCharCode(0xFFFD))\n      ++i\n    }\n\n    return out.join('')\n  }\n\n  static _checkContinuation (uint8array, start, checkLength) {\n    const array = uint8array\n    if (start + checkLength < array.length) {\n      while (checkLength--) {\n        if ((array[++start] & 0xC0) !== 0x80) {\n          return false\n        }\n      }\n      return true\n    } else {\n      return false\n    }\n  }\n}\n","export const isBrowser = typeof window !== 'undefined'\n\nconst ua = isBrowser && navigator.userAgent.toLocaleLowerCase()\n\n// eslint-disable-next-line no-lookahead-lookbehind-regexp/no-lookahead-lookbehind-regexp\nexport const isSafari = isBrowser && /^((?!chrome|android).)*safari/.test(ua)\nexport const isFirefox = isBrowser && ua.includes('firefox')\nexport const isAndroid = isBrowser && ua.includes('android')\n","/* c8 ignore next 4 */\nexport { ExpGolomb } from './exp-golomb'\nexport { Logger } from './logger'\nexport { UTF8 } from './utf8'\nexport * from './env'\n\nexport function concatUint8Array (...arr) {\n  arr = arr.filter(Boolean)\n  const data = new Uint8Array(arr.reduce((p, c) => p + c.byteLength, 0))\n  let prevLen = 0\n  arr.forEach((d) => {\n    data.set(d, prevLen)\n    prevLen += d.byteLength\n  })\n  return data\n}\n\nexport const MAX_SIZE = Math.pow(2, 32)\n\nexport function readBig16 (data, i = 0) {\n  return (data[i] << 8) + (data[i + 1] || 0)\n}\n\nexport function readBig24 (data, i = 0) {\n  return (data[i] << 16) + (data[i + 1] << 8) + (data[i + 2] || 0)\n}\n\nexport function readBig32 (data, i = 0) {\n  return (data[i] << 24 >>> 0) + (data[i + 1] << 16) + (data[i + 2] << 8) + (data[i + 3] || 0)\n}\n\nexport function readBig64 (data, i = 0) {\n  return readBig32(data, i) * MAX_SIZE + readBig32(data, i + 4)\n}\n\nexport function getAvcCodec (codecs) {\n  let codec = 'avc1.'\n  let h\n  for (let i = 0; i < 3; i++) {\n    h = codecs[i].toString(16)\n    if (h.length < 2) h = `0${h}`\n    codec += h\n  }\n  return codec\n}\n\nexport function formatIV (arr) {\n  let iv = ''\n  arr.forEach(value => {\n    iv += bufferToString(value)\n  })\n  if (iv.length <= 32) {\n    const len = 32 - iv.length\n    for (let i = 0; i < len; i++) {\n      iv += '0'\n    }\n  }\n  return iv\n}\n\nexport function parse (a) {\n  if (!Array.isArray(a)) {\n    const arr = []\n    let value = ''\n    for (let i = 0; i < a.length; i++) {\n      if (i % 2) {\n        value = a[i - 1] + a[i]\n        arr.push(parseInt(value, 16))\n        value = ''\n      }\n    }\n    return arr\n  }\n  return a.map(item => { return parseInt(item, 16) })\n}\nfunction bufferToString (value) {\n  return ('0' + (Number(value).toString(16))).slice(-2).toUpperCase()\n}\n\nexport function hashVal (str) {\n  let hash = 0; let i; let chr\n  if (str.length === 0) return hash\n  for (i = 0; i < str.length; i++) {\n    chr = str.charCodeAt(i)\n    hash = ((hash << 5) - hash) + chr\n    hash |= 0\n  }\n  return hash\n}\n\nexport function combineToFloat (integer, decimal) {\n  return Number(integer + '.' + decimal)\n}\n\nexport function toDegree (matrix) {\n  if (matrix.length < 5)\n    return 0\n  const scaled0 = Math.hypot(matrix[0], matrix[3]), scaled1 = Math.hypot(matrix[1], matrix[4])\n  return 0 === scaled0 || 0 === scaled1 ? 0 : 180 * Math.atan2(matrix[1] / scaled1, matrix[0] / scaled0) / Math.PI\n}\n","import { isFirefox, isAndroid } from '../utils'\n\nexport class AAC {\n  static FREQ = [\n    96000,\n    88200,\n    64000,\n    48000,\n    44100,\n    32000,\n    24000,\n    22050,\n    16000,\n    12000,\n    11025,\n    8000,\n    7350\n  ];\n\n  static getRateIndexByRate (rate) {\n    return AAC.FREQ.indexOf(rate)\n  }\n\n  static parseADTS (data, pts) {\n    const len = data.length\n    let i = 0\n\n    while ((i + 2) < len) {\n      if (data[i] === 0xff && (data[i + 1] & 0xf6) === 0xf0) {\n        break\n      }\n      i++\n    }\n\n    if (i >= len) return\n\n    const skip = i\n    const frames = []\n    const samplingFrequencyIndex = (data[i + 2] & 0x3c) >>> 2\n    const sampleRate = AAC.FREQ[samplingFrequencyIndex]\n    if (!sampleRate) throw new Error(`Invalid sampling index: ${samplingFrequencyIndex}`)\n    const objectType = ((data[i + 2] & 0xc0) >>> 6) + 1\n    const channelCount = ((data[i + 2] & 1) << 2) | ((data[i + 3] & 0xc0) >>> 6)\n    const { config, codec } = AAC._getConfig(samplingFrequencyIndex, channelCount, objectType)\n\n    let protectionSkipBytes\n    let frameLength\n    let frameIndex = 0\n    const duration = AAC.getFrameDuration(sampleRate)\n\n    while ((i + 7) < len) {\n      if ((data[i] !== 0xff) || (data[i + 1] & 0xF6) !== 0xf0) {\n        i++\n        continue\n      }\n\n      frameLength = ((data[i + 3] & 0x03) << 11) | (data[i + 4] << 3) | ((data[i + 5] & 0xe0) >> 5)\n      if (!frameLength || (len - i) < frameLength) break\n\n      protectionSkipBytes = (~data[i + 1] & 0x01) * 2\n      frames.push({\n        pts: pts + frameIndex * duration,\n        data: data.subarray(i + 7 + protectionSkipBytes, i + frameLength)\n      })\n\n      frameIndex++\n      i += frameLength\n    }\n\n    return {\n      skip,\n      remaining: i >= len ? undefined : data.subarray(i),\n      frames,\n      samplingFrequencyIndex,\n      sampleRate,\n      objectType,\n      channelCount,\n      codec,\n      config,\n      originCodec: `mp4a.40.${objectType}`\n    }\n  }\n\n  static parseAudioSpecificConfig (data) {\n    if (!data.length) return\n    const objectType = data[0] >>> 3\n    const samplingFrequencyIndex = ((data[0] & 0x07) << 1) | (data[1] >>> 7)\n    const channelCount = (data[1] & 0x78) >>> 3\n    const sampleRate = AAC.FREQ[samplingFrequencyIndex]\n    // play as no audio track stream\n    if (!sampleRate) return\n    const { config, codec } = AAC._getConfig(samplingFrequencyIndex, channelCount, objectType)\n\n    return {\n      samplingFrequencyIndex,\n      sampleRate,\n      objectType,\n      channelCount,\n      config,\n      codec,\n      originCodec: `mp4a.40.${objectType}`\n    }\n  }\n\n  static getFrameDuration (rate, timescale = 90000) {\n    return 1024 * timescale / rate\n  }\n\n  static _getConfig (samplingIndex, channelCount, originObjectType) {\n    const config = []\n    let objectType\n    let extensionSamplingIndex\n    if (isFirefox) {\n      if (samplingIndex >= 6) { // use SBR (HE-AAC)\n        objectType = 5\n        extensionSamplingIndex = samplingIndex - 3\n      } else { // use LC-AAC\n        objectType = 2\n        extensionSamplingIndex = samplingIndex\n      }\n    } else if (isAndroid) { // use LC-AAC\n      objectType = 2\n      extensionSamplingIndex = samplingIndex\n    } else { // use HE-AAC\n      objectType = 5\n      extensionSamplingIndex = samplingIndex\n\n      if (samplingIndex >= 6) {\n        extensionSamplingIndex = samplingIndex - 3\n      } else if (channelCount === 1) { // Mono channel, use LC-AAC\n        objectType = 2\n        extensionSamplingIndex = samplingIndex\n      }\n    }\n\n    config[0] = objectType << 3\n    config[0] |= (samplingIndex & 0x0e) >> 1\n    config[1] = (samplingIndex & 0x01) << 7\n    config[1] |= channelCount << 3\n    if (objectType === 5) {\n      config[1] |= ((extensionSamplingIndex & 0x0e) >> 1)\n      config[2] = (extensionSamplingIndex & 0x01) << 7\n      config[2] |= (2 << 2)\n      config[3] = 0\n    }\n\n    return {\n      config,\n      codec: `mp4a.40.${objectType}`\n    }\n  }\n\n  /* c8 ignore next 65 */\n  static getSilentFrame (codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80])\n        } if (channelCount === 2) {\n          return new Uint8Array([\n            0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80\n          ])\n        } if (channelCount === 3) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x8e\n          ])\n        } if (channelCount === 4) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38\n          ])\n        } if (channelCount === 5) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38\n          ])\n        } if (channelCount === 6) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2,\n            0x00, 0x20, 0x08, 0xe0\n          ])\n        }\n        break\n      default:\n        if (channelCount === 1) {\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e\n          ])\n        } if (channelCount === 2) {\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e\n          ])\n        } if (channelCount === 3) {\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e\n          ])\n        }\n        break\n    }\n  }\n}\n","import { readBig32 } from '../utils'\n\nexport class NALu {\n  /**\n   * @param {Uint8Array} data\n   * @returns {Uint8Array[]}\n   */\n  static parseAnnexB (data) {\n    let j = data.byteLength - 1\n    let dropZerosLength = 0\n    // Collect tailing zeros.\n    // end with 0x000000 and more...\n    do {\n      if (data[j] === 0x00) {\n        dropZerosLength++\n      } else {\n        break\n      }\n\n      j--\n    } while (j > 0)\n\n    if (dropZerosLength >= 3) {\n      // drop tailing zeros.\n      data = data.subarray(0, j + 1)\n    }\n\n    const len = data.length\n    let start = 2\n    let end = 0\n    while (data[start] !== null && data[start] !== undefined && data[start] !== 1) {\n      start++\n    }\n    start++\n    end = start + 2\n\n    if (end >= len) return []\n\n    const units = []\n\n    while (end < len) {\n      switch (data[end]) {\n        case 0:\n          if (data[end - 1] !== 0) {\n            end += 2\n            break\n          } else if (data[end - 2] !== 0) {\n            end++\n            break\n          } else if (end < len - 1 && data[end + 1] !== 1) {\n            end++\n            break\n          }\n\n          if (start !== end - 2) units.push(data.subarray(start, end - 2))\n\n          do {\n            end++\n          } while (data[end] !== 1 && end < len)\n          start = end + 1\n          end = start + 2\n          break\n        case 1:\n          if (data[end - 1] !== 0 || data[end - 2] !== 0) {\n            end += 3\n            break\n          }\n          if (start !== end - 2) units.push(data.subarray(start, end - 2))\n          start = end + 1\n          end = start + 2\n          break\n        default:\n          end += 3\n          break\n      }\n    }\n\n    if (start < len) units.push(data.subarray(start))\n\n    return units\n  }\n\n  static parseAvcC (data, size = 4) {\n    if (data.length < 4) return\n    const dataLen = data.length\n    const units = []\n\n    let offset = 0\n    let length\n    while ((offset + size) < dataLen) {\n      length = readBig32(data, offset)\n      if (size === 3) length >>>= 8\n      offset += size\n\n      if (!length) continue\n      if (offset + length > dataLen) {\n        break\n      }\n\n      units.push(data.subarray(offset, offset + length))\n      offset += length\n    }\n\n    return units\n  }\n\n  static parseSEI (unit, isHevc) {\n    const len = unit.length\n    let i = isHevc ? 2 : 1\n    let type = 0\n    let size = 0\n    let uuid = ''\n\n    while (unit[i] === 255) {\n      type += 255\n      i++\n    }\n\n    type += unit[i++]\n\n    while (unit[i] === 255) {\n      size += 255\n      i++\n    }\n    size += unit[i++]\n\n    if (type === 5 && len > i + 16) {\n      for (let j = 0; j < 16; j++) {\n        uuid += unit[i].toString(16)\n        i++\n      }\n    }\n\n    return {\n      payload: unit.subarray(i, i + size), type, size, uuid\n    }\n  }\n\n  static removeEPB (uint) {\n    const length = uint.byteLength\n    const emulationPreventionBytesPositions = []\n    let i = 1\n\n    while (i < length - 2) {\n      if (uint[i] === 0 && uint[i + 1] === 0 && uint[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2)\n        i += 2\n      } else {\n        i++\n      }\n    }\n\n    if (!emulationPreventionBytesPositions.length) return uint\n\n    const newLength = length - emulationPreventionBytesPositions.length\n    const newData = new Uint8Array(newLength)\n\n    let sourceIndex = 0\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        sourceIndex++\n        emulationPreventionBytesPositions.shift()\n      }\n      newData[i] = uint[sourceIndex]\n    }\n\n    return newData\n  }\n}\n","import { NALu } from './nalu'\nimport { ExpGolomb, getAvcCodec } from '../utils'\n\nexport class AVC {\n  static parseAVCDecoderConfigurationRecord (data) {\n    if (data.length < 7) return\n    const nalUnitSize = (data[4] & 3) + 1\n\n    let spsParsed\n    const spsArr = []\n    const ppsArr = []\n\n    let offset = 6\n    const spsCount = data[5] & 0x1f\n    let spsSize\n    for (let i = 0; i < spsCount; i++) {\n      spsSize = (data[offset] << 8) | data[offset + 1]\n      offset += 2\n      if (!spsSize) continue\n\n      const sps = data.subarray(offset, offset + spsSize)\n      offset += spsSize\n      spsArr.push(sps)\n\n      if (!spsParsed) {\n        spsParsed = AVC.parseSPS(NALu.removeEPB(sps))\n      }\n    }\n\n    const ppsCount = data[offset]\n    offset++\n    let ppsSize\n    for (let i = 0; i < ppsCount; i++) {\n      ppsSize = (data[offset] << 8) | data[offset + 1]\n      offset += 2\n      if (!ppsSize) continue\n      ppsArr.push(data.subarray(offset, offset + ppsSize))\n      offset += ppsSize\n    }\n\n    return {\n      sps: spsParsed,\n      spsArr,\n      ppsArr,\n      nalUnitSize\n    }\n  }\n\n  static parseSPS (unit) {\n    const eg = new ExpGolomb(unit)\n    eg.readUByte()\n\n    const profileIdc = eg.readUByte()\n    const profileCompatibility = eg.readUByte()\n    const levelIdc = eg.readUByte()\n    eg.skipUEG()\n\n    let chromaFormat = 420\n    if (\n      profileIdc === 100 ||\n      profileIdc === 110 ||\n      profileIdc === 122 ||\n      profileIdc === 244 ||\n      profileIdc === 44 ||\n      profileIdc === 83 ||\n      profileIdc === 86 ||\n      profileIdc === 118 ||\n      profileIdc === 128 ||\n      profileIdc === 138 ||\n      profileIdc === 144\n    ) {\n      const chromaFormatIdc = eg.readUEG()\n      if (chromaFormatIdc <= 3) chromaFormat = [0, 420, 422, 444][chromaFormatIdc]\n      if (chromaFormatIdc === 3) eg.skipBits(1)\n      eg.skipUEG()\n      eg.skipUEG()\n      eg.skipBits(1)\n      if (eg.readBool()) {\n        const scalingListCount = chromaFormatIdc !== 3 ? 8 : 12\n        for (let i = 0; i < scalingListCount; i++) {\n          if (eg.readBool()) {\n            if (i < 6) {\n              eg.skipScalingList(16)\n            } else {\n              eg.skipScalingList(64)\n            }\n          }\n        }\n      }\n    }\n\n    eg.skipUEG()\n    const picOrderCntType = eg.readUEG()\n    if (picOrderCntType === 0) {\n      eg.readUEG()\n    } else if (picOrderCntType === 1) {\n      eg.skipBits(1)\n      eg.skipUEG()\n      eg.skipUEG()\n      const numRefFramesInPicOrderCntCycle = eg.readUEG()\n      for (let i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        eg.skipUEG()\n      }\n    }\n\n    eg.skipUEG()\n    eg.skipBits(1)\n    const picWidthInMbsMinus1 = eg.readUEG()\n    const picHeightInMapUnitsMinus1 = eg.readUEG()\n    const frameMbsOnlyFlag = eg.readBits(1)\n    if (frameMbsOnlyFlag === 0) eg.skipBits(1)\n    eg.skipBits(1)\n\n    let frameCropLeftOffset = 0\n    let frameCropRightOffset = 0\n    let frameCropTopOffset = 0\n    let frameCropBottomOffset = 0\n\n    if (eg.readBool()) {\n      frameCropLeftOffset = eg.readUEG()\n      frameCropRightOffset = eg.readUEG()\n      frameCropTopOffset = eg.readUEG()\n      frameCropBottomOffset = eg.readUEG()\n    }\n\n    let sarRatio\n    let fixedFrame\n    let fpsNum\n    let fpsDen\n    let fps\n    if (eg.readBool()) {\n      if (eg.readBool()) {\n        const aspectRatioIdc = eg.readUByte()\n        switch (aspectRatioIdc) {\n          case 1: sarRatio = [1, 1]; break\n          case 2: sarRatio = [12, 11]; break\n          case 3: sarRatio = [10, 11]; break\n          case 4: sarRatio = [16, 11]; break\n          case 5: sarRatio = [40, 33]; break\n          case 6: sarRatio = [24, 11]; break\n          case 7: sarRatio = [20, 11]; break\n          case 8: sarRatio = [32, 11]; break\n          case 9: sarRatio = [80, 33]; break\n          case 10: sarRatio = [18, 11]; break\n          case 11: sarRatio = [15, 11]; break\n          case 12: sarRatio = [64, 33]; break\n          case 13: sarRatio = [160, 99]; break\n          case 14: sarRatio = [4, 3]; break\n          case 15: sarRatio = [3, 2]; break\n          case 16: sarRatio = [2, 1]; break\n          case 255: {\n            sarRatio = [\n              (eg.readUByte() << 8) | eg.readUByte(),\n              (eg.readUByte() << 8) | eg.readUByte()\n            ]\n            break\n          }\n          default:\n        }\n      }\n\n      if (eg.readBool()) eg.readBool()\n\n      if (eg.readBool()) {\n        eg.readBits(4)\n        if (eg.readBool()) eg.readBits(24)\n      }\n\n      if (eg.readBool()) {\n        eg.readUEG()\n        eg.readUEG()\n      }\n\n      if (eg.readBool()) {\n        const numUnitsInTick = eg.readBits(32)\n        const timeScale = eg.readBits(32)\n        fixedFrame = eg.readBool()\n\n        fpsNum = timeScale\n        fpsDen = numUnitsInTick * 2\n        fps = fpsNum / fpsDen\n      }\n    }\n\n    return {\n      codec: getAvcCodec(unit.subarray(1, 4)),\n      profileIdc,\n      profileCompatibility,\n      levelIdc,\n      chromaFormat,\n      width: Math.ceil(\n        (picWidthInMbsMinus1 + 1) * 16 -\n          2 * (frameCropLeftOffset + frameCropRightOffset)\n      ),\n      height:\n        (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 -\n        (frameMbsOnlyFlag ? 2 : 4) *\n          (frameCropTopOffset + frameCropBottomOffset),\n      sarRatio,\n      fpsNum,\n      fpsDen,\n      fps,\n      fixedFrame\n    }\n  }\n}\n","import { NALu } from './nalu'\nimport { ExpGolomb } from '../utils'\n\nexport class HEVC {\n  static parseHEVCDecoderConfigurationRecord (data, hvcC = {}) {\n    if (data.length < 23) return\n    hvcC = hvcC || {}\n    const nalUnitSize = (data[21] & 3) + 1\n\n    let vpsParsed\n    let spsParsed\n    const spsArr = []\n    const ppsArr = []\n    const vpsArr = []\n\n    let offset = 23\n    const numOfArrays = data[22]\n\n    let nalUnitType\n    let numNalus\n    let nalSize\n    for (let i = 0; i < numOfArrays; i++) {\n      nalUnitType = data[offset] & 0x3f\n      numNalus = (data[offset + 1] << 8) | data[offset + 2]\n\n      offset += 3\n\n      for (let j = 0; j < numNalus; j++) {\n        nalSize = (data[offset] << 8) | data[offset + 1]\n        offset += 2\n        if (!nalSize) continue\n        switch (nalUnitType) {\n          case 32: {\n            const vps = data.subarray(offset, offset + nalSize)\n            if (!vpsParsed) vpsParsed = HEVC.parseVPS(NALu.removeEPB(vps), hvcC)\n            vpsArr.push(vps)\n          }\n            break\n          case 33: {\n            const sps = data.subarray(offset, offset + nalSize)\n            if (!spsParsed) spsParsed = HEVC.parseSPS(NALu.removeEPB(sps), hvcC)\n            spsArr.push(sps)\n          }\n            break\n          case 34:\n            ppsArr.push(data.subarray(offset, offset + nalSize))\n            break\n          default:\n        }\n\n        offset += nalSize\n      }\n    }\n\n    return {\n      hvcC,\n      sps: spsParsed,\n      spsArr,\n      ppsArr,\n      vpsArr,\n      nalUnitSize\n    }\n  }\n\n  static parseVPS (unit, hvcC) {\n    hvcC = hvcC || {}\n    const eg = new ExpGolomb(unit)\n    eg.readUByte()\n    eg.readUByte()\n\n    eg.readBits(12)\n    const vpsMaxSubLayersMinus1 = eg.readBits(3)\n    hvcC.numTemporalLayers = Math.max(hvcC.numTemporalLayers || 0, vpsMaxSubLayersMinus1 + 1)\n    eg.readBits(17)\n    HEVC._parseProfileTierLevel(eg, vpsMaxSubLayersMinus1, hvcC)\n\n    return hvcC\n  }\n\n  static parseSPS (unit, hvcC = {}) {\n    hvcC = hvcC || {}\n    const eg = new ExpGolomb(unit)\n    eg.readUByte()\n    eg.readUByte()\n\n    eg.readBits(4)\n    const spsMaxSubLayersMinus1 = eg.readBits(3)\n    hvcC.numTemporalLayers = Math.max(spsMaxSubLayersMinus1 + 1, hvcC.numTemporalLayers || 0)\n    hvcC.temporalIdNested = eg.readBits(1)\n    HEVC._parseProfileTierLevel(eg, spsMaxSubLayersMinus1, hvcC)\n\n    eg.readUEG() // sps_seq_parameter_set_id\n\n    const chromaFormatIdc = hvcC.chromaFormatIdc = eg.readUEG()\n    let chromaFormat = 420\n    if (chromaFormatIdc <= 3) chromaFormat = [0, 420, 422, 444][chromaFormatIdc]\n\n    let separateColourPlaneFlag = 0\n    if (chromaFormatIdc === 3) {\n      separateColourPlaneFlag = eg.readBits(1)\n    }\n\n    let width = eg.readUEG() // pic_width_in_luma_samples\n    let height = eg.readUEG() // pic_height_in_luma_samples\n\n    const conformanceWindowFlag = eg.readBits(1)\n\n    let confWinLeftOffset\n    let confWinRightOffset\n    let confWinTopOffset\n    let confWinBottomOffset\n    if (conformanceWindowFlag === 1) {\n      confWinLeftOffset = eg.readUEG() // conf_win_left_offset\n      confWinRightOffset = eg.readUEG() // conf_win_right_offset\n      confWinTopOffset = eg.readUEG() // conf_win_top_offset\n      confWinBottomOffset = eg.readUEG() // conf_win_bottom_offset\n    }\n\n    hvcC.bitDepthLumaMinus8 = eg.readUEG() // bit_depth_luma_minus8\n    hvcC.bitDepthChromaMinus8 = eg.readUEG() // bit_depth_chroma_minus8\n\n    if (conformanceWindowFlag === 1) {\n      const subWidthC = (((chromaFormatIdc === 1) || (chromaFormatIdc === 2)) && (separateColourPlaneFlag === 0)) ? 2 : 1\n      const subHeightC = ((chromaFormatIdc === 1) && (separateColourPlaneFlag === 0)) ? 2 : 1\n      width -= (subWidthC * (confWinRightOffset + confWinLeftOffset))\n      height -= (subHeightC * (confWinBottomOffset + confWinTopOffset))\n    }\n\n    return {\n      codec: 'hev1.1.6.L93.B0',\n      width,\n      height,\n      chromaFormat,\n      hvcC\n    }\n  }\n\n  static _parseProfileTierLevel (eg, maxSubLayersMinus1, hvcC) {\n    const generalTierFlag = hvcC.generalTierFlag || 0\n    hvcC.generalProfileSpace = eg.readBits(2)\n    hvcC.generalTierFlag = Math.max(eg.readBits(1), generalTierFlag)\n    hvcC.generalProfileIdc = Math.max(eg.readBits(5), hvcC.generalProfileIdc || 0)\n    hvcC.generalProfileCompatibilityFlags = eg.readBits(32)\n    hvcC.generalConstraintIndicatorFlags = [eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8)]\n    const generalLevelIdc = eg.readBits(8)\n    if (generalTierFlag < hvcC.generalTierFlag) {\n      hvcC.generalLevelIdc = generalLevelIdc\n    } else {\n      hvcC.generalLevelIdc = Math.max(generalLevelIdc, hvcC.generalLevelIdc || 0)\n    }\n\n    const subLayerProfilePresentFlag = []\n    const subLayerLevelPresentFlag = []\n\n    if (maxSubLayersMinus1 > eg.bitsAvailable) {\n      throw new Error(`maxSubLayersMinus inavlid size ${maxSubLayersMinus1}`)\n    }\n\n    for (let j = 0; j < maxSubLayersMinus1; j++) {\n      subLayerProfilePresentFlag[j] = eg.readBits(1)\n      subLayerLevelPresentFlag[j] = eg.readBits(1)\n    }\n\n    if (maxSubLayersMinus1 > 0) {\n      eg.readBits((8 - maxSubLayersMinus1) * 2)\n    }\n\n    for (let i = 0; i < maxSubLayersMinus1; i++) {\n      if (subLayerProfilePresentFlag[i] !== 0) {\n        eg.readBits(2)\n        eg.readBits(1)\n        eg.readBits(5)\n\n        eg.readBits(16)\n        eg.readBits(16)\n\n        eg.readBits(4)\n\n        eg.readBits(16)\n        eg.readBits(16)\n        eg.readBits(12)\n      }\n      if (subLayerLevelPresentFlag[i] !== 0) {\n        eg.readBits(8)\n      }\n    }\n  }\n}\n","/**\n * Opus documentation, https://opus-codec.org/docs/\n * Ogg Encapsulation for the Opus Audio Codec, https://datatracker.ietf.org/doc/html/rfc7845.html\n *\n * Packet Organization:\n *\n *      Page 0         Pages 1 ... n        Pages (n+1) ...\n *    +------------+ +---+ +---+ ... +---+ +-----------+ +---------+ +--\n *    |            | |   | |   |     |   | |           | |         | |\n *    |+----------+| |+-----------------+| |+-------------------+ +-----\n *    |||ID Header|| ||  Comment Header || ||Audio Data Packet 1| | ...\n *    |+----------+| |+-----------------+| |+-------------------+ +-----\n *    |            | |   | |   |     |   | |           | |         | |\n *    +------------+ +---+ +---+ ... +---+ +-----------+ +---------+ +--\n *    ^      ^                           ^\n *    |      |                           |\n *    |      |                           Mandatory Page Break\n *    |      |\n *    |      ID header is contained on a single page\n *    |\n *    'Beginning Of Stream'\n */\nexport class OPUS {\n  static getFrameDuration (samples, timescale = 1000) {\n    return 20\n  }\n\n  /**\n   * Identification Header + Comment Header\n   * @param {Uint8Array} data\n   */\n  static parseHeaderPackets (data) {\n    if (!data.length) return\n\n    const dv = new DataView(data.buffer, data.byteOffset, data.byteLength)\n\n    // Identification Header\n    let magicSignature = ''\n    for (let i = 0; i < 8; i++) {\n      magicSignature += String.fromCodePoint(data[i])\n    }\n    if (magicSignature !== 'OpusHead') {\n      throw new Error('Invalid Opus MagicSignature')\n    }\n\n    // skip version\n    // data[8]\n    // console.log('Pre-skip', data[8])\n\n    const channelCount = data[9]\n\n    // skip Pre-skip\n    // data[10] & data[11]\n    console.log('Pre-skip', data[10], data[11])\n\n    const sampleRate = dv.getUint32(12, true)\n    const outputGain = dv.getInt16(16, true)\n\n    // const mappingFamily = dv.getUint8(18)\n\n    // play as no audio track stream\n    if (!sampleRate) return\n\n    const codec = 'opus'\n    const originCodec = 'opus'\n    const config = new Uint8Array(data.buffer, data.byteOffset + 8, data.byteLength - 8)\n\n    return {\n      outputGain,\n      sampleRate,\n      channelCount,\n      config,\n      codec,\n      originCodec\n    }\n  }\n}\n","import { isFirefox } from '../utils'\n\nconst BitratesMap = [\n  32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56,\n  64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80,\n  96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144,\n  160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144,\n  160\n]\n\nconst FREQ = [\n  44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000\n]\n\nconst SamplesCoefficients = [\n  // MPEG 2.5\n  [\n    0, // Reserved\n    72, // Layer3\n    144, // Layer2\n    12 // Layer1\n  ],\n  // Reserved\n  [\n    0, // Reserved\n    0, // Layer3\n    0, // Layer2\n    0 // Layer1\n  ],\n  // MPEG 2\n  [\n    0, // Reserved\n    72, // Layer3\n    144, // Layer2\n    12 // Layer1\n  ],\n  // MPEG 1\n  [\n    0, // Reserved\n    144, // Layer3\n    144, // Layer2\n    12 // Layer1\n  ]\n]\n\nconst BytesInSlot = [\n  0, // Reserved\n  1, // Layer3\n  1, // Layer2\n  4 // Layer1\n]\n\nlet chromeVersion = null\n\nexport class MPEG {\n  static isHeader (data, offset) {\n    return offset + 1 < data.length && (\n      data[offset] === 0xff &&\n      (data[offset + 1] & 0xe0) === 0xe0 &&\n      (data[offset + 1] & 0x06) !== 0x00\n    )\n  }\n\n  static appendFrame (\n    track,\n    data,\n    offset,\n    pts,\n    frameIndex\n  ) {\n    if (offset + 24 > data.length) {\n      return\n    }\n\n    const header = MPEG.parseHeader(data, offset)\n    if (header && offset + header.frameLength <= data.length) {\n      const frameDuration = (header.samplesPerFrame * 90000) / header.sampleRate\n      const stamp = pts + frameIndex * frameDuration\n      const sample = {\n        data: data.subarray(offset, offset + header.frameLength),\n        pts: stamp,\n        dts: stamp\n      }\n      sample.size = sample.data.byteLength\n      track.config = []\n      track.channelCount = header.channelCount\n      track.sampleRate = header.sampleRate\n      if (isFirefox) {\n        track.codec = 'mp3'\n      } else {\n        track.container = 'audio/mpeg'\n      }\n      track.samples.push(sample)\n\n      return { length: header.frameLength }\n    }\n  }\n\n  static parseHeader (data, offset) {\n    const mpegVersion = (data[offset + 1] >> 3) & 3\n    const mpegLayer = (data[offset + 1] >> 1) & 3\n    const bitRateIndex = (data[offset + 2] >> 4) & 15\n    const sampleRateIndex = (data[offset + 2] >> 2) & 3\n    if (\n      mpegVersion !== 1 &&\n      bitRateIndex !== 0 &&\n      bitRateIndex !== 15 &&\n      sampleRateIndex !== 3\n    ) {\n      const paddingBit = (data[offset + 2] >> 1) & 1\n      const channelMode = data[offset + 3] >> 6\n      const columnInBitrates =\n        mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4\n      const bitRate =\n        BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000\n      const columnInSampleRates =\n        mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2\n      const sampleRate = FREQ[columnInSampleRates * 3 + sampleRateIndex]\n      const channelCount = channelMode === 3 ? 1 : 2\n      const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer]\n      const bytesInSlot = BytesInSlot[mpegLayer]\n      const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot\n      const frameLength =\n        Math.floor((sampleCoefficient * bitRate) / sampleRate + paddingBit) *\n        bytesInSlot\n\n      if (chromeVersion === null) {\n        const userAgent = navigator.userAgent || ''\n        const result = userAgent.match(/Chrome\\/(\\d+)/i)\n        chromeVersion = result ? parseInt(result[1]) : 0\n      }\n      const needChromeFix = !!chromeVersion && chromeVersion <= 87\n\n      if (\n        needChromeFix &&\n        mpegLayer === 2 &&\n        bitRate >= 224000 &&\n        channelMode === 0\n      ) {\n        data[offset + 3] = data[offset + 3] | 0x80\n      }\n\n      return { sampleRate, channelCount, frameLength, samplesPerFrame }\n    }\n  }\n}","import { AudioCodecType, AudioSample, WarningType } from '../model'\nimport { AAC, OPUS } from '../codec'\nimport { isSafari } from '../utils'\n\nconst LARGE_AV_FIRST_FRAME_GAP = 500 // ms\nconst AUDIO_GAP_OVERLAP_THRESHOLD_COUNT = 3\nconst MAX_SILENT_FRAME_DURATION = 1000 // ms\nconst AUDIO_EXCEPTION_LOG_EMIT_DURATION = 5000 // 5s\nconst MAX_VIDEO_FRAME_DURATION = 1000 // ms\nconst MAX_DTS_DELTA_WITH_NEXT_CHUNK = 200 // ms\nconst VIDEO_EXCEPTION_LOG_EMIT_DURATION = 5000 // 5s\nconst TRACK_BROKEN_CHECK_TIME = 5\n\nexport class FlvFixer {\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n    this.metadataTrack = metadataTrack\n\n    this._baseDts = -1\n    this._baseDtsInited = false\n\n    this._audioNextPts = undefined\n    this._videoNextDts = undefined\n\n    this._audioTimestampBreak = 0\n    this._videoTimestampBreak = 0\n    this._lastVideoDuration = 0\n\n    // 在视频帧遇到下一个关键帧之前，如果音频时间戳发生了跳变，不能确定是否音视频都发生跳变还是单纯音频发生跳变.\n    // 这里记录关键帧标识, 从下一个关键帧开始，如果视频没有跳变，才能判断是只有音频发生了跳变\n    this._keyFrameInNextChunk = false\n\n    this._lastAudioExceptionGapDot = -Infinity\n    this._lastAudioExceptionOverlapDot = -Infinity\n    this._lastAudioExceptionLargeGapDot = -Infinity\n\n    this._lastVideoExceptionLargeGapDot = -Infinity\n    this._lastVideoExceptionChunkFirstDtsDot = -Infinity\n  }\n\n  /**\n   * @param {number} startTime 点播seek到的时间点\n   * @param {boolean} discontinuity 是否换流\n   * @param {boolean} contiguous 前后chunk时间戳是否连续\n   */\n  fix (startTime = 0, discontinuity = false, contiguous = true) {\n    startTime = Math.round(startTime * 1000)\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    if (discontinuity || !contiguous) {\n      this._videoLastSample = null\n      this._audioNextPts = undefined\n      this._videoNextDts = undefined\n      this._audioTimestampBreak = 0\n      this._videoTimestampBreak = 0\n      this._lastAudioExceptionGapDot = -Infinity\n      this._lastAudioExceptionOverlapDot = -Infinity\n      this._lastAudioExceptionLargeGapDot = -Infinity\n      this._lastVideoExceptionLargeGapDot = -Infinity\n      this._lastVideoExceptionChunkFirstDtsDot = -Infinity\n    }\n\n    if (discontinuity && !contiguous) {\n      this._baseDtsInited = false\n    }\n\n    if (!this._baseDtsInited) {\n      this._calculateBaseDts(audioTrack, videoTrack)\n    }\n\n    if (!contiguous && startTime) {\n      this._audioNextPts = this._videoNextDts = startTime\n    }\n\n    const resetBaseDts = this._baseDtsInited &&\n      (this._videoTimestampBreak || !this.videoTrack.exist()) &&\n      (this._audioTimestampBreak || !this.audioTrack.exist())\n\n    if (resetBaseDts) {\n      this._resetBaseDtsWhenStreamBreaked()\n    }\n\n    this._fixAudio(audioTrack)\n\n    this._keyFrameInNextChunk = false\n\n    this._fixVideo(videoTrack)\n\n    if (this.metadataTrack.exist()) {\n      const timescale = this.metadataTrack.timescale\n      this.metadataTrack.seiSamples.forEach(s => {\n        s.pts = s.originPts - this._baseDts\n        s.time = Math.max(0, s.pts) / timescale\n      })\n      this.metadataTrack.flvScriptSamples.forEach(s => {\n        s.pts = s.originPts - this._baseDts\n        s.time = Math.max(0, s.pts) / timescale\n      })\n    }\n\n    if (videoTrack.samples.length) {\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n    }\n    if (audioTrack.samples.length) {\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts * audioTrack.timescale / 1000\n    }\n  }\n\n  _fixVideo (videoTrack) {\n    const samples = videoTrack.samples\n\n    if (!samples.length) return\n\n    samples.forEach(x => {\n      x.dts -= this._baseDts\n      x.pts -= this._baseDts\n      if (x.keyframe) this._keyFrameInNextChunk = true\n    })\n\n    let refSampleDurationInt\n    if (videoTrack.fpsNum && videoTrack.fpsDen) {\n      refSampleDurationInt = videoTrack.timescale * (videoTrack.fpsDen / videoTrack.fpsNum)\n    } else if (videoTrack.length > 1) {\n      const first = videoTrack.samples[0]\n      const last = videoTrack.samples[samples.length - 1]\n      refSampleDurationInt = Math.floor((last.dts - first.dts) / (samples.length - 1))\n    } else {\n      refSampleDurationInt = this._lastVideoDuration || 40\n    }\n\n    const lastSample = samples.pop()\n\n    if (this._videoLastSample) {\n      samples.unshift(this._videoLastSample)\n    }\n\n    this._videoLastSample = lastSample\n\n    if (!samples.length) return\n\n    if (this._videoNextDts === undefined) {\n      const samp0 = samples[0]\n      this._videoNextDts = samp0.dts\n    }\n\n    const len = samples.length\n    let sampleDuration = 0\n    const firstSample = samples[0]\n    const vDelta = this._videoNextDts - firstSample.dts\n\n    if (Math.abs(vDelta) > MAX_DTS_DELTA_WITH_NEXT_CHUNK) {\n      // emit large delta of first sample with expect\n      if (Math.abs(firstSample.dts - this._lastVideoExceptionChunkFirstDtsDot) > VIDEO_EXCEPTION_LOG_EMIT_DURATION) {\n        this._lastVideoExceptionChunkFirstDtsDot = firstSample.dts\n\n        videoTrack.warnings.push({\n          type: WarningType.LARGE_VIDEO_GAP_BETWEEN_CHUNK,\n          nextDts: this._videoNextDts,\n          firstSampleDts: firstSample.dts,\n          nextSampleDts: samples[1]?.dts,\n          sampleDuration: vDelta\n        })\n      }\n\n      // only video break\n      if (this._videoTimestampBreak >= TRACK_BROKEN_CHECK_TIME) {\n        this._videoNextDts = firstSample.dts\n        this._videoTimestampBreak = 0\n      } else {\n        // resolve first frame only\n        firstSample.dts += vDelta\n        firstSample.pts += vDelta\n        if (!this.audioTrack.exist()) {\n          this._videoTimestampBreak = 1\n        }\n      }\n    }\n\n    for (let i = 0; i < len; i++) {\n      const dts = samples[i].dts\n      const nextSample = samples[i + 1]\n\n      if (i < len - 1) {\n        sampleDuration = nextSample.dts - dts\n      } else if (lastSample) {\n        sampleDuration = lastSample.dts - dts\n      } else {\n        sampleDuration = refSampleDurationInt\n      }\n\n      if (sampleDuration > MAX_VIDEO_FRAME_DURATION || sampleDuration < 0) {\n        this._videoTimestampBreak++\n        // emit stream break\n        if (Math.abs(dts - this._lastVideoExceptionLargeGapDot) > VIDEO_EXCEPTION_LOG_EMIT_DURATION) {\n          this._lastVideoExceptionLargeGapDot = dts\n          videoTrack.warnings.push({\n            type: WarningType.LARGE_VIDEO_GAP,\n            time: dts / videoTrack.timescale,\n            dts,\n            originDts: samples[i].originDts,\n            nextDts: this._videoNextDts,\n            sampleDuration,\n            refSampleDuration: refSampleDurationInt\n          })\n        }\n\n        sampleDuration = refSampleDurationInt\n      }\n\n      samples[i].duration = sampleDuration\n      this._videoNextDts += sampleDuration\n      this._lastVideoDuration = sampleDuration\n    }\n  }\n\n  _fixAudio (audioTrack) {\n    const samples = audioTrack.samples\n    if (!samples.length) return\n\n    // offset origin timestamp\n    samples.forEach(x => {\n      x.dts = x.pts -= this._baseDts\n    })\n\n    this._doFixAudioInternal(audioTrack, samples, 1000)\n  }\n\n  _calculateBaseDts (audioTrack, videoTrack) {\n    const audioSamps = audioTrack.samples\n    const videoSamps = videoTrack.samples\n\n    if (!audioSamps.length && !videoSamps.length) {\n      return false\n    }\n\n    let audioBasePts = Infinity\n    let videoBaseDts = Infinity\n\n    if (audioSamps.length) {\n      audioTrack.baseDts = audioBasePts = audioSamps[0].pts\n    }\n\n    if (videoSamps.length) {\n      videoTrack.baseDts = videoBaseDts = videoSamps[0].dts\n    }\n\n    this._baseDts = Math.min(audioBasePts, videoBaseDts)\n\n    const delta = videoBaseDts - audioBasePts\n\n    if (Number.isFinite(delta) && Math.abs(delta) > LARGE_AV_FIRST_FRAME_GAP) {\n      videoTrack.warnings.push({\n        type: WarningType.LARGE_AV_SHIFT,\n        videoBaseDts,\n        audioBasePts,\n        baseDts: this._baseDts,\n        delta\n      })\n    }\n\n    this._baseDtsInited = true\n    return true\n  }\n\n  _resetBaseDtsWhenStreamBreaked () {\n    /**\n       * timestamp break\n       *                     _audioNextDts\n       *  ---------------------|\n       * (_baseDts)          _videoNextDts\n       * ----------------------|\n       *                        <----------------\n       *                                       nextVideo.dts\n       * ----------------------------------------|\n       *                                       nextAudio.dts\n       * ---------------------------------------|\n       */\n\n    // calc baseDts base on new samples\n    const calc = this._calculateBaseDts(this.audioTrack, this.videoTrack)\n\n    if (!calc) return\n\n    // consider the expect dts for next frame\n    if (!this.audioTrack.exist()){\n      this._baseDts -= this._videoNextDts\n    } else if (!this.videoTrack.exist()){\n      this._baseDts -= this._audioNextPts\n    } else {\n      this._baseDts -= Math.min(this._audioNextPts, this._videoNextDts)\n    }\n    this._videoTimestampBreak = 0\n    this._audioTimestampBreak = 0\n  }\n\n  _doFixAudioInternal (audioTrack, samples, timescale) {\n    if (!audioTrack.sampleDuration) {\n      switch (audioTrack.codecType) {\n        case AudioCodecType.AAC: {\n          audioTrack.sampleDuration = AAC.getFrameDuration(audioTrack.timescale, timescale)\n          break\n        }\n        case AudioCodecType.OPUS: {\n          audioTrack.sampleDuration = OPUS.getFrameDuration(audioTrack.samples, timescale)\n          break\n        }\n        case AudioCodecType.G711PCMA:\n        case AudioCodecType.G711PCMU: {\n          audioTrack.sampleDuration = this._getG711Duration(audioTrack)\n          break\n        }\n        default:\n          console.error('can\\'t fix audio codecType:', audioTrack.codecType)\n          break\n      }\n    }\n    const refSampleDuration = audioTrack.sampleDuration\n\n    const sampleDurationInSampleRate =\n      audioTrack.codecType === AudioCodecType.OPUS\n        ? 20\n        : audioTrack.codecType === AudioCodecType.AAC\n          ? 1024\n          : (refSampleDuration * audioTrack.timescale) / 1000\n\n    if (this._audioNextPts === undefined) {\n      const samp0 = samples[0]\n      this._audioNextPts = samp0.pts\n    }\n\n    for (let i = 0; i < samples.length; i++) {\n      let nextPts = this._audioNextPts\n      const sample = samples[i]\n      let delta = sample.pts - nextPts\n\n      // only audio break\n      if (i === 0 && this._audioTimestampBreak >= TRACK_BROKEN_CHECK_TIME && this._keyFrameInNextChunk) {\n        nextPts = this._audioNextPts = sample.dts\n        delta = 0\n        this._audioTimestampBreak = 0\n      }\n\n      // fill frames\n      // delta >= 3 * refSampleDurationInt\n      // delta <= 500s\n      if (!this._audioTimestampBreak && delta >= AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta <= MAX_SILENT_FRAME_DURATION && !isSafari) {\n        const silentFrame = this._getSilentFrame(audioTrack) || samples[0].data.subarray()\n        const count = Math.floor(delta / refSampleDuration)\n\n        if (Math.abs(sample.pts - this._lastAudioExceptionGapDot) > AUDIO_EXCEPTION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionGapDot = sample.pts\n          audioTrack.warnings.push({\n            type: WarningType.AUDIO_FILLED,\n            pts: sample.pts,\n            originPts: sample.originPts,\n            count,\n            nextPts,\n            refSampleDuration\n          })\n        }\n\n        for (let j = 0; j < count; j++) {\n          const silentSample = new AudioSample(Math.floor(this._audioNextPts + refSampleDuration) - Math.floor(this._audioNextPts), silentFrame, sampleDurationInSampleRate)\n          silentSample.originPts = Math.floor(this._baseDts + nextPts)\n          samples.splice(i, 0, silentSample)\n          this._audioNextPts += refSampleDuration\n          i++\n        }\n\n        i--\n        // delta  <= -3 * refSampleDurationInt\n        // delta  >= -500ms\n      } else if (delta <= -AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta >= -1 * MAX_SILENT_FRAME_DURATION) {\n        // need discard frames\n        if (Math.abs(sample.pts - this._lastAudioExceptionOverlapDot) > AUDIO_EXCEPTION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionOverlapDot = sample.pts\n\n          audioTrack.warnings.push({\n            type: WarningType.AUDIO_DROPPED,\n            pts: sample.pts,\n            originPts: sample.originPts,\n            nextPts,\n            refSampleDuration\n          })\n        }\n        samples.splice(i, 1)\n        i--\n      } else {\n        if (Math.abs(delta) > MAX_SILENT_FRAME_DURATION) {\n          this._audioTimestampBreak++\n\n          if (Math.abs(sample.pts - this._lastAudioExceptionLargeGapDot) > AUDIO_EXCEPTION_LOG_EMIT_DURATION) {\n            this._lastAudioExceptionLargeGapDot = sample.pts\n            audioTrack.warnings.push({\n              type: WarningType.LARGE_AUDIO_GAP,\n              time: sample.pts / 1000,\n              pts: sample.pts,\n              originPts: sample.originPts,\n              nextPts,\n              sampleDuration: delta,\n              refSampleDuration\n            })\n          }\n        }\n\n        if (audioTrack.codecType === AudioCodecType.OPUS) {\n          const lastSample = samples[samples.length - 1]\n          if (lastSample) {\n            lastSample.duration = sample.pts - lastSample.pts\n          }\n        } else {\n          sample.dts = sample.pts = nextPts\n          sample.duration = sampleDurationInSampleRate\n        }\n        this._audioNextPts += refSampleDuration\n      }\n    }\n  }\n\n  _getG711Duration (track) {\n    const { sampleSize, channelCount, sampleRate } = track\n    const samp0 = track.samples[0]\n    if (!samp0) return\n    return samp0.data.byteLength * 2 / channelCount / (sampleSize / 8) / sampleRate * 1000\n  }\n\n  _getSilentFrame (track) {\n    if (track.codecType === AudioCodecType.AAC) return AAC.getSilentFrame(track.codec, track.channelCount)\n    return new Uint8Array(8 * track.sampleDuration * track.channelCount)\n  }\n}\n","import { UTF8 } from '../utils'\n\nexport class AMF {\n  static parse (data) {\n    if (data.length < 3) return\n\n    const ret = {}\n    const name = AMF._parseValue(new DataView(data.buffer, data.byteOffset, data.byteLength))\n    const value = AMF._parseValue(new DataView(data.buffer, data.byteOffset + name.size, data.byteLength - name.size))\n    ret[name.data] = value.data\n\n    return ret\n  }\n\n  static _parseValue (view) {\n    const dataLen = view.byteLength\n    const type = view.getUint8(0)\n    let offset = 1\n    let isEnd = false\n    let value\n\n    switch (type) {\n      case 0: // Number(Double) type\n        value = view.getFloat64(1)\n        offset += 8\n        break\n      case 1: { // Boolean type\n        value = !!view.getUint8(1)\n        offset += 1\n        break\n      }\n      case 2: { // String type\n        const { data, size } = AMF._parseString(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset))\n        value = data\n        offset += size\n      }\n        break\n      case 3: { // Object(s) type\n        value = {}\n        let terminal = 0\n        if ((view.getUint32(dataLen - 4) & 0x00FFFFFF) === 9) {\n          terminal = 3\n        }\n        while (offset < dataLen - 4) { // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n          const { size, data, isEnd } = AMF._parseObject(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset - terminal))\n          if (isEnd) break\n          value[data.name] = data.value\n          offset += size\n        }\n        if (offset <= dataLen - 3) {\n          const marker = view.getUint32(offset - 1) & 0x00FFFFFF\n          if (marker === 9) offset += 3\n        }\n      }\n        break\n      case 8: { // ECMA array type (Mixed array)\n        value = {}\n        offset += 4 // ECMAArrayLength(UI32)\n        let terminal = 0 // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n        if ((view.getUint32(dataLen - 4) & 0x00FFFFFF) === 9) {\n          terminal = 3\n        }\n        while (offset < dataLen - 8) { // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n          const { size, data, isEnd } = AMF._parseObject(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset - terminal))\n          if (isEnd) break\n          value[data.name] = data.value\n          offset += size\n        }\n        if (offset <= dataLen - 3) {\n          const marker = view.getUint32(offset - 1) & 0x00FFFFFF\n          if (marker === 9) {\n            offset += 3\n          }\n        }\n      }\n        break\n      case 9: // ScriptDataObjectEnd\n        value = undefined\n        offset = 1\n        isEnd = true\n        break\n      case 10: { // Strict array type\n        value = []\n        const strictArrayLength = view.getUint32(1)\n        offset += 4\n        for (let i = 0; i < strictArrayLength; i++) {\n          const { data, size } = AMF._parseValue(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset))\n          value.push(data)\n          offset += size\n        }\n      }\n        break\n      case 11: { // Date type\n        const timestamp = view.getFloat64(offset) + view.getInt16(offset + 8) * 60000\n        value = new Date(timestamp)\n        offset += 10\n      }\n        break\n      case 12: { // Long string type\n        const length = view.getUint32(1)\n        offset += 4\n        value = ''\n        if (length > 0) {\n          value = UTF8.decode(new Uint8Array(view.buffer, view.byteOffset + offset, length))\n        }\n        offset += length\n      }\n        break\n      default:\n        offset = dataLen\n        break\n    }\n\n    return {\n      data: value,\n      size: offset,\n      isEnd\n    }\n  }\n\n  static _parseString (view) {\n    const length = view.getUint16(0)\n    let data = ''\n    if (length > 0) {\n      data = UTF8.decode(new Uint8Array(view.buffer, view.byteOffset + 2, length))\n    }\n\n    return {\n      data,\n      size: 2 + length\n    }\n  }\n\n  static _parseObject (view) {\n    if (view.byteLength < 3) return\n\n    const name = AMF._parseString(view)\n    const value = AMF._parseValue(new DataView(view.buffer, view.byteOffset + name.size, view.byteLength - name.size))\n\n    return {\n      data: {\n        name: name.data,\n        value: value.data\n      },\n      size: name.size + value.size,\n      isEnd: value.isEnd\n    }\n  }\n}\n","/**\n * AudioData\n * @property {number} FlvSoundFormat\n */\nexport const FlvSoundFormat = {\n  MP3: 2,\n  G711A: 7, // G.711 A-law logarithmic PCM\n  G711M: 8, // G.711 mu-law logarithmic PCM\n  AAC: 10, // AAC\n  OPUS: 13\n}\n\n","import { VideoTrack, AudioTrack, MetadataTrack, AudioSample, VideoSample, VideoCodecType, AudioCodecType, FlvScriptSample, SeiSample } from '../model'\nimport { FlvFixer } from './fixer'\nimport { concatUint8Array, Logger, readBig32 } from '../utils'\nimport { AAC, AVC, HEVC, NALu } from '../codec'\nimport { AMF } from './amf'\nimport { FlvSoundFormat } from './soundFormat'\nimport { OPUS } from '../codec/opus'\n\nconst logger = new Logger('FlvDemuxer')\n\n/**\n * @typedef {Object} DemuxResult\n * @property {VideoTrack} videoTrack\n * @property {AudioTrack} audioTrack\n * @property {MetadataTrack} metadataTrack\n */\n\nexport class FlvDemuxer {\n  _headerParsed = false\n  _remainingData = null\n  _gopId = 0\n  _needAddMetaBeforeKeyFrameNal = true // 标识H265流中关键帧Nal之前是否需要插入vps、sps、pps Nal\n\n  static AUDIO_RATE = [5500, 11000, 22000, 44000]\n\n  /**\n   * @param {VideoTrack} [videoTrack]\n   * @param {AudioTrack} [audioTrack]\n   * @param {MetadataTrack} [metadataTrack]\n   */\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack || new VideoTrack()\n    this.audioTrack = audioTrack || new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n    this._fixer = new FlvFixer(this.videoTrack, this.audioTrack, this.metadataTrack)\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false] 切流\n   * @param {boolean} [contiguous=true]\n   * @returns {DemuxResult}\n   */\n  demux (data, discontinuity = false, contiguous = true, seamlessLoadingSwitching) {\n    const { audioTrack, videoTrack, metadataTrack } = this\n\n    if (discontinuity || !contiguous) {\n      this._remainingData = null\n    }\n\n    if (discontinuity) {\n      this._headerParsed = false\n    }\n\n    if (discontinuity) {\n      videoTrack.reset()\n      audioTrack.reset()\n      metadataTrack.reset()\n    } else {\n      videoTrack.samples = []\n      audioTrack.samples = []\n      metadataTrack.seiSamples = []\n      metadataTrack.flvScriptSamples = []\n      videoTrack.warnings = []\n      audioTrack.warnings = []\n\n      if (this._remainingData) {\n        data = concatUint8Array(this._remainingData, data)\n        this._remainingData = null\n      }\n    }\n\n    if (!data.length) {\n      return {\n        videoTrack,\n        audioTrack,\n        metadataTrack\n      }\n    }\n\n    let offset = 0\n    if (!this._headerParsed) {\n      if (!FlvDemuxer.probe(data)) {\n        throw new Error('Invalid flv file')\n      }\n      audioTrack.present = ((data[4] & 4) >>> 2) !== 0\n      videoTrack.present = (data[4] & 1) !== 0\n      this._headerParsed = true\n      offset = readBig32(data, 5) + 4 // skip prev tag size\n    }\n\n    const dataLen = data.length\n\n    let tagType\n    let dataSize\n    let timestamp\n    let bodyData\n    let prevTagSize\n    while ((offset + 15) < dataLen) { // header and prev tag size\n      tagType = data[offset]\n      dataSize = (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3]\n      if (offset + 15 + dataSize > dataLen) break\n      timestamp = (\n        (data[offset + 7] << 24 >>> 0) +\n        (data[offset + 4] << 16) +\n        (data[offset + 5] << 8) +\n        data[offset + 6]\n      )\n\n      offset += 11\n      bodyData = data.subarray(offset, offset + dataSize)\n      if (tagType === 8) {\n        this._parseAudio(bodyData, timestamp)\n      } else if (tagType === 9) {\n        if (seamlessLoadingSwitching) this.seamlessLoadingSwitching = true\n        this._parseVideo(bodyData, timestamp)\n      } else if (tagType === 18) {\n        this._parseScript(bodyData, timestamp)\n      } else {\n        logger.warn(`Invalid tag type: ${tagType}`)\n      }\n\n      offset += dataSize\n      prevTagSize = readBig32(data, offset)\n      if (prevTagSize !== 11 + dataSize) {\n        logger.warn(`Invalid PrevTagSize ${prevTagSize} (${11 + dataSize})`)\n      }\n\n      offset += 4\n    }\n\n    if (offset < dataLen) {\n      this._remainingData = data.subarray(offset)\n    }\n\n    audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 1000\n    audioTrack.timescale = audioTrack.codecType === AudioCodecType.OPUS ? 1000 : audioTrack.sampleRate || 0\n\n    if (!audioTrack.exist() && audioTrack.hasSample()) {\n      audioTrack.reset()\n    }\n    if (!videoTrack.exist() && videoTrack.hasSample()) {\n      videoTrack.reset()\n    }\n\n    const scriptDataObject = metadataTrack.flvScriptSamples[metadataTrack.flvScriptSamples.length - 1]\n    const metaData = scriptDataObject?.data?.onMetaData\n\n    if (metaData) {\n      if (videoTrack?.exist()) {\n        if (metaData.hasOwnProperty('duration')) {\n          videoTrack.duration = metaData.duration * 1000\n        }\n\n        if (metaData.hasOwnProperty('width') && metaData.hasOwnProperty('height')) {\n          videoTrack.width = metaData.width\n          videoTrack.height = metaData.height\n        }\n      }\n\n      if (audioTrack?.exist()) {\n        if (metaData.hasOwnProperty('duration')) {\n          audioTrack.duration = metaData.duration * 1000\n        }\n      }\n    }\n\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack\n    }\n  }\n\n  /**\n   * @param {number} [startTime=0]\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @returns {DemuxResult}\n   */\n  fix (startTime, discontinuity, contiguous) {\n    this._fixer.fix(startTime, discontinuity, contiguous)\n    return {\n      videoTrack: this.videoTrack,\n      audioTrack: this.audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @param {number} [startTime=0]\n   * @returns {DemuxResult}\n   */\n  demuxAndFix (data, discontinuity, contiguous, startTime, seamlessLoadingSwitching) {\n    this.demux(data, discontinuity, contiguous, seamlessLoadingSwitching)\n    return this.fix(startTime, discontinuity, contiguous)\n  }\n\n  /**\n   * @param { Uint8Array } data\n   * @returns {boolean}\n   */\n  static probe (data) {\n    if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {\n      return false\n    }\n    return readBig32(data, 5) >= 9\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {number} pts\n   * @private\n   */\n  _parseAudio (data, pts) {\n    if (!data.length) return\n\n    const format = (data[0] & 0xf0) >>> 4\n    const track = this.audioTrack\n\n    if (\n      format !== FlvSoundFormat.AAC &&\n      format !== FlvSoundFormat.G711A &&\n      format !== FlvSoundFormat.G711M &&\n      format !== FlvSoundFormat.OPUS\n    ) {\n      logger.warn(`Unsupported sound format: ${format}`)\n      track.reset()\n      return\n    }\n\n    if (format !== FlvSoundFormat.AAC && format !== FlvSoundFormat.OPUS) {\n      const soundRate = (data[0] & 0x0c) >> 2\n      const soundSize = (data[0] & 0x02) >> 1\n      const soundType = (data[0] & 0x01)\n      track.sampleRate = FlvDemuxer.AUDIO_RATE[soundRate]\n      track.sampleSize = soundSize ? 16 : 8\n      track.channelCount = soundType + 1\n    }\n\n    switch (format) {\n      case FlvSoundFormat.G711A:\n      case FlvSoundFormat.G711M:\n        this._parseG711(data, pts, format)\n        break\n      case FlvSoundFormat.AAC:\n        this._parseAac(data, pts)\n        break\n      case FlvSoundFormat.OPUS:\n        this._parseOpus(data, pts)\n        break\n      default:\n        break\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {number} pts\n   * @private\n   */\n  _parseOpus (data, pts) {\n    const track = this.audioTrack\n    const packetType = data[1]\n\n    track.codecType = AudioCodecType.OPUS\n\n    switch (packetType) {\n      case 0 /* Header Packets */: {\n        const ret = OPUS.parseHeaderPackets(data.subarray(2))\n        if (ret) {\n          track.codec = ret.codec\n          track.channelCount = ret.channelCount\n          track.sampleRate = ret.sampleRate\n          track.config = ret.config\n          track.sampleDuration = OPUS.getFrameDuration([], track.timescale)\n        } else {\n          track.reset()\n          logger.warn('Cannot parse AudioSpecificConfig', data)\n        }\n        break\n      }\n      case 1 /* Raw OPUS frame data */: {\n        if (pts === undefined || pts === null) return\n\n        const newSample = new AudioSample(pts, data.subarray(2), track.sampleDuration)\n        track.samples.push(newSample)\n        break\n      }\n      default:\n        logger.warn(`Unknown OpusPacketType: ${packetType}`)\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {number} pts\n   * @param {import('./soundFormat').FlvSoundFormat} format\n   */\n  _parseG711 (data, pts, format) {\n    const track = this.audioTrack\n    const audioData = data.subarray(1)\n\n    if (audioData.byteLength < 1) return\n\n    const sample = new AudioSample(pts, audioData)\n    track.codecType = format === 7 ? AudioCodecType.G711PCMA : AudioCodecType.G711PCMU\n    track.sampleRate = 8000\n    track.codec = track.codecType\n    track.samples.push(sample)\n  }\n\n  _parseAac (data, pts) {\n    const track = this.audioTrack\n    track.codecType = AudioCodecType.AAC\n\n    if (data[1] === 0) { // AACPacketType\n      const ret = AAC.parseAudioSpecificConfig(data.subarray(2))\n      if (ret) {\n        track.codec = ret.codec\n        track.channelCount = ret.channelCount\n        track.sampleRate = ret.sampleRate\n        track.config = ret.config\n        track.objectType = ret.objectType\n        track.sampleRateIndex = ret.samplingFrequencyIndex\n      } else {\n        track.reset()\n        logger.warn('Cannot parse AudioSpecificConfig', data)\n      }\n    } else if (data[1] === 1) { // Raw AAC frame data\n      if (pts === undefined || pts === null) return\n      track.samples.push(new AudioSample(pts, data.subarray(2)))\n    } else {\n      logger.warn(`Unknown AACPacketType: ${data[1]}`)\n    }\n  }\n\n  _parseVideo (data, dts) {\n    if (data.length < 6) return\n\n    const frameType = (data[0] & 0xf0) >>> 4\n    const codecId = data[0] & 0x0f\n\n    const track = this.videoTrack\n\n    if (\n      codecId !== 7 && // AVC\n      codecId !== 12 // HEVC\n    ) {\n      track.reset()\n      logger.warn(`Unsupported codecId: ${codecId}`)\n      return\n    }\n\n    const isHevc = codecId === 12\n    track.codecType = isHevc ? VideoCodecType.HEVC : VideoCodecType.AVC\n\n    const packetType = data[1]\n    const cts = (((data[2] << 16) | (data[3] << 8) | (data[4])) << 8) >> 8\n\n    if (packetType === 0) { // DecoderConfigurationRecord\n      const configData = data.subarray(5)\n      const ret = isHevc\n        ? HEVC.parseHEVCDecoderConfigurationRecord(configData)\n        : AVC.parseAVCDecoderConfigurationRecord(configData)\n      if (ret) {\n        const { hvcC, sps, ppsArr, spsArr, vpsArr, nalUnitSize } = ret\n        if (hvcC) {\n          track.hvcC = track.hvcC || hvcC\n        }\n        if (sps) {\n          track.codec = sps.codec\n          track.width = sps.width\n          track.height = sps.height\n          track.sarRatio = sps.sarRatio\n          track.fpsNum = sps.fpsNum\n          track.fpsDen = sps.fpsDen\n        }\n        if (spsArr.length) track.sps = spsArr\n        if (ppsArr.length) track.pps = ppsArr\n        if (vpsArr && vpsArr.length) track.vps = vpsArr\n        if (nalUnitSize) track.nalUnitSize = nalUnitSize\n      } else {\n        logger.warn(`Cannot parse ${isHevc ? 'HEVC' : 'AVC'}DecoderConfigurationRecord`, data)\n      }\n    } else if (packetType === 1) { // One or more NALUs\n      let units = NALu.parseAvcC(data.subarray(5), track.nalUnitSize)\n\n      units = this._checkAddMetaNalToUnits(isHevc, units, track)\n\n      if (units && units.length) {\n        const sample = new VideoSample(dts + cts, dts, units)\n        if (this.seamlessLoadingSwitching && dts < track.lastKeyFrameDts) {\n          return\n        }\n        this.seamlessLoadingSwitching = false\n        if (frameType === 1) {\n          sample.setToKeyframe()\n          track.lastKeyFrameDts = dts\n        }\n        track.samples.push(sample)\n\n        units.forEach(unit => {\n          const type = isHevc ? (unit[0] >>> 1) & 0x3f : unit[0] & 0x1f\n          switch (type) {\n            case 5: // IDR\n            case 16: // HEVC BLA_W_LP\n            case 17: // HEVC BLA_W_RADL\n            case 18: // HEVC BLA_N_LP\n            case 19: // HEVC IDR_W_RADL\n            case 20: // HEVC IDR_N_LP\n            case 21: // HEVC CRA_NUT\n            case 22: // HEVC RSV_IRAP_VCL22\n            case 23: // HEVC RSV_IRAP_VCL23\n              if ((!isHevc && type !== 5) || (isHevc && type === 5)) break\n              sample.setToKeyframe()\n              break\n            case 6: // SEI\n            case 39: // HEVC PREFIX_SEI\n            case 40: // HEVC SUFFIX_SEI\n              if ((!isHevc && type !== 6) || (isHevc && type === 6)) break\n              this.metadataTrack.seiSamples.push(new SeiSample(\n                NALu.parseSEI(NALu.removeEPB(unit), isHevc),\n                dts + cts\n              ))\n              break\n            default:\n          }\n        })\n\n        if (sample.keyframe) {\n          this._gopId++\n        }\n        sample.gopId = this._gopId\n      } else {\n        logger.warn('Cannot parse NALUs', data)\n      }\n    } else if (packetType === 2) {\n      // AVC end of sequence, Empty\n    } else {\n      logger.warn(`Unknown AVCPacketType: ${packetType}`)\n    }\n  }\n\n  _checkAddMetaNalToUnits (hevc, units, track) {\n    if (!hevc || !this._needAddMetaBeforeKeyFrameNal) {\n      this._needAddMetaBeforeKeyFrameNal = false\n      return units\n    }\n\n    const nalTypes = units.map(x => (x[0] >>> 1) & 0x3f)\n\n    if (nalTypes.includes(32)) {\n      this._needAddMetaBeforeKeyFrameNal = false\n      return units\n    }\n\n    units.unshift(track.pps[0])\n    units.unshift(track.sps[0])\n    units.unshift(track.vps[0])\n\n    return units.filter(Boolean)\n  }\n\n  _parseScript (data, pts) {\n    this.metadataTrack.flvScriptSamples.push(new FlvScriptSample(AMF.parse(data), pts))\n  }\n}\n","import { AudioSample, WarningType } from '../model'\nimport { AAC } from '../codec'\nimport { isSafari } from '../utils'\nimport { AudioCodecType } from '../model/types'\n\nconst LARGE_AV_FIRST_FRAME_GAP = 90000 / 2 // 500ms\nconst AUDIO_GAP_OVERLAP_THRESHOLD_COUNT = 3\nconst MAX_SILENT_FRAME_DURATION = 90000 // 1s\nconst AUDIO_EXCETION_LOG_EMIT_DURATION = 5 * 90000 // 5s\nconst MAX_VIDEO_FRAME_DURATION = 90000 // 1s\nconst MAX_DTS_DELTA_WITH_NEXT_CHUNK = 90000 / 2 // 500ms\nconst LARGE_AV_FIRST_FRAME_FORCE_FIX_THRESHOLD = 90000 * 5 // 5s\n\nexport class TsFixer {\n  constructor (videoTrack, audioTrack, metadataTrack, fixerConfig) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n    this.metadataTrack = metadataTrack\n\n    this._baseDts = -1\n    this._baseVideoDts = -1\n    this._baseAudioDts = -1\n    this._baseDtsInited = false\n\n    this._audioNextPts = undefined\n    this._videoNextDts = undefined\n\n    this._audioTimestampBreak = false\n    this._videoTimestampBreak = false\n\n    this._lastAudioExceptionGapDot = 0\n    this._lastAudioExceptionOverlapDot = 0\n    this._lastAudioExceptionLargeGapDot = 0\n\n    this._needForceFixLargeGap = fixerConfig?.forceFixLargeGap\n    this._largeGapThreshold = fixerConfig?.largeGapThreshold || LARGE_AV_FIRST_FRAME_FORCE_FIX_THRESHOLD\n  }\n\n  fix (startTime = 0, discontinuity = false, contiguous = true) {\n    startTime = Math.round(startTime * 90000)\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    const vSamples = videoTrack.samples\n    const aSamples = audioTrack.samples\n\n    if (!vSamples.length && !aSamples.length) return\n\n    const firstVideoSample = vSamples[0]\n    const firstAudioSample = aSamples[0]\n    // consider av delta\n    let vaDelta = 0\n\n    if (vSamples.length && aSamples.length) {\n      vaDelta = firstVideoSample.dts - firstAudioSample.pts\n    }\n\n    if (!this._baseDtsInited) {\n      this._calculateBaseDts(this.audioTrack, this.videoTrack)\n    }\n\n    // recalc baseDts\n    if (discontinuity) {\n      this._calculateBaseDts(this.audioTrack, this.videoTrack)\n      this._baseDts -= startTime\n      this._baseAudioDts -= startTime\n      this._baseVideoDts -= startTime\n    }\n\n    // id discontinue, recalc nextDts, consider av delta of firstframe\n    if (!contiguous) {\n      /**\n       *  segment.start = min(a, v)\n       *  segment.start\n       *      |\n       *      a\n       *       -- vaDelta --\n       *                   v\n       */\n      this._videoNextDts = vaDelta > 0 ? startTime + vaDelta : startTime\n      this._audioNextPts = vaDelta > 0 ? startTime : startTime - vaDelta\n\n      if (this._needForceFixLargeGap){\n        this._videoNextDts = 0\n        this._audioNextPts = 0\n      }\n      const vDeltaToNextDts = firstVideoSample ? firstVideoSample.dts - this._baseDts - this._videoNextDts : 0\n      const aDeltaToNextDts = firstAudioSample ? firstAudioSample.pts - this._baseDts - this._audioNextPts : 0\n\n      if (Math.abs(vDeltaToNextDts || aDeltaToNextDts) > MAX_VIDEO_FRAME_DURATION) {\n        this._calculateBaseDts(this.audioTrack, this.videoTrack)\n        this._baseDts -= startTime\n      }\n    }\n\n    this._resetBaseDtsWhenStreamBreaked()\n\n    // fix audio first\n    this._fixAudio(audioTrack)\n\n    this._fixVideo(videoTrack)\n\n    if (this.metadataTrack.exist()) {\n      const timescale = this.metadataTrack.timescale\n      this.metadataTrack.seiSamples.forEach(s => {\n        s.pts = s.originPts - this._baseDts\n        s.time = Math.max(0, s.pts) / timescale\n      })\n    }\n\n    if (videoTrack.samples.length) {\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n    }\n    if (audioTrack.samples.length) {\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts * audioTrack.timescale / 90000\n    }\n  }\n\n  _fixVideo (videoTrack) {\n    const samples = videoTrack.samples\n\n    if (!samples.length) return\n    samples.forEach(x => {\n      x.dts -= this._needForceFixLargeGap ? this._baseVideoDts : this._baseDts\n      x.pts -= this._needForceFixLargeGap ? this._baseVideoDts : this._baseDts\n    })\n\n    if (this._videoNextDts === undefined) {\n      const samp0 = samples[0]\n      this._videoNextDts = samp0.dts\n    }\n\n    const len = samples.length\n    let sampleDuration = 0\n    const firstSample = samples[0]\n    const nextSample = samples[1]\n    const vDelta = this._videoNextDts - firstSample.dts\n\n    if (Math.abs(vDelta) > MAX_DTS_DELTA_WITH_NEXT_CHUNK) {\n      videoTrack.warnings.push({\n        type: WarningType.LARGE_VIDEO_GAP_BETWEEN_CHUNK,\n        nextDts: this._videoNextDts / 90,\n        firstSampleDts: firstSample.dts / 90,\n        nextSampleDts: (samples[1]?.dts || 0) / 90,\n        sampleDuration: vDelta / 90\n      })\n\n      // resolve first frame first\n      firstSample.dts += vDelta\n      firstSample.pts += vDelta\n\n\n      // check to ajust the whole segment\n      if (nextSample && Math.abs(nextSample.dts - firstSample.dts) > MAX_VIDEO_FRAME_DURATION) {\n        this._videoTimestampBreak = true\n        samples.forEach((x, i) => {\n          if (i === 0) return\n          x.dts += vDelta\n          x.pts += vDelta\n        })\n      } else {\n        for (let i = 1; i < len - 1; i++) {\n          const dts = samples[i]?.dts\n          const prevDts = samples[i - 1 ].dts\n          if (dts && dts - prevDts < 0) {\n            samples[i].dts += vDelta\n            samples[i].pts += vDelta\n          }\n        }\n      }\n    }\n\n    let refSampleDurationInt\n    if (videoTrack.fpsNum && videoTrack.fpsDen) {\n      refSampleDurationInt = videoTrack.timescale * (videoTrack.fpsDen / videoTrack.fpsNum)\n    }\n\n    // fps inaccuracy\n    if (refSampleDurationInt < 90 * 10) { // < 10ms per frame\n      refSampleDurationInt = 0\n    }\n\n    if (!refSampleDurationInt) {\n      const first = videoTrack.samples[0]\n      const second = videoTrack.samples[1]\n      // 100ms default\n      refSampleDurationInt = len === 1 ? 9000 : Math.floor((second.dts - first.dts))\n    }\n\n    for (let i = 0; i < len; i++) {\n      const dts = samples[i].dts\n      const nextSample = samples[i + 1]\n      if (i < len - 1) {\n        sampleDuration = nextSample.dts - dts\n      } else if (samples[i - 1]) {\n        sampleDuration = Math.min(dts - samples[i - 1].dts, refSampleDurationInt)\n      } else {\n        sampleDuration = refSampleDurationInt\n      }\n\n      if (sampleDuration > MAX_VIDEO_FRAME_DURATION || sampleDuration < 0) {\n        // dts exception of adjacent frame\n        this._videoTimestampBreak = true\n\n        // check if only video breaked!\n        sampleDuration = this._audioTimestampBreak ? refSampleDurationInt : Math.max(sampleDuration, 30 * 90) // 30ms\n\n        // check if sample breaked within current fragment\n        const expectFragEnd = (this._audioNextPts || 0)\n        if (nextSample && nextSample.dts > expectFragEnd) {\n          sampleDuration = refSampleDurationInt\n        }\n\n        videoTrack.warnings.push({\n          type: WarningType.LARGE_VIDEO_GAP,\n          time: dts / videoTrack.timescale,\n          dts,\n          originDts: samples[i].originDts,\n          nextDts: this._videoNextDts,\n          sampleDuration,\n          refSampleDuration: refSampleDurationInt\n        })\n      }\n\n      samples[i].duration = sampleDuration\n      this._videoNextDts += sampleDuration\n    }\n  }\n\n  _fixAudio (audioTrack) {\n    const samples = audioTrack.samples\n\n    if (!samples.length) return\n    if (audioTrack.codecType === AudioCodecType.MP3) {\n      if (this.lastAudioSample) {\n        samples.unshift(this.lastAudioSample)\n      }\n      for (let index = 0; index < samples.length; index++) {\n        const x = samples[index]\n        if (samples[index + 1]) {\n          x.duration = samples[index + 1].pts - x.pts\n        } else {\n          break\n        }\n        x.pts -= this._baseDts\n        x.dts = x.pts\n      }\n      this.lastAudioSample = samples.pop()\n      return\n    }\n    samples.forEach(x => {\n      x.pts -= this._needForceFixLargeGap ? this._baseAudioDts : this._baseDts\n      x.dts = x.pts\n    })\n\n    this._doFixAudioInternal(audioTrack, samples, 90000)\n  }\n\n  _calculateBaseDts (audioTrack, videoTrack) {\n    const audioSamps = audioTrack.samples\n    const videoSamps = videoTrack.samples\n\n    if (!audioSamps.length && !videoSamps.length) {\n      return false\n    }\n\n    let audioBasePts = Infinity\n    let videoBaseDts = Infinity\n\n    if (audioSamps.length) {\n      audioTrack.baseDts = audioBasePts = audioSamps[0].pts\n      this._baseAudioDts = audioBasePts\n    }\n\n    if (videoSamps.length) {\n      videoTrack.baseDts = videoBaseDts = videoSamps[0].dts\n      this._baseVideoDts = videoBaseDts\n    }\n\n    this._baseDts = Math.min(audioBasePts, videoBaseDts)\n\n    const delta = videoBaseDts - audioBasePts\n    let largeGap = false\n    if (Number.isFinite(delta) && Math.abs(delta) > LARGE_AV_FIRST_FRAME_GAP) {\n      videoTrack.warnings.push({\n        type: WarningType.LARGE_AV_SHIFT,\n        videoBaseDts,\n        audioBasePts,\n        baseDts: this._baseDts,\n        delta\n      })\n    }\n    if (Number.isFinite(delta) && Math.abs(delta) > this._largeGapThreshold * MAX_SILENT_FRAME_DURATION) {\n      largeGap = true\n    }\n    if (!this._baseDtsInited){\n      if (largeGap && this._needForceFixLargeGap) {\n        this._needForceFixLargeGap = true\n      } else {\n        this._needForceFixLargeGap = false\n      }\n    }\n    this._baseDtsInited = true\n    return true\n  }\n\n  _resetBaseDtsWhenStreamBreaked () {\n    if (this._baseDtsInited && this._videoTimestampBreak && this._audioTimestampBreak) {\n      /**\n       * timestamp breaked\n       *                     _audioNextDts\n       *  ---------------------|\n       * (_baseDts)          _videoNextDts\n       * ----------------------|\n       *                        <----------------\n       *                                       nextVideo.dts\n       * ----------------------------------------|\n       *                                       nextAudio.dts\n       * ---------------------------------------|\n       */\n\n      // calc baseDts base on new samples\n      const calc = this._calculateBaseDts(this.audioTrack, this.videoTrack)\n\n      if (!calc) return\n\n      // consider the expect dts for next frame\n      this._baseDts -= Math.min(this._audioNextPts, this._videoNextDts)\n      this._audioLastSample = null\n      this._videoLastSample = null\n      this._videoTimestampBreak = false\n      this._audioTimestampBreak = false\n    }\n  }\n\n  _doFixAudioInternal (audioTrack, samples, timescale) {\n    if (!audioTrack.sampleDuration) audioTrack.sampleDuration = AAC.getFrameDuration(audioTrack.timescale, timescale)\n    const refSampleDuration = audioTrack.sampleDuration\n\n    if (this._audioNextPts === undefined) {\n      const samp0 = samples[0]\n      this._audioNextPts = samp0.pts\n    }\n\n    for (let i = 0; i < samples.length; i++) {\n      const nextPts = this._audioNextPts\n      const sample = samples[i]\n      const delta = sample.pts - nextPts\n\n      // fill frames\n      // delta >= 3 * refSampleDurationInt\n      // delta <= 500s\n      if (!this._audioTimestampBreak && delta >= AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta <= MAX_SILENT_FRAME_DURATION && !isSafari) {\n        const silentFrame = AAC.getSilentFrame(audioTrack.codec, audioTrack.channelCount) || samples[0].data.subarray()\n        const count = Math.floor(delta / refSampleDuration)\n\n        if (Math.abs(sample.pts - this._lastAudioExceptionGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionGapDot = sample.pts\n        }\n\n        audioTrack.warnings.push({\n          type: WarningType.AUDIO_FILLED,\n          pts: sample.pts / 90,\n          originPts: sample.originPts,\n          count,\n          nextPts: nextPts / 90,\n          refSampleDuration\n        })\n\n        for (let j = 0; j < count; j++) {\n          const silentSample = new AudioSample(Math.floor(nextPts), silentFrame)\n          silentSample.originPts = Math.floor(this._baseDts + nextPts)\n          samples.splice(i, 0, silentSample)\n          this._audioNextPts += refSampleDuration\n          i++\n        }\n\n        i--\n        // delta  <= -3 * refSampleDurationInt\n        // delta  >= -500ms\n      } else if (delta <= -AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta >= -1 * MAX_SILENT_FRAME_DURATION) {\n        // need discard frames\n        if (Math.abs(sample.pts - this._lastAudioExceptionOverlapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionOverlapDot = sample.pts\n          audioTrack.warnings.push({\n            type: WarningType.AUDIO_DROPPED,\n            pts: sample.pts / 90,\n            originPts: sample.originPts,\n            nextPts: nextPts / 90,\n            refSampleDuration\n          })\n        }\n        samples.splice(i, 1)\n        i--\n      } else {\n        if (Math.abs(delta) >= MAX_SILENT_FRAME_DURATION) {\n          this._audioTimestampBreak = true\n\n          if (Math.abs(sample.pts - this._lastAudioExceptionLargeGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n            this._lastAudioExceptionLargeGapDot = sample.pts\n            audioTrack.warnings.push({\n              type: WarningType.LARGE_AUDIO_GAP,\n              time: sample.pts / 1000,\n              pts: sample.pts / 90,\n              originPts: sample.originPts,\n              nextPts: nextPts / 90,\n              sampleDuration: delta,\n              refSampleDuration\n            })\n          }\n        }\n\n        sample.dts = sample.pts = nextPts\n        this._audioNextPts += refSampleDuration\n      }\n    }\n  }\n}\n","import { TsFixer } from './fixer'\nimport { AVC, AAC, HEVC, NALu, MPEG } from '../codec'\nimport { VideoSample, AudioSample, VideoCodecType, VideoTrack, AudioTrack, MetadataTrack, SeiSample } from '../model'\nimport { Logger, concatUint8Array } from '../utils'\nimport { AudioCodecType } from '../model/types'\n\nconst logger = new Logger('TsDemuxer')\n\nexport class TsDemuxer {\n  _pmtId = -1\n  _remainingPacketData = null\n  _videoPesData = []\n  _audioPesData = []\n  _gopId = 0\n\n  /**\n   * @param {VideoTrack} [videoTrack]\n   * @param {AudioTrack} [audioTrack]\n   * @param {MetadataTrack} [metadataTrack]\n   */\n  constructor (videoTrack, audioTrack, metadataTrack, fixerConfig = {}) {\n    this.videoTrack = videoTrack || new VideoTrack()\n    this.audioTrack = audioTrack || new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n    this._fixer = new TsFixer(this.videoTrack, this.audioTrack, this.metadataTrack, fixerConfig)\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @returns {import('../flv').DemuxResult}\n   */\n  demux (data, discontinuity = false, contiguous = true) {\n    const { audioTrack, videoTrack, metadataTrack } = this\n\n    if (discontinuity) {\n      this._pmtId = -1\n      videoTrack.reset()\n      audioTrack.reset()\n      metadataTrack.reset()\n    }\n\n    if (!contiguous || discontinuity) {\n      this._remainingPacketData = null\n      this._videoPesData = []\n      this._audioPesData = []\n    } else {\n      videoTrack.samples = []\n      audioTrack.samples = []\n      metadataTrack.seiSamples = []\n      videoTrack.warnings = []\n      audioTrack.warnings = []\n\n      if (this._remainingPacketData) {\n        data = concatUint8Array(this._remainingPacketData, data)\n        this._remainingPacketData = null\n      }\n    }\n\n    let dataLen = data.length\n    const remainingLength = dataLen % 188\n    if (remainingLength) {\n      this._remainingPacketData = data.subarray(dataLen - remainingLength)\n      dataLen -= remainingLength\n    }\n\n    let videoPid = videoTrack.pid\n    let audioPid = audioTrack.pid\n\n    for (let start = 0; start < dataLen; start += 188) {\n      if (data[start] !== 0x47) throw new Error('TS packet did not start with 0x47')\n      const payloadUnitStartIndicator = !!(data[start + 1] & 0x40)\n      const pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2]\n      const adaptationFiledControl = (data[start + 3] & 0x30) >> 4\n\n      let offset\n      if (adaptationFiledControl > 1) {\n        offset = start + 5 + data[start + 4]\n        if (offset === start + 188) continue\n      } else {\n        offset = start + 4\n      }\n\n      switch (pid) {\n        case 0: // PAT\n          if (payloadUnitStartIndicator) offset += data[offset] + 1\n          this._pmtId = ((data[offset + 10] & 0x1f) << 8) | data[offset + 11]\n          break\n        case this._pmtId: {\n          if (payloadUnitStartIndicator) offset += data[offset] + 1\n          const tableEnd = offset + 3 + (((data[offset + 1] & 0x0f) << 8) | data[offset + 2]) - 4\n          const programInfoLength = ((data[offset + 10] & 0x0f) << 8) | data[offset + 11]\n          offset += 12 + programInfoLength\n\n          while (offset < tableEnd) {\n            const esPid = ((data[offset + 1] & 0x1f) << 8) | data[offset + 2]\n            switch (data[offset]) {\n              case 0x0f: // AAC ADTS\n                audioTrack.pid = audioPid = esPid\n                break\n              case 0x03:\n              case 0x04:\n                if (audioTrack.pid === -1) {\n                  audioTrack.pid = audioPid = esPid\n                  audioTrack.codecType = AudioCodecType.MP3\n                }\n                break\n              case 0x1b: // AVC\n                if (videoPid !== -1) break\n                videoTrack.codecType = VideoCodecType.AVC\n                videoTrack.pid = videoPid = esPid\n                break\n              case 0x24: // HEVC\n                if (videoPid !== -1) break\n                videoTrack.codecType = VideoCodecType.HEVC\n                videoTrack.pid = videoPid = esPid\n                break\n              default:\n                logger.warn(`Unsupported stream. type: ${data[offset]}, pid: ${esPid}`)\n            }\n\n            offset += (((data[offset + 3] & 0x0f) << 8) | data[offset + 4]) + 5\n          }\n        }\n          break\n        case videoPid:\n          if (payloadUnitStartIndicator && this._videoPesData.length) {\n            this._parseVideoData()\n          }\n          this._videoPesData.push(data.subarray(offset, start + 188))\n          break\n        case audioPid:\n          if (payloadUnitStartIndicator && this._audioPesData.length) {\n            this._parseAudioData()\n          }\n          this._audioPesData.push(data.subarray(offset, start + 188))\n          break\n        case 17:\n        case 0x1fff:\n          break\n        default:\n          logger.warn(`Unknown pid: ${pid}`)\n      }\n    }\n\n    this._parseVideoData()\n    this._parseAudioData()\n\n    audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 90000\n\n    audioTrack.timescale = audioTrack.sampleRate || 0\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack\n    }\n  }\n\n  /**\n   * @param {number} [startTime=0]\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   */\n  fix (startTime, discontinuity, contiguous) {\n    this._fixer.fix(startTime, discontinuity, contiguous)\n    return {\n      videoTrack: this.videoTrack,\n      audioTrack: this.audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @param {number} [startTime=0]\n   */\n  demuxAndFix (data, discontinuity, contiguous, startTime) {\n    this.demux(data, discontinuity, contiguous)\n    return this.fix(startTime, discontinuity, contiguous)\n  }\n\n  /**\n   * @param { Uint8Array } data\n   * @returns {boolean}\n   */\n  static probe (data) {\n    if (!data.length) return false\n    return data[0] === 0x47 && data[188] === 0x47 && data[376] === 0x47\n  }\n\n  _parseVideoData () {\n    if (!this._videoPesData.length) return\n    const pes = TsDemuxer._parsePES(concatUint8Array(...this._videoPesData))\n    if (!pes) {\n      logger.warn('Cannot parse video pes', this._videoPesData)\n      return\n    }\n\n    const units = NALu.parseAnnexB(pes.data)\n    if (units) {\n      this._createVideoSample(units, pes.pts, pes.dts)\n    } else {\n      logger.warn('Cannot parse avc units', pes)\n    }\n\n    this._videoPesData = []\n  }\n\n  _createVideoSample (units, pts, dts) {\n    if (!units.length) return\n    const track = this.videoTrack\n    const isHevc = track.codecType === VideoCodecType.HEVC\n\n    const sample = new VideoSample(pts, dts)\n    units.forEach((unit) => {\n      const type = isHevc ? (unit[0] >>> 1) & 0x3f : unit[0] & 0x1f\n      switch (type) {\n        case 5: // IDR\n        case 16: // HEVC BLA_W_LP\n        case 17: // HEVC BLA_W_RADL\n        case 18: // HEVC BLA_N_LP\n        case 19: // HEVC IDR_W_RADL\n        case 20: // HEVC IDR_N_LP\n        case 21: // HEVC CRA_NUT\n        case 22: // HEVC RSV_IRAP_VCL22\n        case 23: // HEVC RSV_IRAP_VCL23\n          if ((!isHevc && type !== 5) || (isHevc && type === 5)) break\n          sample.setToKeyframe()\n          this._gopId++\n          break\n        case 6: // SEI\n        case 39: // HEVC PREFIX_SEI\n        case 40: // HEVC SUFFIX_SEI\n          if ((!isHevc && type !== 6) || (isHevc && type === 6)) break\n          this.metadataTrack.seiSamples.push(new SeiSample(\n            NALu.parseSEI(NALu.removeEPB(unit), isHevc),\n            pts\n          ))\n          // fix 分割nal之前只要sei信息被当做单独一个sample\n          return\n        case 32: // HEVC VPS\n          if (!isHevc) break\n          if (!track.vps.length) {\n            const hvcC = HEVC.parseVPS(NALu.removeEPB(unit), track.hvcC)\n            track.hvcC = track.hvcC || hvcC\n            track.vps = [unit]\n          }\n          break\n        case 7: // SPS\n        case 33: // HEVC SPS\n          if ((!isHevc && type !== 7) || (isHevc && type === 7)) break\n          if (!track.sps.length) {\n            const data = NALu.removeEPB(unit)\n            const spsInfo = isHevc ? HEVC.parseSPS(data, track.hvcC) : AVC.parseSPS(data)\n            track.sps = [unit]\n            track.hvcC = track.hvcC || spsInfo.hvcC\n            track.codec = spsInfo.codec\n            track.width = spsInfo.width\n            track.height = spsInfo.height\n            track.sarRatio = spsInfo.sarRatio\n            track.fpsNum = spsInfo.fpsNum\n            track.fpsDen = spsInfo.fpsDen\n          }\n          break\n        case 8: // PPS\n        case 34: // HEVC PPS\n          if ((!isHevc && type !== 8) || (isHevc && type === 8)) break\n          if (!track.pps.length) track.pps = [unit]\n          break\n        case 9: // AUD\n        case 35: // HEVC AUD\n          // if ((!isHevc && type !== 9) || (isHevc && type === 9)) break\n          // sample.gopId = this._gopId\n          // if (sample.units.length && !keyFrame) {\n          //   this._pushVideoSample(track, sample)\n          //   sample = this.prevAvcSample = new VideoSample(pts, dts)\n          // }\n          break\n        case 38: // HEVC FD_NUT\n          if (isHevc) {\n            let ffByteFound = false\n            for (let i = 2; i < unit.byteLength; i++) {\n              if (unit[i] === 0xff) {\n                ffByteFound = true\n                break\n              }\n            }\n            if (!ffByteFound) {\n              return\n            }\n          }\n          break\n        default:\n      }\n      sample.units.push(unit)\n    })\n    sample.gopId = this._gopId\n    this._pushVideoSample(track, sample)\n  }\n\n  _pushVideoSample (track, sample) {\n    if (sample.units.length) {\n      if (sample.pts === null || sample.pts === undefined) {\n        logger.warn('Video sample no pts', sample)\n        const lastSample = track.samples[track.samples.length - 1]\n        if (lastSample) {\n          sample.pts = lastSample.pts\n          sample.dts = lastSample.dts\n        } else {\n          logger.warn('Drop video sample', sample)\n        }\n      } else {\n        track.samples.push(sample)\n      }\n    }\n  }\n\n  _parseAudioData () {\n    if (!this._audioPesData.length) return\n    const pes = TsDemuxer._parsePES(concatUint8Array(...this._audioPesData))\n    if (!pes) {\n      logger.warn('Cannot parse audio pes', this._audioPesData)\n      return\n    }\n\n    switch (this.audioTrack.codecType) {\n      case AudioCodecType.AAC:\n        this._parseAacData(pes)\n        break\n      case AudioCodecType.MP3:\n        this._parseMPEG(pes)\n        break\n      default:\n    }\n\n    this._audioPesData = []\n  }\n\n  _parseAacData (pes) {\n    const track = this.audioTrack\n    let pts = pes.pts\n    if (pts === null || pts === undefined) {\n      logger.warn('AAC pes not pts', track)\n      if (!track.samples.length || !track.sampleRate) {\n        return\n      }\n      pts = track.samples[track.samples.length - 1].pts + AAC.getFrameDuration(track.sampleRate)\n    }\n\n    const ret = AAC.parseADTS(pes.data, pts)\n    if (ret) {\n      track.codec = ret.codec\n      track.channelCount = ret.channelCount\n      track.sampleRate = ret.sampleRate\n      track.objectType = ret.objectType\n      track.sampleRateIndex = ret.samplingFrequencyIndex\n      track.config = ret.config\n      track.samples.push(...ret.frames.map((s) => new AudioSample(s.pts, s.data)))\n\n      if (ret.skip) {\n        logger.warn(`Skip aac adts ${ret.skip} bits`)\n      }\n      if (ret.remaining) {\n        logger.warn(`Remaining aac adts ${ret.remaining} bits`)\n      }\n    } else {\n      logger.warn('Cannot parse aac adts', pes)\n    }\n  }\n\n  _parseMPEG (pes) {\n    const data = pes.data\n    const length = data.length\n    let frameIndex = 0\n    let offset = 0\n    const pts = pes.pts\n    if (pts === undefined) {\n      logger.warn('[tsdemuxer]: MPEG PES unknown PTS')\n      return\n    }\n\n    while (offset < length) {\n      if (MPEG.isHeader(data, offset)) {\n        const frame = MPEG.appendFrame(\n          this.audioTrack,\n          data,\n          offset,\n          pts,\n          frameIndex\n        )\n        if (frame) {\n          offset += frame.length\n          frameIndex++\n        } else {\n          break\n        }\n      } else {\n        offset++\n      }\n    }\n  }\n\n  static _parsePES (data) {\n    const headerDataLen = data[8]\n    if (headerDataLen === null || headerDataLen === undefined || data.length < (headerDataLen + 9)) return\n    const startPrefix = data[0] << 16 | data[1] << 8 | data[2]\n    if (startPrefix !== 1) return\n    const pesLen = (data[4] << 8) + data[5]\n    if (pesLen && pesLen > data.length - 6) return\n\n    let pts\n    let dts\n    const ptsDtsFlags = data[7]\n    if (ptsDtsFlags & 0xc0) {\n      pts = (data[9] & 0x0e) * 536870912 +\n        (data[10] & 0xff) * 4194304 +\n        (data[11] & 0xfe) * 16384 +\n        (data[12] & 0xff) * 128 +\n        (data[13] & 0xfe) / 2\n\n      if (ptsDtsFlags & 0x40) {\n        dts = (data[14] & 0x0e) * 536870912 +\n          (data[15] & 0xff) * 4194304 +\n          (data[16] & 0xfe) * 16384 +\n          (data[17] & 0xff) * 128 +\n          (data[18] & 0xfe) / 2\n        if (pts - dts > 60 * 90000) pts = dts\n      } else {\n        dts = pts\n      }\n    }\n\n    return { data: data.subarray(9 + headerDataLen), pts, dts }\n  }\n}\n","export class ByteReader {\n  private dv: DataView\n  start: number\n  offset: number\n  end: number\n  constructor(buf: ArrayBuffer, offset: number, len: number) {\n    this.dv = new DataView(buf)\n    this.start = this.offset = offset || this.dv.byteOffset\n    this.end = len ? this.start + len : this.start + this.dv.byteLength\n  }\n  static fromUint8(uint8: Uint8Array) {\n    return new ByteReader(uint8.buffer, uint8.byteOffset, uint8.byteLength)\n  }\n  static concatUint8s(args: Uint8Array[]) {\n    const uint8 = new Uint8Array(args.reduce((ret, v) => ret + v.byteLength, 0))\n    let offset = 0\n    args.forEach((v) => {\n      uint8.set(v, offset)\n      offset += v.byteLength\n    })\n    return uint8\n  }\n  static concatUint8(...args: Uint8Array[]) {\n    return this.concatUint8s(args)\n  }\n  get buffer() {\n    return this.dv.buffer\n  }\n  get unreadLength() {\n    return Math.max(this.end - this.offset, 0)\n  }\n  get size() {\n    return this.end - this.start\n  }\n  readFloat(byteNum: number) {\n    let val = 0\n    switch (byteNum) {\n      case 4:\n        val = this.dv.getFloat32(this.offset)\n        break\n      case 8:\n        val = this.dv.getFloat64(this.offset)\n        break\n      default:\n        throw new Error(`read ${byteNum}-byte float is not supported`)\n    }\n    this.offset += byteNum\n    return val\n  }\n  back(byteNum: number) {\n    this.offset -= byteNum\n  }\n  skip(byteNum: number) {\n    this.offset += byteNum\n  }\n  readInt(byteNum: number) {\n    const offset = this.offset\n    this.offset += byteNum\n    switch (byteNum) {\n      case 1:\n        return this.dv.getInt8(offset)\n      case 2:\n        return this.dv.getInt16(offset)\n      case 4:\n        return this.dv.getInt32(offset)\n      default:\n        throw new Error(`read ${byteNum}-byte integers is not supported`)\n    }\n  }\n  read(byteNum: number) {\n    const offset = this.offset\n    this.offset += byteNum\n    switch (byteNum) {\n      case 1:\n        return this.dv.getUint8(offset)\n      case 2:\n        return this.dv.getUint16(offset)\n      case 3:\n        return (this.dv.getUint16(offset) << 8) + this.dv.getUint8(offset + 2)\n      case 4:\n        return this.dv.getUint32(offset)\n      default:\n        this.back(byteNum - 4)\n        // js不支持32位左移，可通过+、Math.pow运算达到64位以内运算的目的\n        return this.read(byteNum - 4) + this.dv.getUint32(offset) * Math.pow(256, byteNum - 4)\n    }\n  }\n  write(byteNum: number, val: number) {\n    const offset = this.offset\n    this.offset += byteNum\n    switch (byteNum) {\n      case 1:\n        return this.dv.setUint8(offset, val)\n      case 2:\n        return this.dv.setUint16(offset, val)\n      case 3:\n        return this.dv.setUint8(offset, val >>> 16),\n          this.dv.setUint16(offset + 1, 0xffff & val)\n      case 4:\n        return this.dv.setUint32(offset, val)\n      default:\n        throw new Error(`write ${byteNum}-byte integers is not supported`)\n    }\n  }\n  readToBuffer(len?: number) {\n    let buffer: ArrayBuffer\n    if (this.offset || len) {\n      buffer = this.dv.buffer.slice(this.offset, len ? this.offset + len : this.end)\n    } else {\n      buffer = this.dv.buffer\n    }\n    this.offset += buffer.byteLength\n    return buffer\n  }\n  readToUint8(len?: number) {\n    const uint8 = new Uint8Array(this.dv.buffer, this.offset, len || this.unreadLength)\n    this.offset += uint8.byteLength\n    return uint8\n  }\n  readString(len: number) {\n    let i = 0, str = ''\n    for (; i < len; i++) {\n      str += String.fromCharCode(this.dv.getUint8(this.offset))\n      this.offset++\n    }\n    return str\n  }\n}","import { ByteReader } from './byte-reader'\n\nexport class BitReader {\n  private val: number\n  size: number\n  offset = 0\n  constructor(val: number, size: number) {\n    this.val = val\n    this.size = size\n  }\n  static fromByte(byte: ByteReader, len: number) {\n    return new BitReader(byte.read(len), len << 3)\n  }\n  skip(len: number) {\n    this.offset += len\n  }\n  read(len: number) {\n    const unreadLength = this.size - this.offset - len\n\n    if (unreadLength >= 0) {\n      let bits = 0, i = 0\n      this.offset += len\n      // 32位及以上的整数不支持位移运算，使用 / + Math.pow 规避\n      if (this.size > 31) {\n        for (; i < len; i++) {\n          bits += Math.pow(2, i)\n        }\n        return this.val / Math.pow(2, unreadLength) & bits\n      } else {\n        for (; i < len; i++) {\n          bits += 1 << i\n        }\n        return this.val >>> unreadLength & bits\n      }\n    }\n    throw new Error(`the number of the read operation exceeds the total length limit of bits`)\n  }\n}","import { AudioCodecType, VideoCodecType } from '../model'\nimport { getAvcCodec, readBig16, readBig24, readBig32, readBig64, combineToFloat, toDegree } from '../utils'\nimport { AAC } from '../codec'\nimport { ByteReader } from '../utils/byte-reader'\nimport { BitReader } from '../utils/bit-reader'\nexport class MP4Parser {\n  static findBox (data, names, start = 0) {\n    const ret = []\n    if (!data) return ret\n\n    let size = 0\n    let type = ''\n    let headerSize = 0\n    while (data.length > 7) {\n      size = readBig32(data)\n      type = String.fromCharCode.apply(null, data.subarray(4, 8))\n      headerSize = 8\n      if (size === 1) {\n        size = readBig64(data, 8)\n        headerSize += 8\n      } else if (!size) {\n        size = data.length\n      }\n      if (!names[0] || type === names[0]) {\n        const subData = data.subarray(0, size)\n        if (names.length < 2) {\n          ret.push({\n            start,\n            size,\n            headerSize,\n            type,\n            data: subData\n          })\n        } else {\n          return MP4Parser.findBox(subData.subarray(headerSize), names.slice(1), start + headerSize)\n        }\n      }\n\n      start += size\n      data = data.subarray(size)\n    }\n\n    return ret\n  }\n\n  static tfhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.trackId = readBig32(data)\n      let start = 4\n      const baseDataOffsetPresent = (ret.flags & 0xff) & 0x01\n      const sampleDescriptionIndexPresent = (ret.flags & 0xff) & 0x02\n      const defaultSampleDurationPresent = (ret.flags & 0xff) & 0x08\n      const defaultSampleSizePresent = (ret.flags & 0xff) & 0x10\n      const defaultSampleFlagsPresent = (ret.flags & 0xff) & 0x20\n\n      if (baseDataOffsetPresent) {\n        start += 4 // truncate top 4 bytes\n        ret.baseDataOffset = readBig32(data, start)\n        start += 4\n      }\n      if (sampleDescriptionIndexPresent) {\n        ret.sampleDescriptionIndex = readBig32(data, start)\n        start += 4\n      }\n      if (defaultSampleDurationPresent) {\n        ret.defaultSampleDuration = readBig32(data, start)\n        start += 4\n      }\n      if (defaultSampleSizePresent) {\n        ret.defaultSampleSize = readBig32(data, start)\n        start += 4\n      }\n      if (defaultSampleFlagsPresent) {\n        ret.defaultSampleFlags = readBig32(data, start)\n      }\n    })\n  }\n\n  static sidx (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      ret.reference_ID = readBig32(data, start)// stream.readUint32();\n      start += 4\n      ret.timescale = readBig32(data, start)\n      start += 4\n      if (ret.version === 0) {\n        ret.earliest_presentation_time = readBig32(data, start)\n        start += 4\n        ret.first_offset = readBig32(data, start)\n        start += 4\n      } else {\n        ret.earliest_presentation_time = readBig64(data, start)\n        start += 8\n        ret.first_offset = readBig64(data, start)\n        start += 8\n      }\n      start += 2\n      ret.references = []\n      const count = readBig16(data, start)\n      start += 2\n      for (let i = 0; i < count; i++) {\n        const ref = {}\n        ret.references.push(ref)\n        let tmp32 = readBig32(data, start)\n        start += 4\n        ref.reference_type = (tmp32 >> 31) & 0x1\n        ref.referenced_size = tmp32 & 0x7FFFFFFF\n        ref.subsegment_duration = readBig32(data, start)\n        start += 4\n        tmp32 = readBig32(data, start)\n        start += 4\n        ref.starts_with_SAP = (tmp32 >> 31) & 0x1\n        ref.SAP_type = (tmp32 >> 28) & 0x7\n        ref.SAP_delta_time = tmp32 & 0xFFFFFFF\n      }\n    })\n  }\n\n  static moov (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.mvhd = MP4Parser.mvhd(MP4Parser.findBox(data, ['mvhd'], start)[0])\n      ret.trak = MP4Parser.findBox(data, ['trak'], start).map(trak => MP4Parser.trak(trak))\n      ret.pssh = MP4Parser.pssh(MP4Parser.findBox(data, ['pssh'], start)[0])\n    })\n  }\n\n  static mvhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      if (ret.version === 1) {\n        ret.timescale = readBig32(data, 16)\n        ret.duration = readBig64(data, 20)\n        start += 28\n      } else {\n        ret.timescale = readBig32(data, 8)\n        ret.duration = readBig32(data, 12)\n        start += 16\n      }\n      ret.nextTrackId = readBig32(data, start + 76)\n    })\n  }\n\n  static trak (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.tkhd = MP4Parser.tkhd(MP4Parser.findBox(data, ['tkhd'], start)[0])\n      ret.mdia = MP4Parser.mdia(MP4Parser.findBox(data, ['mdia'], start)[0])\n    })\n  }\n\n  static tkhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      const byte = ByteReader.fromUint8(data)\n      if (ret.version === 1) {\n        byte.read(8) // createTime\n        byte.read(8) // modifyTime\n        ret.trackId = byte.read(4)\n        byte.read(4)\n        ret.duration = byte.read(8)\n      } else {\n        byte.read(4) // createTime\n        byte.read(4) // modifyTime\n        ret.trackId = byte.read(4)\n        byte.read(4)\n        ret.duration = byte.read(4)\n      }\n      byte.skip(16) // reserved(8) + layer(2) + alternateGroup(2) + volume(2) + reserved(2)\n      ret.matrix = [] // for remux\n      for (let i = 0; i < 36; i++) {\n        ret.matrix.push(byte.read(1))\n      }\n      byte.back(36)\n      const caculatedMatrix = [] // for caculation of rotation\n      for (let i = 0, int32; i < 3; i++) {\n        caculatedMatrix.push(combineToFloat(byte.readInt(2), byte.readInt(2))) // 16.16 fixed point\n        caculatedMatrix.push(combineToFloat(byte.readInt(2), byte.readInt(2))) // 16.16 fixed point\n        int32 = byte.readInt(4)\n        caculatedMatrix.push(combineToFloat(int32 >> 30, int32 & 0x3fffffff)) //  2.30 fixed point\n      }\n      ret.rotation = toDegree(caculatedMatrix)\n      ret.width = byte.read(4) // 16.16 fixed point, no parsed\n      ret.height = byte.read(4) // 16.16 fixed point, no parsed\n    })\n  }\n\n  static mdia (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.mdhd = MP4Parser.mdhd(MP4Parser.findBox(data, ['mdhd'], start)[0])\n      ret.hdlr = MP4Parser.hdlr(MP4Parser.findBox(data, ['hdlr'], start)[0])\n      ret.minf = MP4Parser.minf(MP4Parser.findBox(data, ['minf'], start)[0])\n    })\n  }\n\n  static mdhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      if (ret.version === 1) {\n        ret.timescale = readBig32(data, 16)\n        ret.duration = readBig64(data, 20)\n        start += 28\n      } else {\n        ret.timescale = readBig32(data, 8)\n        ret.duration = readBig32(data, 12)\n        start += 16\n      }\n      const lang = readBig16(data, start)\n      ret.language = String.fromCharCode(((lang >> 10) & 0x1F) + 0x60, ((lang >> 5) & 0x1F) + 0x60, (lang & 0x1F) + 0x60)\n    })\n  }\n\n  static hdlr (box) {\n    return parseBox(box, true, (ret, data) => {\n      if (ret.version === 0) {\n        ret.handlerType = String.fromCharCode.apply(null, data.subarray(4, 8))\n      }\n    })\n  }\n\n  static minf (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.vmhd = MP4Parser.vmhd(MP4Parser.findBox(data, ['vmhd'], start)[0])\n      ret.smhd = MP4Parser.smhd(MP4Parser.findBox(data, ['smhd'], start)[0])\n      ret.stbl = MP4Parser.stbl(MP4Parser.findBox(data, ['stbl'], start)[0])\n    })\n  }\n\n  static vmhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.graphicsmode = readBig16(data)\n      ret.opcolor = [readBig16(data, 2), readBig16(data, 4), readBig16(data, 6)]\n    })\n  }\n\n  static smhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.balance = readBig16(data)\n    })\n  }\n\n  static stbl (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.stsd = MP4Parser.stsd(MP4Parser.findBox(data, ['stsd'], start)[0])\n      ret.stts = MP4Parser.stts(MP4Parser.findBox(data, ['stts'], start)[0])\n      ret.ctts = MP4Parser.ctts(MP4Parser.findBox(data, ['ctts'], start)[0])\n      ret.stsc = MP4Parser.stsc(MP4Parser.findBox(data, ['stsc'], start)[0])\n      ret.stsz = MP4Parser.stsz(MP4Parser.findBox(data, ['stsz'], start)[0])\n      ret.stco = MP4Parser.stco(MP4Parser.findBox(data, ['stco'], start)[0])\n      if (!ret.stco) {\n        ret.co64 = MP4Parser.co64(MP4Parser.findBox(data, ['co64'], start)[0])\n        ret.stco = ret.co64\n      }\n      const default_IV_size = ret.stsd.entries[0]?.sinf?.schi?.tenc.default_IV_size\n      ret.stss = MP4Parser.stss(MP4Parser.findBox(data, ['stss'], start)[0])\n      ret.senc = MP4Parser.senc(MP4Parser.findBox(data, ['senc'], start)[0], default_IV_size)\n    })\n  }\n\n  static senc (box, iv = 8) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      const sampleCount = readBig32(data, start)\n      start += 4\n      ret.samples = []\n      for (let i = 0; i < sampleCount; i++) {\n        const sample = {}\n        sample.InitializationVector = []\n        for (let j = 0; j < iv; j++){\n          sample.InitializationVector[j] = data[start + j]\n        }\n        start += iv\n        if (ret.flags & 0x2) {\n          sample.subsamples = []\n          const subsampleCount = readBig16(data, start)\n          start += 2\n          for (let j = 0; j < subsampleCount; j++) {\n            const subsample = {}\n            subsample.BytesOfClearData = readBig16(data, start)\n            start += 2\n            subsample.BytesOfProtectedData = readBig32(data, start)\n            start += 4\n            sample.subsamples.push(subsample)\n          }\n        }\n        ret.samples.push(sample)\n      }\n    })\n  }\n\n  static pssh (box) {\n    return parseBox(box, true, (ret, data) => {\n      const keyIds = []\n      const systemId = []\n      let start = 0\n      for (let i = 0; i < 16; i++) {\n        systemId.push(toHex(data[start + i]))\n      }\n      start += 16\n      if (ret.version > 0) {\n        const numKeyIds = readBig32(data, start)\n        start += 4\n        for (let i = 0; i < ('' + numKeyIds).length; i++) {\n          for (let j = 0; j < 16; j++) {\n            const keyId = data[start]\n            start += 1\n            keyIds.push(toHex(keyId))\n          }\n        }\n      }\n      const dataSize = readBig32(data, start)\n      ret.data_size = dataSize\n      start += 4\n      ret.kid = keyIds\n      ret.system_id = systemId\n      ret.buffer = data\n    })\n  }\n\n  static stsd (box) {\n    return parseBox(box, true, (ret, data, start) => {\n      ret.entryCount = readBig32(data)\n      ret.entries = MP4Parser.findBox(data.subarray(4), [], start + 4).map(b => {\n        switch (b.type) {\n          case 'av01':\n            return MP4Parser.av01(b)\n          case 'avc1':\n          case 'avc2':\n          case 'avc3':\n          case 'avc4':\n            return MP4Parser.avc1(b)\n          case 'hvc1':\n          case 'hev1':\n            return MP4Parser.hvc1(b)\n          case 'mp4a':\n            return MP4Parser.mp4a(b)\n          case 'alaw':\n          case 'ulaw':\n            return MP4Parser.alaw(b)\n          case 'enca':\n            // sinf->schi->tenc\n            return parseBox(b, false, (ret, data, start) => {\n              ret.channelCount = readBig16(data, 16)\n              ret.samplesize = readBig16(data, 18)\n              ret.sampleRate = (readBig32(data, 24) / (1 << 16))\n              data = data.subarray(28)\n              ret.sinf = MP4Parser.sinf(MP4Parser.findBox(data, ['sinf'], start)[0])\n              ret.esds = MP4Parser.esds(MP4Parser.findBox(data, ['esds'], start)[0])\n            })\n          case 'encv':\n            // sinf->schi->tenc\n            return parseBox(b, false, (ret, data, start) => {\n              ret.width = readBig16(data, 24)\n              ret.height = readBig16(data, 26)\n              ret.horizresolution = readBig32(data, 28)\n              ret.vertresolution = readBig32(data, 32)\n              data = data.subarray(78)\n              ret.sinf = MP4Parser.sinf(MP4Parser.findBox(data, ['sinf'], start)[0])\n              ret.avcC = MP4Parser.avcC(MP4Parser.findBox(data, ['avcC'], start)[0])\n              ret.hvcC = MP4Parser.hvcC(MP4Parser.findBox(data, ['hvcC'], start)[0])\n              ret.pasp = MP4Parser.pasp(MP4Parser.findBox(data, ['pasp'], start)[0])\n            })\n          default:\n        }\n      }).filter(Boolean)\n    })\n  }\n\n  static tenc (box) {\n    return parseBox(box, false, (ret, data) => {\n      let start = 6\n      ret.default_IsEncrypted = data[start]\n      start += 1\n      ret.default_IV_size = data[start]\n      start += 1\n      ret.default_KID = []\n      for (let i = 0; i < 16; i++) {\n        ret.default_KID.push(toHex(data[start]))\n        start += 1\n      }\n    })\n  }\n\n  static schi (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.tenc = MP4Parser.tenc(MP4Parser.findBox(data, ['tenc'], start)[0])\n    })\n  }\n\n  static sinf (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.schi = MP4Parser.schi(MP4Parser.findBox(data, ['schi'], start)[0])\n      ret.frma = MP4Parser.frma(MP4Parser.findBox(data, ['frma'], start)[0])\n    })\n  }\n\n  static frma (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.data_format = ''\n      for (let i = 0; i < 4; i++) {\n        ret.data_format += String.fromCharCode(data[i])\n      }\n    })\n  }\n\n  static colr (box) {\n    return parseBox(box, false, (ret, data) => {\n      const byte = ByteReader.fromUint8(data)\n      ret.data = box.data\n      ret.colorType = byte.readString(4)\n      // Array.from(data.subarray(0, 4)).map(v => String.fromCharCode(v)).join('')\n      if (ret.colorType === 'nclx') {\n        ret.colorPrimaries = byte.read(2)\n        ret.transferCharacteristics = byte.read(2)\n        ret.matrixCoefficients = byte.read(2)\n        ret.fullRangeFlag = byte.read(1) >> 7\n      } else if (ret.colorType === 'rICC' || ret.colorType === 'prof') {\n        ret.iccProfile = data.readToUint8()\n      }\n    })\n  }\n\n  static av01 (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseVisualSampleEntry(ret, data)\n      const bodyData = data.subarray(bodyStart)\n      start += bodyStart\n      ret.av1C = MP4Parser.av1C(MP4Parser.findBox(bodyData, ['av1C'], start)[0])\n      ret.colr = MP4Parser.colr(MP4Parser.findBox(bodyData, ['colr'], start)[0])\n    })\n  }\n\n  static av1C (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.data = box.data\n\n      const byte = ByteReader.fromUint8(data)\n      const bit = BitReader.fromByte(byte, 4)\n\n      ret.marker = bit.read(1)\n      ret.version = bit.read(7)\n\n      ret.seqProfile = bit.read(3)\n      ret.seqLevelIdx0 = bit.read(5)\n\n      ret.seqTier0 = bit.read(1)\n      ret.highBitdepth = bit.read(1)\n      ret.twelveBit = bit.read(1)\n      ret.monochrome = bit.read(1)\n      ret.chromaSubsamplingX = bit.read(1)\n      ret.chromaSubsamplingY = bit.read(1)\n      ret.chromaSamplePosition = bit.read(2)\n      ret.reserved = bit.read(3)\n      ret.initialPresentationDelayPresent = bit.read(1)\n\n      if (ret.initialPresentationDelayPresent) {\n        ret.initialPresentationDelayMinusOne = bit.read(4)\n      } else {\n        ret.initialPresentationDelayMinusOne = 0\n      }\n      ret.configOBUs = byte.readToUint8()\n\n      let bitdepth\n      if (ret.seqLevelIdx0 === 2 && ret.highBitdepth === 1) {\n        bitdepth = ret.twelveBit === 1 ? '12' : '10'\n      } else if (ret.seqProfile <= 2) {\n        bitdepth = ret.highBitdepth === 1 ? '10' : '08'\n      }\n      ret.codec = [\n        'av01',\n        ret.seqProfile,\n        (ret.seqLevelIdx0 < 10 ? '0' + ret.seqLevelIdx0 : ret.seqLevelIdx0) + (ret.seqTier0 ? 'H' : 'M'),\n        bitdepth\n      ].join('.')\n    })\n  }\n\n  static avc1 (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseVisualSampleEntry(ret, data)\n      const bodyData = data.subarray(bodyStart)\n      start += bodyStart\n      ret.avcC = MP4Parser.avcC(MP4Parser.findBox(bodyData, ['avcC'], start)[0])\n      ret.pasp = MP4Parser.pasp(MP4Parser.findBox(bodyData, ['pasp'], start)[0])\n    })\n  }\n\n  static avcC (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.data = box.data\n      ret.configurationVersion = data[0]\n      ret.AVCProfileIndication = data[1]\n      ret.profileCompatibility = data[2]\n      ret.AVCLevelIndication = data[3]\n      ret.codec = getAvcCodec([data[1], data[2], data[3]])\n      ret.lengthSizeMinusOne = data[4] & 0x3\n      ret.spsLength = data[5] & 0x1F\n      ret.sps = []\n      let start = 6\n      for (let i = 0; i < ret.spsLength; i++) {\n        const size = readBig16(data, start)\n        start += 2\n        ret.sps.push(data.subarray(start, start + size))\n        // ret.spsInfo = SpsParser.parseSPS(ret.sps[i])\n        // ret.pixelRatio = ret.spsInfo.par_ratio\n        start += size\n      }\n      ret.ppsLength = data[start]\n      start += 1\n      ret.pps = []\n      for (let i = 0; i < ret.ppsLength; i++) {\n        const size = readBig16(data, start)\n        start += 2\n        ret.pps.push(data.subarray(start, start += size))\n        start += size\n      }\n    })\n  }\n\n  static hvc1 (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseVisualSampleEntry(ret, data)\n      const bodyData = data.subarray(bodyStart)\n      start += bodyStart\n      ret.hvcC = MP4Parser.hvcC(MP4Parser.findBox(bodyData, ['hvcC'], start)[0])\n      ret.pasp = MP4Parser.pasp(MP4Parser.findBox(bodyData, ['pasp'], start)[0])\n    })\n  }\n\n  static hvcC (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.data = box.data\n      ret.codec = 'hev1.1.6.L93.B0'\n      ret.configurationVersion = data[0]\n      const tmp = data[1]\n      ret.generalProfileSpace = tmp >> 6\n      ret.generalTierFlag = (tmp & 0x20) >> 5\n      ret.generalProfileIdc = tmp & 0x1F\n      ret.generalProfileCompatibility = readBig32(data, 2)\n      ret.generalConstraintIndicatorFlags = data.subarray(6, 12)\n      ret.generalLevelIdc = data[12]\n      ret.avgFrameRate = readBig16(data, 19)\n      ret.numOfArrays = data[22]\n      ret.vps = []\n      ret.sps = []\n      ret.pps = []\n      let start = 23\n      let type = 0\n      let numNalus = 0\n      let size = 0\n      for (let i = 0; i < ret.numOfArrays; i++) {\n        type = data[start] & 0x3F\n        numNalus = readBig16(data, start + 1)\n        start += 3\n        const nalus = []\n        for (let j = 0; j < numNalus; j++) {\n          size = readBig16(data, start)\n          start += 2\n          nalus.push(data.subarray(start, start + size))\n          start += size\n        }\n\n        if (type === 32) {\n          ret.vps.push(...nalus)\n        } else if (type === 33) {\n          ret.sps.push(...nalus)\n        } else if (type === 34) {\n          ret.pps.push(...nalus)\n        }\n      }\n    })\n  }\n\n  static pasp (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.hSpacing = readBig32(data)\n      ret.vSpacing = readBig32(data, 4)\n    })\n  }\n\n  static mp4a (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseAudioSampleEntry(ret, data)\n      ret.esds = MP4Parser.esds(MP4Parser.findBox(data.subarray(bodyStart), ['esds'], start + bodyStart)[0])\n    })\n  }\n\n  static esds (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.codec = 'mp4a.'\n      let start = 0\n      let byteRead = 0\n      let size = 0\n      let tag = 0\n      while (data.length) {\n        start = 0\n        tag = data[start]\n        byteRead = data[start + 1]\n        start += 2\n        while (byteRead & 0x80) {\n          size = (byteRead & 0x7F) << 7\n          byteRead = data[start]\n          start += 1\n        }\n        size += byteRead & 0x7F\n        if (tag === 3) {\n          data = data.subarray(start + 3)\n        } else if (tag === 4) {\n          ret.codec += (data[start].toString(16) + '.').padStart(3, '0')\n          data = data.subarray(start + 13)\n        } else if (tag === 5) {\n          const config = ret.config = data.subarray(start, start + size)\n          let objectType = (config[0] & 0xF8) >> 3\n          if (objectType === 31 && config.length >= 2) {\n            objectType = 32 + ((config[0] & 0x7) << 3) + ((config[1] & 0xE0) >> 5)\n          }\n          ret.objectType = objectType\n          ret.codec += objectType.toString(16)\n          if (ret.codec[ret.codec.length - 1] === '.') {\n            ret.codec = ret.codec.substring(0, ret.codec.length - 1)\n          }\n          return\n        } else {\n          if (ret.codec[ret.codec.length - 1] === '.') {\n            ret.codec = ret.codec.substring(0, ret.codec.length - 1)\n          }\n          return\n        }\n      }\n    })\n  }\n\n  static alaw (box) {\n    return parseBox(box, false, (ret, data) => {\n      parseAudioSampleEntry(ret, data)\n    })\n  }\n\n  static stts (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push({\n          count: readBig32(data, start),\n          delta: readBig32(data, start + 4)\n        })\n        start += 8\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static ctts (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      if (ret.version === 1) {\n        for (let i = 0; i < entryCount; i++) {\n          entries.push({\n            count: readBig32(data, start),\n            offset: readBig32(data, start + 4)\n          })\n          start += 8\n        }\n      } else {\n        for (let i = 0; i < entryCount; i++) {\n          entries.push({\n            count: readBig32(data, start),\n            offset: -(~readBig32(data, start + 4) + 1)\n          })\n          start += 8\n        }\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static stsc (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push({\n          firstChunk: readBig32(data, start),\n          samplesPerChunk: readBig32(data, start + 4),\n          sampleDescriptionIndex: readBig32(data, start + 8)\n        })\n        start += 12\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static stsz (box) {\n    return parseBox(box, true, (ret, data) => {\n      const sampleSize = readBig32(data)\n      const sampleCount = readBig32(data, 4)\n      const entrySizes = []\n      if (!sampleSize) {\n        let start = 8\n        for (let i = 0; i < sampleCount; i++) {\n          entrySizes.push(readBig32(data, start))\n          start += 4\n        }\n      }\n      ret.sampleSize = sampleSize\n      ret.sampleCount = sampleCount\n      ret.entrySizes = entrySizes\n    })\n  }\n\n  static stco (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push(readBig32(data, start))\n        start += 4\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static co64 (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push(readBig64(data, start))\n        start += 8\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static stss (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push(readBig32(data, start))\n        start += 4\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static moof (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.mfhd = MP4Parser.mfhd(MP4Parser.findBox(data, ['mfhd'], start)[0])\n      ret.traf = MP4Parser.findBox(data, ['traf'], start).map(t => MP4Parser.traf(t))\n    })\n  }\n\n  static mfhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.sequenceNumber = readBig32(data)\n    })\n  }\n\n  static traf (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.tfhd = MP4Parser.tfhd(MP4Parser.findBox(data, ['tfhd'], start)[0])\n      ret.tfdt = MP4Parser.tfdt(MP4Parser.findBox(data, ['tfdt'], start)[0])\n      ret.trun = MP4Parser.trun(MP4Parser.findBox(data, ['trun'], start)[0])\n    })\n  }\n\n  static trun (box) {\n    return parseBox(box, true, (ret, data) => {\n      const { version, flags } = ret\n      const dataLen = data.length\n      const sampleCount = ret.sampleCount = readBig32(data)\n      let offset = 4\n      if (dataLen > offset && flags & 1) {\n        ret.dataOffset = -(~readBig32(data, offset) + 1)\n        offset += 4\n      }\n      if (dataLen > offset && flags & 4) {\n        ret.firstSampleFlags = readBig32(data, offset)\n        offset += 4\n      }\n      ret.samples = []\n      if (dataLen > offset) {\n        let sample\n        for (let i = 0; i < sampleCount; i++) {\n          sample = {}\n          if (flags & 0x100) {\n            sample.duration = readBig32(data, offset)\n            offset += 4\n          }\n          if (flags & 0x200) {\n            sample.size = readBig32(data, offset)\n            offset += 4\n          }\n          if (flags & 0x400) {\n            sample.flags = readBig32(data, offset)\n            offset += 4\n          }\n          if (flags & 0x800) {\n            if (version) {\n              sample.cts = -(~readBig32(data, offset + 4) + 1)\n            } else {\n              sample.cts = readBig32(data, offset)\n            }\n            offset += 4\n          }\n          ret.samples.push(sample)\n        }\n      }\n    })\n  }\n\n  static tfdt (box) {\n    return parseBox(box, true, (ret, data) => {\n      if (ret.version === 1) {\n        ret.baseMediaDecodeTime = readBig64(data)\n      } else {\n        ret.baseMediaDecodeTime = readBig32(data)\n      }\n    })\n  }\n\n  static probe (data) {\n    return !!MP4Parser.findBox(data, ['ftyp'])\n  }\n\n  static parseSampleFlags (flags) {\n    return {\n      isLeading: (flags[0] & 0x0c) >>> 2,\n      dependsOn: flags[0] & 0x03,\n      isDependedOn: (flags[1] & 0xc0) >>> 6,\n      hasRedundancy: (flags[1] & 0x30) >>> 4,\n      paddingValue: (flags[1] & 0x0e) >>> 1,\n      isNonSyncSample: flags[1] & 0x01,\n      degradationPriority: (flags[2] << 8) | flags[3]\n    }\n  }\n\n  static moovToTrack (moov, videoTrack, audioTrack) {\n    const tracks = moov.trak\n    if (!tracks || !tracks.length) return\n    const vTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'vide')\n    const aTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'soun')\n    if (vTrack && videoTrack) {\n      const v = videoTrack\n      const _vTrackId = vTrack.tkhd?.trackId\n      if (_vTrackId !== null && _vTrackId !== undefined) v.id = vTrack.tkhd.trackId\n      v.tkhdDuration = vTrack.tkhd.duration\n      v.mvhdDurtion = moov.mvhd.duration\n      v.mvhdTimecale = moov.mvhd.timescale\n      v.timescale = v.formatTimescale = vTrack.mdia.mdhd.timescale\n      v.duration = vTrack.mdia.mdhd.duration || (v.mvhdDurtion / v.mvhdTimecale * v.timescale)\n      v.rotation = vTrack.tkhd.rotation\n      v.matrix = vTrack.tkhd.matrix\n      const e1 = vTrack.mdia.minf.stbl.stsd.entries[0]\n      v.width = e1.width\n      v.height = e1.height\n      if (e1.pasp) {\n        v.sarRatio = [e1.pasp.hSpacing, e1.pasp.vSpacing]\n      }\n      if (e1.av1C) {\n        v.codecType = VideoCodecType.AV1\n        v.codec = e1.av1C.codec\n        v.av1C = e1.av1C.data\n        v.colr = e1.colr.data\n      } else if (e1.hvcC) {\n        v.codecType = VideoCodecType.HEVC\n        v.codec = e1.hvcC.codec\n        v.vps = e1.hvcC.vps\n        v.sps = e1.hvcC.sps\n        v.pps = e1.hvcC.pps\n        v.hvcC = e1.hvcC.data\n      } else if (e1.avcC) {\n        v.codec = e1.avcC.codec\n        v.sps = e1.avcC.sps\n        v.pps = e1.avcC.pps\n      } else {\n        throw new Error('unknown video stsd entry')\n      }\n      v.present = true\n      v.ext = {}\n      v.ext.stss = vTrack.mdia?.minf?.stbl?.stss\n      v.ext.ctts = vTrack.mdia?.minf?.stbl?.ctts\n\n      if (e1 && e1.type === 'encv') {\n        v.isVideoEncryption = true\n        e1.default_KID = e1.sinf?.schi?.tenc.default_KID\n        e1.default_IsEncrypted = e1.sinf?.schi?.tenc.default_IsEncrypted\n        e1.default_IV_size = e1.sinf?.schi?.tenc.default_IV_size\n        v.videoSenc = vTrack.mdia.minf.stbl.senc && vTrack.mdia.minf.stbl.senc.samples\n        e1.data_format = e1.sinf?.frma?.data_format\n        v.useEME = moov.useEME\n        v.kidValue = moov.kidValue\n        v.pssh = moov.pssh\n        v.encv = e1\n      }\n    }\n\n    if (aTrack && audioTrack) {\n      const a = audioTrack\n      const _aTrackId = aTrack.tkhd?.trackId\n      if (_aTrackId !== null && _aTrackId !== undefined) a.id = aTrack.tkhd.trackId\n      a.tkhdDuration = aTrack.tkhd.duration\n      a.mvhdDurtion = moov.mvhd.duration\n      a.mvhdTimecale = moov.mvhd.timescale\n      a.timescale = a.formatTimescale = aTrack.mdia.mdhd.timescale\n      a.duration = aTrack.mdia.mdhd.duration || (a.mvhdDurtion / a.mvhdTimecale * a.timescale)\n      const e1 = aTrack.mdia.minf.stbl.stsd.entries[0]\n      a.sampleSize = e1.sampleSize\n      a.sampleRate = e1.sampleRate\n      a.channelCount = e1.channelCount\n      a.present = true\n\n      switch (e1.type) {\n        case 'alaw':\n          a.codecType = a.codec = AudioCodecType.G711PCMA\n          a.sampleRate = 8000\n          break\n        case 'ulaw':\n          a.codecType = a.codec = AudioCodecType.G711PCMU\n          a.sampleRate = 8000\n          break\n        default:\n          a.sampleDuration = AAC.getFrameDuration(a.sampleRate, a.timescale)\n          a.sampleRateIndex = AAC.getRateIndexByRate(a.sampleRate)\n          a.objectType = e1.esds?.objectType || 2\n          if (e1.esds) a.config = Array.from(e1.esds.config)\n          a.codec = e1.esds?.codec || 'mp4a.40.2'\n          break\n      }\n      a.sampleDuration = AAC.getFrameDuration(a.sampleRate, a.timescale)\n      a.objectType = e1.esds?.objectType || 2\n      if (e1.esds) {\n        if (e1.esds.config) {\n          a.config = Array.from(e1.esds.config)\n        } else {\n          console.warn('esds config is null')\n        }\n      }\n      a.codec = e1.esds?.codec || 'mp4a.40.2'\n      a.sampleRateIndex = AAC.getRateIndexByRate(a.sampleRate)\n      a.ext = {}\n      a.ext.stss = aTrack.mdia?.minf?.stbl?.stss\n      a.ext.ctts = aTrack.mdia?.minf?.stbl?.ctts\n      a.present = true\n      if (e1 && e1.type === 'enca') {\n        a.isAudioEncryption = true\n        e1.data_format = e1.sinf?.frma?.data_format\n        e1.default_KID = e1.sinf?.schi?.tenc.default_KID\n        e1.default_IsEncrypted = e1.sinf?.schi?.tenc.default_IsEncrypted\n        e1.default_IV_size = e1.sinf?.schi?.tenc.default_IV_size\n        a.audioSenc = aTrack.mdia.minf.stbl.senc && aTrack.mdia.minf.stbl.senc.samples\n        a.useEME = moov.useEME\n        a.kidValue = moov.kidValue\n        a.enca = e1\n      }\n    }\n\n    audioTrack && (audioTrack.isVideoEncryption = videoTrack ? videoTrack.isVideoEncryption : false)\n    videoTrack && (videoTrack.isAudioEncryption = audioTrack ? audioTrack.isAudioEncryption : false)\n\n    if (videoTrack?.encv || audioTrack?.enca) {\n      const vkid = videoTrack?.encv?.default_KID\n      const akid = audioTrack?.enca?.default_KID\n      const kid = (vkid || akid) ? (vkid || akid).join('') : null\n      videoTrack && (videoTrack.kid = kid)\n      audioTrack && (audioTrack.kid = kid)\n    }\n\n    videoTrack && (videoTrack.flags = 0xf01)\n    audioTrack && (audioTrack.flags = 0x701)\n\n    return {\n      videoTrack,\n      audioTrack\n    }\n  }\n\n  static evaluateDefaultDuration (videoTrack, audioTrack, videoSampleCount) {\n    const audioSampleCount = audioTrack?.samples?.length\n\n    // audio\n    if (!audioSampleCount) return 1024\n\n    const segmentDuration = 1024 * audioSampleCount / audioTrack.timescale\n\n    return segmentDuration * videoTrack.timescale / videoSampleCount\n  }\n\n  static moofToSamples (moof, videoTrack, audioTrack) {\n    const ret = {}\n\n    if (moof.mfhd) {\n      if (videoTrack) videoTrack.sequenceNumber = moof.mfhd.sequenceNumber\n      if (audioTrack) audioTrack.sequenceNumber = moof.mfhd.sequenceNumber\n    }\n\n    moof.traf.forEach(({ tfhd, tfdt, trun }) => {\n      if (!tfhd || !trun) return\n      if (tfdt) {\n        if (videoTrack && videoTrack.id === tfhd.trackId) videoTrack.baseMediaDecodeTime = tfdt.baseMediaDecodeTime\n        if (audioTrack && audioTrack.id === tfhd.trackId) audioTrack.baseMediaDecodeTime = tfdt.baseMediaDecodeTime\n      }\n      const defaultSize = tfhd.defaultSampleSize || 0\n      const defaultDuration = tfhd.defaultSampleDuration || MP4Parser.evaluateDefaultDuration(videoTrack, audioTrack, trun.samples.length || trun.sampleCount)\n      let offset = trun.dataOffset || 0\n      let dts = 0\n      let gopId = -1\n      if (!trun.samples.length && trun.sampleCount) {\n        ret[tfhd.trackId] = []\n        for (let i = 0; i < trun.sampleCount; i++) {\n          ret[tfhd.trackId].push({\n            offset,\n            dts,\n            duration: defaultDuration,\n            size: defaultSize\n          })\n          dts += defaultDuration\n          offset += defaultSize\n        }\n      } else {\n        ret[tfhd.trackId] = trun.samples.map((s, index) => {\n          s = {\n            offset,\n            dts,\n            pts: dts + (s.cts || 0),\n            duration: s.duration || defaultDuration,\n            size: s.size || defaultSize,\n            gopId,\n            keyframe: index === 0 || ((s.flags !== null && s.flags !== undefined) && ((s.flags & 65536) >>> 0) !== 65536)\n          }\n          if (s.keyframe) {\n            gopId++\n            s.gopId = gopId\n          }\n          dts += s.duration\n          offset += s.size\n          return s\n        })\n      }\n    })\n\n    return ret\n  }\n\n  static moovToSamples (moov) {\n    const tracks = moov.trak\n    if (!tracks || !tracks.length) return\n    const vTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'vide')\n    const aTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'soun')\n    if (!vTrack && !aTrack) return\n    let videoSamples\n    let audioSamples\n    if (vTrack) {\n      const videoStbl = vTrack.mdia?.minf?.stbl\n      if (!videoStbl) return\n      const { stts, stsc, stsz, stco, stss, ctts } = videoStbl\n      if (!stts || !stsc || !stsz || !stco || !stss) return\n      videoSamples = getSamples(stts, stsc, stsz, stco, ctts, stss)\n    }\n    if (aTrack) {\n      const audioStbl = aTrack.mdia?.minf?.stbl\n      if (!audioStbl) return\n      const timescale = aTrack.mdia.mdhd?.timescale\n      const { stts, stsc, stsz, stco } = audioStbl\n      if (!timescale || !stts || !stsc || !stsz || !stco) return\n      audioSamples = getSamples(stts, stsc, stsz, stco)\n    }\n\n    return {\n      videoSamples,\n      audioSamples\n    }\n  }\n}\n\nfunction getSamples (stts, stsc, stsz, stco, ctts, stss) {\n  const samples = []\n  const cttsEntries = ctts?.entries\n  const stscEntries = stsc.entries\n  const stcoEntries = stco.entries\n  const stszEntrySizes = stsz.entrySizes\n  const stssEntries = stss?.entries\n  let keyframeMap\n  if (stssEntries) {\n    keyframeMap = {}\n    stssEntries.forEach(x => { keyframeMap[x - 1] = true })\n  }\n  let cttsArr\n  if (cttsEntries) {\n    cttsArr = []\n    cttsEntries.forEach(({ count, offset }) => {\n      for (let i = 0; i < count; i++) {\n        cttsArr.push(offset)\n      }\n    })\n  }\n\n  let sample\n  let gopId = -1\n  let dts = 0\n  let pos = 0\n  let chunkIndex = 0\n  let chunkRunIndex = 0\n  let offsetInChunk = 0\n  let lastSampleInChunk = stscEntries[0].samplesPerChunk\n  let lastChunkInRun = stscEntries[1] ? stscEntries[1].firstChunk - 1 : Infinity\n  stts.entries.forEach(({ count, delta }) => {\n    for (let i = 0; i < count; i++) {\n      sample = {\n        dts,\n        duration: delta,\n        size: stszEntrySizes[pos] || stsz.sampleSize,\n        offset: stcoEntries[chunkIndex] + offsetInChunk,\n        index: pos\n      }\n      if (stssEntries) {\n        sample.keyframe = keyframeMap[pos]\n        if (sample.keyframe) {\n          gopId++\n        }\n        sample.gopId = gopId\n      }\n      // sample.timeOffset = 0\n      if (cttsArr && pos < cttsArr.length) {\n        sample.pts = sample.dts + cttsArr[pos]\n        // sample.timeOffset = cttsArr[pos]\n        // if (pos === 0) {\n        //   sample.pts = sample.dts\n        //   sample.timeOffset = 0\n        // }\n      }\n      samples.push(sample)\n      dts += delta\n      pos++\n\n      if (pos < lastSampleInChunk) {\n        offsetInChunk += sample.size\n      } else {\n        chunkIndex++\n        offsetInChunk = 0\n        if (chunkIndex >= lastChunkInRun) {\n          chunkRunIndex++\n          lastChunkInRun = stscEntries[chunkRunIndex + 1] ? stscEntries[chunkRunIndex + 1].firstChunk - 1 : Infinity\n        }\n        lastSampleInChunk += stscEntries[chunkRunIndex].samplesPerChunk\n      }\n    }\n  })\n\n  return samples\n}\n\nfunction parseVisualSampleEntry (ret, data) {\n  ret.dataReferenceIndex = readBig16(data, 6)\n  ret.width = readBig16(data, 24)\n  ret.height = readBig16(data, 26)\n  ret.horizresolution = readBig32(data, 28)\n  ret.vertresolution = readBig32(data, 32)\n  ret.frameCount = readBig16(data, 40)\n  ret.depth = readBig16(data, 74)\n  return 78\n}\n\nfunction parseAudioSampleEntry (ret, data) {\n  ret.dataReferenceIndex = readBig16(data, 6)\n  ret.channelCount = readBig16(data, 16)\n  ret.sampleSize = readBig16(data, 18)\n  ret.sampleRate = readBig32(data, 24) / (1 << 16)\n  return 28\n}\n\nfunction parseBox (box, isFullBox, parse) {\n  if (!box) return\n  if (box.size !== box.data.length) {\n    throw new Error(`box ${box.type} size !== data.length`)\n  }\n  const ret = {\n    start: box.start,\n    size: box.size,\n    headerSize: box.headerSize,\n    type: box.type\n  }\n  if (isFullBox) {\n    ret.version = box.data[box.headerSize]\n    ret.flags = readBig24(box.data, box.headerSize + 1)\n    ret.headerSize += 4\n  }\n  parse(ret, box.data.subarray(ret.headerSize), ret.start + ret.headerSize)\n  return ret\n}\n\nconst padStart = function (str, length, pad) {\n  const charstr = String(pad)\n  const len = length >> 0\n  let maxlen = Math.ceil(len / charstr.length)\n  const chars = []\n  const r = String(str)\n  while (maxlen--) {\n    chars.push(charstr)\n  }\n  return chars.join('').substring(0, len - r.length) + r\n}\n\nconst toHex = function (...value) {\n  const hex = []\n  value.forEach(item => {\n    hex.push(padStart(Number(item).toString(16), 2, 0))\n  })\n  return hex[0]\n}\n","import { VideoTrack, AudioTrack, MetadataTrack, VideoSample, AudioSample } from '../model'\nimport { concatUint8Array, readBig32 } from '../utils'\nimport { MP4Parser } from './mp4-parser'\n\nexport class FMP4Demuxer {\n  __loadedMoofWraps = []\n  __lastRemainData = null\n  __lastRemainDataStart = 0\n  __nextMoofStart = -1\n\n\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack || new VideoTrack()\n    this.audioTrack = audioTrack || new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n  }\n\n  demuxPart (partData, partDataStart, moov) {\n    const { videoTrack, audioTrack } = this\n    const videoExist = videoTrack.exist()\n    const audioExist = audioTrack.exist()\n\n    const isAV01 = /av01/.test(videoTrack.codec)\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    let data = partData\n    let dataStart = partDataStart\n    if (this.__lastRemainData) {\n      const lastRemainDataEnd = this.__lastRemainDataStart + this.__lastRemainData.byteLength\n      // 如果遗留数据和新数据之间存在非包含关系的重叠，则需要合并，否则丢弃遗留数据\n      // 如果遗留数据和新数据之间不存在重叠，需要丢弃遗留数据，保证后续的新数据可以连续的解析\n      const continuous = partDataStart <= lastRemainDataEnd && partDataStart > this.__lastRemainDataStart && partDataStart + partData.byteLength > lastRemainDataEnd\n      if (continuous) {\n        // data = 遗留数据 + 新数据，为了程序健壮性，即可能存在重复的range，需要subarray规避\n        const noDuplicateData = partData.subarray(this.__lastRemainData.byteLength + this.__lastRemainDataStart - partDataStart)\n        data = concatUint8Array(this.__lastRemainData, noDuplicateData)\n        dataStart = this.__lastRemainDataStart\n        this.__lastRemainData = null\n      } else {\n        this.__lastRemainData = null\n        this.__lastRemainDataStart = 0\n        this.__nextMoofStart = -1\n      }\n    }\n\n    if (!moov) {\n      const moovBox = MP4Parser.findBox(data, ['moov'])[0]\n      if (!moovBox) throw new Error('cannot found moov box')\n      moov = MP4Parser.moov(moovBox)\n    }\n\n    if (data) {\n      const dataEnd = dataStart + data.byteLength\n      if (!videoExist && !audioExist) {\n        MP4Parser.moovToTrack(moov, videoTrack, audioTrack)\n      }\n      // findBox要求参数由box header作为起始，故需要定位到moof的起始点，通过前一个moof计算出下一个moof的start位置，并保证解析的内容大于header的长度(8)\n      const moofBoxes = []\n      if (this.__nextMoofStart < 0) {\n        MP4Parser.findBox(data, ['moof'], dataStart).forEach(v => moofBoxes.push(v))\n      } else if (this.__nextMoofStart >= dataStart && this.__nextMoofStart <= dataEnd - 8) {\n        MP4Parser.findBox(data.subarray(this.__nextMoofStart - dataStart), ['moof'], this.__nextMoofStart).forEach(v => moofBoxes.push(v))\n      }\n      moofBoxes.filter(moofBox => moofBox.size <= moofBox.data.length).forEach(moofBox => {\n        const moof = MP4Parser.moof(moofBox)\n        // 通过（trun.dataOffset + all samples的合并值）最大值计算得到下一个moof.start，也可以通过mdat box获取，此处为前者逻辑\n        this.__nextMoofStart = moof.start + Math.max(...moof.traf.map(v => v.trun.samples.reduce((ret, w) => ret + w.size, v.trun.dataOffset || 0)))\n        this.__loadedMoofWraps.push({\n          start: moof.start,\n          nextMoofStart: this.__nextMoofStart,\n          moof\n        })\n        this.__loadedMoofWraps.sort((p, n) => p.start - n.start) // 排序，兼容seek\n      })\n\n      for (const moofWrap of this.__loadedMoofWraps) {\n        // 跳过不需要解析的moof，减少非必要的损耗\n        if (moofWrap.start > dataEnd || moofWrap.nextMoofStart < dataStart) {\n          continue\n        }\n        const moofStart = moofWrap.start\n        const tracks = MP4Parser.moofToSamples(moofWrap.moof, videoTrack, audioTrack)\n\n        const videoBaseMediaDecodeTime = videoTrack.baseMediaDecodeTime\n        const audioBaseMediaDecodeTime = audioTrack.baseMediaDecodeTime\n        let nalSize\n        Object.keys(tracks).forEach(k => {\n          // eslint-disable-next-line\n          if (videoTrack.id == k) {\n            tracks[k]\n              .some(x => {\n                const xStart = x.offset += moofStart\n                if (xStart < dataStart) {\n                  return\n                }\n                // 如果当前sample已经超过了数据范围，则中断遍历\n                if (xStart + x.size > dataEnd) {\n                  return true\n                }\n                const sample = new VideoSample((x.pts || x.dts) + videoBaseMediaDecodeTime, x.dts + videoBaseMediaDecodeTime)\n                sample.duration = x.duration\n                sample.gopId = x.gopId\n                if (x.keyframe) sample.setToKeyframe()\n                const sampleData = data.subarray(xStart - dataStart, xStart - dataStart + x.size)\n                sample.data = sampleData\n                if (!isAV01) { // av1编码的数据不需要解析nals\n                  let start = 0\n                  const len = sampleData.length - 1\n                  while (start < len) {\n                    nalSize = readBig32(sampleData, start)\n                    start += 4\n                    sample.units.push(sampleData.subarray(start, start + nalSize))\n                    start += nalSize\n                  }\n                }\n                this.__lastRemainDataStart = xStart + x.size\n                videoTrack.samples.push(sample)\n              })\n            // eslint-disable-next-line eqeqeq\n          } else if (audioTrack.id == k) {\n            tracks[k]\n              .some(x => {\n                const xStart = x.offset + moofStart\n                if (xStart < dataStart) {\n                  return\n                }\n                if (xStart + x.size > dataEnd) {\n                  return true\n                }\n                const sampleData = data.subarray(xStart - dataStart, xStart - dataStart + x.size)\n                audioTrack.samples.push(new AudioSample(x.dts + audioBaseMediaDecodeTime, sampleData, x.duration))\n                this.__lastRemainDataStart = xStart + x.size\n              })\n          }\n        })\n      }\n    }\n\n    // 保存未解析的数据，下次解析时合并使用\n    if (this.__lastRemainDataStart > dataStart && this.__lastRemainDataStart < data.byteLength + dataStart) {\n      this.__lastRemainData = data.subarray(this.__lastRemainDataStart - dataStart)\n    } else {\n      this.__lastRemainData = data\n      this.__lastRemainDataStart = dataStart\n    }\n\n    // fmp4中sample.pts是通过tfdt的baseMediaDecodeTime + sample.duration计算得出的\n    // 所以此处sample的pts是多少不重要，反而需要确保demuxPart中baseMediaDecodeTime的值为起始帧的pts，才能保证remux后解析的结果与原始数据一致\n    if (videoTrack.samples.length) {\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].pts\n    }\n    if (audioTrack.samples.length) {\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts\n    }\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  demux (videoData, audioData) {\n    const { videoTrack, audioTrack } = this\n    const videoExist = videoTrack.exist()\n    const audioExist = audioTrack.exist()\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    if (audioData) {\n      if (!audioExist) {\n        const moovBox = MP4Parser.findBox(audioData, ['moov'])[0]\n        if (!moovBox) throw new Error('cannot found moov box')\n        MP4Parser.moovToTrack(MP4Parser.moov(moovBox), null, audioTrack)\n      }\n      const moofBox = MP4Parser.findBox(audioData, ['moof'])[0]\n      if (moofBox) {\n        const samples = MP4Parser.moofToSamples(MP4Parser.moof(moofBox), null, audioTrack)[audioTrack.id]\n        const baseMediaDecodeTime = audioTrack.baseMediaDecodeTime\n        if (samples) {\n          const baseOffset = moofBox.start\n          samples.map(x => {\n            x.offset += baseOffset\n            const sampleData = audioData.subarray(x.offset, x.offset + x.size)\n            audioTrack.samples.push(new AudioSample(x.dts + baseMediaDecodeTime, sampleData, x.duration))\n          })\n        }\n      }\n    }\n\n    if (videoData) {\n      if (!videoExist && !audioExist) {\n        const moovBox = MP4Parser.findBox(videoData, ['moov'])[0]\n        if (!moovBox) throw new Error('cannot found moov box')\n        MP4Parser.moovToTrack(MP4Parser.moov(moovBox), videoTrack, audioTrack)\n      }\n      const moofBox = MP4Parser.findBox(videoData, ['moof'])[0]\n      if (moofBox) {\n        const tracks = MP4Parser.moofToSamples(MP4Parser.moof(moofBox), videoTrack, audioTrack)\n        const videoBaseMediaDecodeTime = videoTrack.baseMediaDecodeTime\n        const audioBaseMediaDecodeTime = audioTrack.baseMediaDecodeTime\n        const baseOffset = moofBox.start\n        let nalSize\n        Object.keys(tracks).forEach(k => {\n          // eslint-disable-next-line eqeqeq\n          if (videoTrack.id == k) {\n            tracks[k].map(x => {\n              x.offset += baseOffset\n              const sample = new VideoSample((x.pts || x.dts) + videoBaseMediaDecodeTime, x.dts + videoBaseMediaDecodeTime)\n              sample.duration = x.duration\n              sample.gopId = x.gopId\n              if (x.keyframe) sample.setToKeyframe()\n              const sampleData = videoData.subarray(x.offset, x.offset + x.size)\n              sample.data = sampleData\n              let start = 0\n              const len = sampleData.length - 1\n              while (start < len) {\n                nalSize = readBig32(sampleData, start)\n                start += 4\n                sample.units.push(sampleData.subarray(start, start + nalSize))\n                start += nalSize\n              }\n              videoTrack.samples.push(sample)\n            })\n            // eslint-disable-next-line eqeqeq\n          } else if (audioTrack.id == k) {\n            tracks[k].map(x => {\n              x.offset += baseOffset\n              const sampleData = videoData.subarray(x.offset, x.offset + x.size)\n              audioTrack.samples.push(new AudioSample(x.dts + audioBaseMediaDecodeTime, sampleData, x.duration))\n            })\n          }\n        })\n      }\n    }\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  reset () {\n    this.videoTrack.reset()\n    this.audioTrack.reset()\n    this.metadataTrack.reset()\n  }\n\n  static probe (data) {\n    return MP4Parser.probe(data)\n  }\n}\n","\n// 改造为兼容IE11\nfunction Concat (ResultConstructor, ...arrays){\n  let totalLength = 0\n  arrays.forEach(function (arr){\n    totalLength += arr.length\n  })\n  const result = new ResultConstructor(totalLength)\n  let offset = 0\n  arrays.forEach(function (arr){\n    result.set(arr, offset)\n    offset += arr.length\n  })\n  return result\n}\n\nclass Buffer {\n  constructor () {\n    this.buffer = new Uint8Array(0)\n  }\n\n  write (...buffer) {\n    const self = this\n    buffer.forEach(item => {\n      if (item) {\n        self.buffer = Concat(Uint8Array, self.buffer, item)\n      } else {\n        window.console.warn(item)\n      }\n    })\n  }\n\n  static writeUint16 (value) {\n    return new Uint8Array([\n      (value >> 8) & 0xff,\n      value & 0xff\n    ])\n  }\n\n  static writeUint32 (value) {\n    return new Uint8Array([\n      value >> 24,\n      (value >> 16) & 0xff,\n      (value >> 8) & 0xff,\n      value & 0xff\n    ])\n  }\n}\n\nexport default Buffer\n","import { AudioCodecType, TrackType, VideoCodecType } from '../model'\nimport { concatUint8Array, parse } from '../utils'\nimport Buffer from './buffer'\n\nconst UINT32_MAX = 2 ** 32 - 1\n\nexport class MP4 {\n  static types = [\n    'Opus',\n    'dOps',\n    'av01',\n    'av1C',\n    'avc1',\n    'avcC',\n    'hvc1',\n    'hvcC',\n    'dinf',\n    'dref',\n    'esds',\n    'ftyp',\n    'hdlr',\n    'mdat',\n    'mdhd',\n    'mdia',\n    'mfhd',\n    'minf',\n    'moof',\n    'moov',\n    'mp4a',\n    'mvex',\n    'mvhd',\n    'pasp',\n    'stbl',\n    'stco',\n    'stsc',\n    'stsd',\n    'stsz',\n    'stts',\n    'tfdt',\n    'tfhd',\n    'traf',\n    'trak',\n    'trex',\n    'tkhd',\n    'vmhd',\n    'smhd',\n    'ctts',\n    'stss',\n    'styp',\n    'pssh',\n    'sidx',\n    'sbgp',\n    'saiz',\n    'saio',\n    'senc',\n    'trun',\n    'encv',\n    'enca',\n    'sinf',\n    'btrt',\n    'frma',\n    'tenc',\n    'schm',\n    'schi',\n    'mehd',\n    'fiel',\n    'sdtp'\n  ].reduce((p, c) => {\n    p[c] = [c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2), c.charCodeAt(3)]\n    return p\n  }, Object.create(null));\n\n  static HDLR_TYPES = {\n    video: new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61,\n      0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]),\n    audio: new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61,\n      0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ])\n  }\n\n  static FTYPAVC1 = MP4.box(MP4.types.ftyp, new Uint8Array([\n    105, 115, 111, 109, // isom\n    0, 0, 0, 1,\n    105, 115, 111, 109,\n    97, 118, 99, 49 // avc1\n  ]))\n\n  static FTYPHEV1 = MP4.box(MP4.types.ftyp, new Uint8Array([\n    105, 115, 111, 109, // isom\n    0, 0, 0, 1,\n    105, 115, 111, 109,\n    104, 101, 118, 49 // hev1\n  ]))\n\n  static DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version\n    0x00, 0x00, 0x01 // entry_flags\n  ])))\n\n  static VMHD = MP4.box(MP4.types.vmhd, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphics mode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // op color\n  ]))\n\n  static SMHD = MP4.box(MP4.types.smhd, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, // balance\n    0x00, 0x00 // reserved\n  ]))\n\n  static StblTable = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n  ])\n\n  static STTS = MP4.box(MP4.types.stts, MP4.StblTable)\n\n  static STSC = MP4.box(MP4.types.stsc, MP4.StblTable)\n\n  static STSZ = MP4.box(MP4.types.stsz, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n  ]))\n\n  static STCO = MP4.box(MP4.types.stco, MP4.StblTable)\n\n  static box (type, ...payload) {\n    payload = payload.filter(Boolean)\n    const size = 8 + payload.reduce((p, c) => (p + c.byteLength), 0)\n    const ret = new Uint8Array(size)\n    ret[0] = (size >> 24) & 0xff\n    ret[1] = (size >> 16) & 0xff\n    ret[2] = (size >> 8) & 0xff\n    ret[3] = size & 0xff\n    ret.set(type, 4)\n    let offset = 8\n    payload.forEach((data) => {\n      ret.set(data, offset)\n      offset += data.byteLength\n    })\n    return ret\n  }\n\n  static ftyp (tracks) {\n    const isHevc = tracks.find(t => t.type === TrackType.VIDEO && t.codecType === VideoCodecType.HEVC)\n    return isHevc ? MP4.FTYPHEV1 : MP4.FTYPAVC1\n  }\n\n  static initSegment (tracks) {\n    const ftyp = MP4.ftyp(tracks)\n    // console.log('[remux],ftyp ,len ', ftyp.byteLength, hashVal(ftyp.toString()))\n    const init = concatUint8Array(ftyp, MP4.moov(tracks))\n    // console.log('[remux],init ,len ', init.byteLength, hashVal(init.toString()))\n    return init\n  }\n\n  static pssh (data) {\n    // const buffer = new Buffer()\n    const content = new Uint8Array(\n      [\n        0x01, 0x00, 0x00, 0x00 // version\n      ].concat(\n        [\n          0x10, 0x77, 0xef, 0xec,\n          0xc0, 0xb2, 0x4d, 0x02,\n          0xac, 0xe3, 0x3c, 0x1e,\n          0x52, 0xe2, 0xfb, 0x4b\n        ],\n        [0x00, 0x00, 0x00, 0x01],\n        parse(data.kid),\n        [0x00, 0x00, 0x00, 0x00]\n      )\n    )\n    return MP4.box(MP4.types.pssh, content)\n  }\n\n  static moov (tracks) {\n    if (tracks[0].useEME && (tracks[0].encv || tracks[0].enca)) {\n      if (!tracks[0].pssh) {\n        tracks[0].pssh = {\n          kid: tracks[0].kid\n        }\n      }\n      const pssh = this.pssh(tracks[0].pssh)\n      // console.log('[remux],pssh,', hashVal(pssh.toString()))\n      return MP4.box(MP4.types.moov,\n        MP4.mvhd(tracks[0].mvhdDurtion || tracks[0].duration, tracks[0].mvhdTimecale || tracks[0].timescale),\n        MP4.mvex(tracks),\n        ...tracks.map((t) => MP4.trak(t)),\n        pssh)\n    } else {\n      return MP4.box(MP4.types.moov,\n        MP4.mvhd(tracks[0].mvhdDurtion || tracks[0].duration, tracks[0].mvhdTimecale || tracks[0].timescale),\n        ...tracks.map((t) => MP4.trak(t)),\n        MP4.mvex(tracks)\n      )\n    }\n  }\n\n  static mvhd (duration, timescale = 90000) {\n    const mvhd = MP4.box(MP4.types.mvhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // modification_time\n      (timescale >> 24) & 0xff, (timescale >> 16) & 0xff, (timescale >> 8) & 0xff, timescale & 0xff,\n      (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff,\n      0x00, 0x01, 0x00, 0x00, // rate\n      0x01, 0x00, // volume\n      0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // matrix\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // todo 0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]))\n    // console.log('[remux],mvhd, len,', mvhd.byteLength, hashVal(mvhd.toString()))\n    return mvhd\n  }\n\n  static trak (track) {\n    const trak = MP4.box(\n      MP4.types.trak,\n      MP4.tkhd(track.id, track.tkhdDuration || 0, track.width, track.height),\n      MP4.mdia(track)\n    )\n    // console.log('[remux],trak, len,', trak.byteLength, track.id, hashVal(trak.toString()))\n    return trak\n  }\n\n  static tkhd (id, duration, width = 0, height = 0) {\n    const tkhd = MP4.box(MP4.types.tkhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x07, // flags、todo 0x07\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // modification_time todo\n      (id >> 24) & 0xff, (id >> 16) & 0xff, (id >> 8) & 0xff, id & 0xff,\n      0x00, 0x00, 0x00, 0x00,\n      (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff, // todo (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, // layer\n      0x00, 0x00, // /*0x00*/ alternate_group  //todo type === 'video' ? 0x01 : 0x00（第二个位置）\n      0x01, 0x00, // /* 0x01 */, 0x00, // non-audio track volume  //todo type === 'audio' ? 0x01 : 0x00（第一个位置）\n      0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // matrix\n      (width >> 8) & 0xff, width & 0xff, 0x00, 0x00,\n      (height >> 8) & 0xff, height & 0xff, 0x00, 0x00\n    ]))\n    // console.log('[remux],tkhd, len,', tkhd.byteLength, hashVal(tkhd.toString()))\n    return tkhd\n  }\n\n  static mdia (track) {\n    const mdia = MP4.box(MP4.types.mdia, MP4.mdhd(track.duration, track.timescale), MP4.hdlr(track.type), MP4.minf(track))\n    // console.log('[remux],mdia, len,', mdia.byteLength, hashVal(mdia.toString()))\n    return mdia\n  }\n\n  static mdhd (duration, timescale = 90000) {\n    const mdhd = MP4.box(MP4.types.mdhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // todo 0x00, 0x00, 0x00, 0x00, // modification_time\n      (timescale >> 24) & 0xff, (timescale >> 16) & 0xff, (timescale >> 8) & 0xff, timescale & 0xff,\n      (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff, // (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff,//todo\n      0x55, 0xc4, // 'und' language (undetermined) //todo 0x15, 0xC7\n      0x00, 0x00 // pre_defined\n    ]))\n    // console.log('[remux],mdhd, len,', mdhd.byteLength, hashVal(mdhd.toString()))\n    return mdhd\n  }\n\n  static hdlr (type) {\n    const hdlr = MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type])\n    // console.log('[remux],hdlr, len,', hdlr.byteLength, hashVal(hdlr.toString()))\n    return hdlr\n  }\n\n  static minf (track) {\n    const minf = MP4.box(MP4.types.minf, track.type === TrackType.VIDEO ? MP4.VMHD : MP4.SMHD, MP4.DINF, MP4.stbl(track))\n    // console.log('[remux],minf, len,', minf.byteLength, hashVal(minf.toString()))\n    return minf\n  }\n\n  static stbl (track) {\n    const extBox = []\n    if (track && track.ext) {\n      track.ext.stss && extBox.push(MP4.stss(track.ext.stss.entries))\n      // track.ext.stss && extBox.push(MP4.ctts(track.ext.stss.entries))\n    }\n    const stbl = MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.STTS, extBox[0], MP4.STSC, MP4.STSZ, MP4.STCO)\n    // console.log('[remux],stbl, len,', stbl.byteLength, hashVal(stbl.toString()))\n    return stbl\n  }\n\n  static stsd (track) {\n    let content\n\n    if (track.type === 'audio') {\n      if (track.useEME && track.enca) {\n        content = MP4.enca(track)\n        // console.log('[remux],enca, len,', content.byteLength, track.type, hashVal(content.toString()))\n      } else {\n        if (track.codecType === AudioCodecType.OPUS) {\n          content = MP4.opus(track)\n        } else {\n          content = MP4.mp4a(track)\n        }\n      }\n    } else if (track.useEME && track.encv) {\n      content = MP4.encv(track)\n      // console.log('[remux],encv, len,', content.byteLength, track.type, hashVal(content.toString()))\n    } else if (track.av1C) {\n      content = MP4.av01(track)\n    } else {\n      content = MP4.avc1hev1(track)\n      // console.log('[remux],avc1hev1, len,', content.byteLength, track.type, hashVal(content.toString()))\n    }\n    const stsd = MP4.box(MP4.types.stsd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01 // entry_count\n    ]), content)\n    // console.log('[remux],stsd, len,', stsd.byteLength, hashVal(stsd.toString()))\n    return stsd\n  }\n\n  static enca (data) {\n    const channelCount = data.enca.channelCount\n    const sampleRate = data.enca.sampleRate\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, channelCount, // channelcount\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00, // reserved2\n      (sampleRate >> 8) & 0xff,\n      sampleRate & 0xff, //\n      0x00, 0x00\n    ])\n    const esds = MP4.esds(data.config)\n    // console.log('[remux],esds, len,', esds.byteLength, hashVal(esds.toString()))\n    const sinf = MP4.sinf(data.enca)\n    // console.log('[remux],sinf, len,', sinf.byteLength, hashVal(sinf.toString()))\n    return MP4.box(MP4.types.enca, content, esds, sinf)\n  }\n\n  static encv (track) {\n    const sps = track.sps.length > 0 ? track.sps[0] : []\n    const pps = track.pps.length > 0 ? track.pps[0] : []\n    const width = track.width\n    const height = track.height\n    const hSpacing = track.sarRatio[0]\n    const vSpacing = track.sarRatio[1]\n\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      (width >> 8) & 0xff,\n      width & 0xff, // width\n      (height >> 8) & 0xff,\n      height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n\n      0x12,\n      0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js\n      0x79, 0x6D, 0x6F, 0x74,\n      0x69, 0x6F, 0x6E, 0x2F,\n      0x68, 0x6C, 0x73, 0x2E,\n      0x6A, 0x73, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11]) // pre_defined = -1;\n    const avcc = new Uint8Array([\n      0x01, // version\n      sps[1], // profile\n      sps[2], // profile compatible\n      sps[3], // level\n      0xfc | 3,\n      0xE0 | 1, // 目前只处理一个sps\n      sps.length >>> 8 & 0xff,\n      sps.length & 0xff\n    ].concat(...sps).concat([\n      0x01,\n      pps.length >>> 8 & 0xff,\n      pps.length & 0xff\n    ]).concat(...pps))\n    const btrt = new Uint8Array([\n      0x00, 0x00, 0x58, 0x39,\n      0x00, 0x0F, 0xC8, 0xC0,\n      0x00, 0x04, 0x56, 0x48\n    ])\n    const sinf = MP4.sinf(track.encv)\n    const pasp = new Uint8Array([\n      (hSpacing >> 24), // hSpacing\n      (hSpacing >> 16) & 0xff,\n      (hSpacing >> 8) & 0xff,\n      hSpacing & 0xff,\n      (vSpacing >> 24), // vSpacing\n      (vSpacing >> 16) & 0xff,\n      (vSpacing >> 8) & 0xff,\n      vSpacing & 0xff\n    ])\n    return MP4.box(MP4.types.encv, content, MP4.box(MP4.types.avcC, avcc), MP4.box(MP4.types.btrt, btrt), sinf, MP4.box(MP4.types.pasp, pasp))\n  }\n\n  static schi (data) {\n    const content = new Uint8Array([])\n    const tenc = MP4.tenc(data)\n    return MP4.box(MP4.types.schi, content, tenc)\n  }\n\n  static tenc (data) {\n    //  用于每个track的加密参数（包括KID、初始化向量、加密标志位），包含在TrackEncryptionBox(‘tenc’)中。\n    const content = new Uint8Array(\n      [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // skip\n        data.default_IsEncrypted & 0xff, // default_isProtected\n        data.default_IV_size & 0xff // default_Per_Sample_IV_Size\n      ].concat(parse(data.default_KID)))\n    return MP4.box(MP4.types.tenc, content)\n  }\n\n  static sinf (data) {\n    const content = new Uint8Array([])\n    const frma = new Uint8Array([\n      data.data_format.charCodeAt(0),\n      data.data_format.charCodeAt(1),\n      data.data_format.charCodeAt(2),\n      data.data_format.charCodeAt(3)\n    ])\n    const schm = new Uint8Array([\n      0x00, 0x00, 0x00, 0x00,\n      0x63, 0x65, 0x6E, 0x63, // cenc\n      0x00, 0x01, 0x00, 0x00 // version\n    ])\n    const schi = MP4.schi(data)\n    return MP4.box(MP4.types.sinf, content, MP4.box(MP4.types.frma, frma), MP4.box(MP4.types.schm, schm), schi)\n  }\n  static av01 (track) {\n    return MP4.box(MP4.types.av01, new Uint8Array([\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n      (track.width >> 8) & 0xff, track.width & 0xff, // width\n      (track.height >> 8) & 0xff, track.height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // compressor name\n      0x00, 0x18, // depth\n      0x11, 0x11 // pre_defined = -1 //todo\n    ]), track.av1C, track.colr)\n  }\n  static avc1hev1 (track) {\n    const isHevc = track.codecType === VideoCodecType.HEVC\n    const typ = isHevc ? MP4.types.hvc1 : MP4.types.avc1\n    const config = isHevc ? MP4.hvcC(track) : MP4.avcC(track)\n    const boxes = [\n      new Uint8Array([\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // data_reference_index\n        0x00, 0x00, // pre_defined\n        0x00, 0x00, // reserved\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n        (track.width >> 8) & 0xff, track.width & 0xff, // width\n        (track.height >> 8) & 0xff, track.height & 0xff, // height\n        0x00, 0x48, 0x00, 0x00, // horizresolution\n        0x00, 0x48, 0x00, 0x00, // vertresolution\n        0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // frame_count\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, // compressor name\n        0x00, 0x18, // depth\n        0x11, 0x11 // pre_defined = -1 //todo\n      ]), config\n    ]\n    // console.log('[remux],avc1hev1_0, len,', boxes[0].byteLength, hashVal(boxes[0].toString()))\n    // console.log('[remux],avc1hev1_1, len,', boxes[1].byteLength, hashVal(boxes[1].toString()))\n    if (isHevc) {\n      boxes.push(MP4.box(MP4.types.fiel, new Uint8Array([0x01, 0x00])))\n      // console.log('[remux],fiel, len,', boxes[2].byteLength, hashVal(boxes[2].toString()))\n    } else if (track.sarRatio && track.sarRatio.length > 1) {\n      boxes.push(MP4.pasp(track.sarRatio))\n      // console.log('[remux],pasp, len,', boxes[2].byteLength, hashVal(boxes[2].toString()))\n    }\n    return MP4.box(typ, ...boxes)\n  }\n\n  static avcC (track) {\n    const sps = []\n    const pps = []\n\n    let len\n    track.sps.forEach((s) => {\n      len = s.byteLength\n      sps.push((len >>> 8) & 0xff)\n      sps.push(len & 0xff)\n      sps.push(...s)\n    })\n\n    track.pps.forEach((p) => {\n      len = p.byteLength\n      pps.push((len >>> 8) & 0xff)\n      pps.push(len & 0xff)\n      pps.push(...p)\n    })\n\n    return MP4.box(MP4.types.avcC, new Uint8Array([\n      0x01, // configurationVersion\n      sps[3], // AVCProfileIndication\n      sps[4], // profile_compatibility\n      sps[5], // AVCLevelIndication\n      0xfc | 3, // lengthSizeMinusOne\n      0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(...sps)\n      .concat([track.pps.length]) // numOfPictureParameterSets\n      .concat(...pps)))\n  }\n\n  static hvcC (track) {\n    const hvcC = track.hvcC\n    if (hvcC instanceof ArrayBuffer || hvcC instanceof Uint8Array) return hvcC\n    const { vps, sps, pps } = track\n    let data\n    if (hvcC) {\n      const pcf = hvcC.generalProfileCompatibilityFlags\n      const cif = hvcC.generalConstraintIndicatorFlags\n      const numOfArrays = (vps.length && 1) + (sps.length && 1) + (pps.length && 1)\n      data = [\n        0x01, // configurationVersion\n        hvcC.generalProfileSpace << 6 | hvcC.generalTierFlag << 5 | hvcC.generalProfileIdc,\n        pcf >>> 24, pcf >>> 16, pcf >>> 8, pcf,\n        cif[0], cif[1], cif[2], cif[3], cif[4], cif[5],\n        hvcC.generalLevelIdc,\n        0xF0, 0x00, // min_spatial_segmentation_idc\n        0xFC, // parallelismType\n        hvcC.chromaFormatIdc | 0xFC,\n        hvcC.bitDepthLumaMinus8 | 0xF8,\n        hvcC.bitDepthChromaMinus8 | 0xF8,\n        0x00, 0x00, // avgFrameRate\n        hvcC.numTemporalLayers << 3 | hvcC.temporalIdNested << 2 | 3,\n        numOfArrays\n      ]\n      const write = (x) => {\n        data.push(x.length >> 8, x.length)\n        data.push(...x)\n      }\n      if (vps.length) {\n        data.push(0xA0, 0x00, vps.length)\n        vps.forEach(write)\n      }\n      if (sps.length) {\n        data.push(0xA1, 0x00, sps.length)\n        sps.forEach(write)\n      }\n      if (pps.length) {\n        data.push(0xA2, 0x00, pps.length)\n        pps.forEach(write)\n      }\n    } else {\n      data = [\n        0x01, // configurationVersion\n        0x01, // profile_space + tier_flag + profile_idc\n        0x60, 0x00, 0x00, 0x00, // general_profile_compatibility\n        0x90, 0x00, 0x00, 0x00, 0x00, 0x00, // constraint_indicator_flags\n        0x5D, // level_idc=90\n        0xF0, 0x00, 0xFC, 0xFD, // profile_compatibility_indications\n        0xF8, // ‘11111’b + bitDepthLumaMinus8\n        0xF8, // ‘11111’b + bitDepthChromaMinus8\n        0x00, 0x00, // avgFrameRate\n        0x0F, // constantFrameRate + numTemporalLayers + ‘1’b + lengthSizeMinusOne\n        0x03, // numOfArrays\n\n        // vps\n        0xA0, 0x00, 0x01, // array_completeness + ‘0’b + NAL_unit_type + numNalus\n        0x00, 0x18, // nalUnitLength\n        0x40, 0x01, 0x0C, 0x01, 0xFF, 0xFF, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x5D, 0x99, 0x98, 0x09,\n\n        // sps\n        0xA1, 0x00, 0x01, // array_completeness + ‘0’b + NAL_unit_type + numNalus\n        0x00, 0x2D, // nalUnitLength\n        0x42, 0x01, 0x01, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x5D, 0xA0, 0x02,\n        0x80, 0x80, 0x2D, 0x16, 0x59, 0x99, 0xA4, 0x93, 0x2B, 0x9A, 0x80, 0x80, 0x80, 0x82, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00,\n        0x00, 0x03, 0x00, 0x32, 0x10,\n\n        // pps\n        0xA2, 0x00, 0x01, // array_completeness + ‘0’b + NAL_unit_type + numNalus\n        0x00, 0x07, // nalUnitLength\n        0x44, 0x01, 0xC1, 0x72, 0xB4, 0x62, 0x40\n      ]\n    }\n    return MP4.box(MP4.types.hvcC, new Uint8Array(data))\n  }\n\n  static pasp ([hSpacing, vSpacing]) {\n    return MP4.box(MP4.types.pasp, new Uint8Array([\n      hSpacing >> 24, (hSpacing >> 16) & 0xff, (hSpacing >> 8) & 0xff, hSpacing & 0xff,\n      vSpacing >> 24, (vSpacing >> 16) & 0xff, (vSpacing >> 8) & 0xff, vSpacing & 0xff\n    ]))\n  }\n\n  static mp4a (track) {\n    return MP4.box(MP4.types.mp4a, new Uint8Array([\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, track.channelCount,\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      (track.sampleRate >> 8) & 0xff, track.sampleRate & 0xff,\n      0x00, 0x00\n    ]), track.config.length ? MP4.esds(track.config) : undefined)\n  }\n\n  static esds (config) {\n    const len = config.length\n    const esds = MP4.box(MP4.types.esds, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x03, // tag\n      0x17 + len, // length\n      0x00, 0x00, // ES_ID\n      0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n      0x04, // tag\n      0x0f + len, // length\n      0x40, // object type\n      0x15, // streamType\n      0x00, 0x06, 0x00, // bufferSizeDB\n      0x00, 0x00, 0xda, 0xc0, // maxBitrate\n      0x00, 0x00, 0xda, 0xc0, // avgBitrate\n      0x05 // tag, DecoderSpecificInfoTag\n    ].concat([len])\n      .concat(config)\n      .concat(\n        [0x06, 0x01, 0x02]// GASpecificConfig\n      )\n    ))\n    // console.log('[remux],esds ,len ', esds.byteLength, hashVal(esds.toString()))\n    return esds\n  }\n\n  /**\n   * https://opus-codec.org/docs/opus_in_isobmff.html\n   */\n  static opus (track) {\n    const opusAudioDescription = new Uint8Array([\n      0x00, 0x00, 0x00, // version\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      track.channelCount,\n      0x00, 0x10, // sampleSize\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      (track.sampleRate >> 8) & 0xff,\n      track.sampleRate & 0xff, // sampleRate\n      0x00, 0x00\n    ])\n\n    const opusSpecificConfig = track.config.length ? MP4.dOps(track) : []\n    return MP4.box(MP4.types.Opus, opusAudioDescription, opusSpecificConfig)\n  }\n\n  static dOps (track) {\n    if (track.config) {\n      track.config[4] = (track.sampleRate >>> 24) & 0xFF\n      track.config[5] = (track.sampleRate >>> 16) & 0xFF\n      track.config[6] = (track.sampleRate >>> 8) & 0xFF\n      track.config[7] = (track.sampleRate) & 0xFF\n\n      return MP4.box(MP4.types.dOps, track.config)\n    }\n\n    // const {channelCount, channelConfigCode, sampleRate } = track\n\n    // const mapping = channelConfigCode?.map((c) => {\n    //   return [\n    //     (c >>> 4) & 0xFF, // Channel mapping family\n    //     c & 0xFF // Channel mapping index\n    //   ]\n    // }).flat() || []\n\n    // const data = new Uint8Array([\n    //   0x00, // version\n    //   channelCount, // channelCount\n    //   0x00, 0x00, // preSkip\n    //   (sampleRate >>> 24) & 0xFF,\n    //   (sampleRate >>> 17) & 0xFF,\n    //   (sampleRate >>> 8) & 0xFF,\n    //   (sampleRate >>> 0) & 0xFF,\n    //   0x00, 0x00, // Global Gain\n    //   ... mapping\n    // ])\n\n    // return data\n  }\n\n  static mvex (tracks) {\n    // const mehd = MP4.box(MP4.types.mehd, this.extension(0, 0), Buffer.writeUint32(tracks[0].tkhdDuration))\n    // const mvex = MP4.box(MP4.types.mvex, mehd, MP4.trex1(1), MP4.trex2(2))\n    // // console.log('[remux],mvex, len,', mvex.byteLength, hashVal(mvex.toString()))\n    // const mvex = MP4.box(MP4.types.mvex, MP4.trex1(1), MP4.trex2(2))\n    const mvex = MP4.box(MP4.types.mvex, ...tracks.map((t) => MP4.trex(t.id)))\n    // console.log('[remux],mvex, len,', mvex.byteLength, hashVal(mvex.toString()))\n    return mvex\n  }\n\n  static trex (id) {\n    const trex = MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      id >> 24, (id >> 16) & 0xff, (id >> 8) & 0xff, id & 0xff, // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]))\n    // console.log('[remux],trex, len,', trex.byteLength, hashVal(trex.toString()))\n    return trex\n  }\n\n  static trex1 (id) {\n    const trex = MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      (id >> 24),\n      (id >> 16) & 0xff,\n      (id >> 8) & 0xff,\n      (id & 0xff), // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x02, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x00 // default_sample_flags\n    ]))\n    // console.log('[remux],trex, len,', trex.byteLength, hashVal(trex.toString()))\n    return trex\n  }\n\n  static trex2 (id) {\n    const trex = MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      (id >> 24),\n      (id >> 16) & 0xff,\n      (id >> 8) & 0xff,\n      (id & 0xff), // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x04, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x02, 0x00, 0x00, 0x00 // default_sample_flags\n    ]))\n    // console.log('[remux],trex, len,', trex.byteLength, hashVal(trex.toString()))\n    return trex\n  }\n\n  static moof (tracks) {\n    const moof = MP4.box(MP4.types.moof, MP4.mfhd(tracks[0].samples ? tracks[0].samples[0].gopId : 0), ...tracks.map((t) => MP4.traf(t)))\n    // console.log('[remux],moof, len', moof.byteLength)\n    return moof\n    // return MP4.box(MP4.types.moof, MP4.mfhd(tracks[0].gopId), ...tracks.map((t) => MP4.traf(t)))\n  }\n\n  static mfhd (sequenceNumber) {\n    // sequenceNumber += 1\n    const mfhd = MP4.box(MP4.types.mfhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      sequenceNumber >> 24, (sequenceNumber >> 16) & 0xff, (sequenceNumber >> 8) & 0xff, sequenceNumber & 0xff\n    ]))\n    // console.log('[remux],mfhd, len,', mfhd.byteLength, hashVal(mfhd.toString()))\n    return mfhd\n  }\n\n  static traf (track) {\n    const tfhd = MP4.tfhd(track.id)\n    // console.log('[remux],tfhd, len,', tfhd.byteLength, hashVal(tfhd.toString()), ', trackid = ', track.id)\n    // console.log('[remux],tfdt,baseMediaDecodeTime,', track.baseMediaDecodeTime)\n    const tfdt = MP4.tfdt(track, track.baseMediaDecodeTime)\n    let sencLength = 0\n    let samples\n    if (track.isVideo && track.videoSenc) {\n      samples = track.videoSenc\n      samples.forEach(function (item) {\n        sencLength = sencLength + 8\n        if (item.subsamples && item.subsamples.length) {\n          sencLength = sencLength + 2\n          sencLength = sencLength + item.subsamples.length * 6\n        }\n      })\n    }\n    track.videoSencLength = sencLength\n    // console.log('[remux],tfdt, len,', tfdt.toString().length)\n    // console.log('[remux],tfdt, len,', tfdt.byteLength, hashVal(tfdt.toString()))\n    if (!track.useEME || (!track.isVideoEncryption && !track.isAudioEncryption)) {\n      const sdtp = MP4.sdtp(track)\n      // console.log('[remux],sdtp, len,', sdtp.byteLength, hashVal(sdtp.toString()))\n      const offset = 16 + // tfhd\n        20 + // tfdt\n        8 + // traf header\n        16 + // mfhd\n        8 + // moof header\n        8 // mdat header\n      return MP4.box(MP4.types.traf, tfhd, tfdt, sdtp, MP4.trun(track.samples, sdtp.byteLength + offset))\n    } else if (track.isVideoEncryption) {\n      if (track.isVideo) {\n        // 加密视频\n        const saiz = MP4.saiz(track)\n        const saio = MP4.saio(track)\n        const trun = MP4.trun1(track)\n        const senc = MP4.senc(track)\n        const traf = MP4.box(MP4.types.traf, tfhd, tfdt, saiz, saio, trun, senc)\n        // console.log('[remux],trex_video, len,', traf.byteLength, hashVal(traf.toString()))\n        return traf\n      } else {\n        // 视频加密，音频加密和未加密处理\n        if (!track.isAudioEncryption) {\n          // 音频未加密\n          const sbgp = MP4.sbgp()\n          const trun = MP4.trun1(track)\n          return MP4.box(MP4.types.traf, tfhd, tfdt, sbgp, trun)\n        } else {\n          // 音频加密\n          const sbgp = MP4.sbgp()\n          const saiz = MP4.saiz(track)\n          const saio = MP4.saio(track)\n          const senc = MP4.senc(track)\n          const trun = MP4.trun1(track)\n          const traf = MP4.box(MP4.types.traf, tfhd, tfdt, sbgp, saiz, saio, senc, trun)\n          // console.log('[remux],trex_audio, len,', traf.byteLength, hashVal(traf.toString()))\n          return traf\n        }\n      }\n    } else {\n      // 视频未加密，音频加密\n      if (track.isVideo) {\n        const trun = MP4.trun1(track)\n        return MP4.box(MP4.types.traf, tfhd, tfdt, trun)\n      } else {\n        const sbgp = MP4.sbgp()\n        const saiz = MP4.saiz(track)\n        const saio = MP4.saio(track)\n        const senc = MP4.senc(track)\n        const trun = MP4.trun1(track)\n        const traf = MP4.box(MP4.types.traf, tfhd, tfdt, sbgp, saiz, saio, senc, trun)\n        // console.log('[remux],trex, len,', traf.byteLength, hashVal(traf.toString()))\n        return traf\n      }\n    }\n  }\n\n  static sdtp (data) {\n    const buffer = new Buffer()\n    data.samples.forEach(item => {\n      buffer.write(new Uint8Array(data.isVideo ? [item.keyframe ? 32 : 16] : [16]))\n    })\n    return MP4.box(MP4.types.sdtp, this.extension(0, 0), buffer.buffer)\n  }\n\n  static trun1 (data) {\n    // const id = data.id\n    // const ceil = id === 1 ? 12 : 4\n    const buffer = new Buffer()\n    const sampleCount = Buffer.writeUint32(data.samples.length)\n    let offset = null\n    if (data.isVideo) {\n      const sencLength = data.videoSencLength\n      /*\n      16 + // mfhd\n      16 + // tfhd\n      20 + // tfdt\n      17 + //saiz\n      24 + //saio\n      data.samples.length*16\n      4(offset) + 4(sampleCount) + 12(header)  //trun\n      12(header) + sencLength //senc\n      8 + // traf header\n      8 + // moof header\n      8 // mdat header\n      = 149+data.samples.length * 16 + sencLength\n       */\n      offset = Buffer.writeUint32(data.samples.length * 16 + sencLength + 149)\n      if (!data.isVideoEncryption && data.isAudioEncryption) {\n        offset = Buffer.writeUint32(data.samples.length * 16 + 92)\n      }\n    } else {\n      /*\n      16 + // mfhd\n      16 + // tfhd\n      20 + // tfdt\n      28 + //sbgp\n      4(offset) + 4(sampleCount) + 12(header)  //trun\n      8 + // traf header\n      8 + // moof header\n      8 // mdat header\n       */\n      let len = data.samples.length * 12 + 124\n      if (data.isAudioEncryption) {\n        len = data.samples.length * 12 + 8 * data.audioSenc.length + 177\n      }\n      offset = Buffer.writeUint32(len)\n    }\n\n    data.samples.forEach(item => {\n      buffer.write(Buffer.writeUint32(item.duration))\n      buffer.write(Buffer.writeUint32(item.size))\n      buffer.write(Buffer.writeUint32(item.keyframe ? 0x02000000 : 0x00010000))\n      if (data.isVideo) {\n        buffer.write(Buffer.writeUint32(item.cts ? item.cts : 0))\n      }\n    })\n\n    return MP4.box(MP4.types.trun, this.extension(0, data.flags), sampleCount, offset, buffer.buffer)\n  }\n\n  static senc (data) {\n    const buffer = new Buffer()\n    const len = data.samples.length\n    const ceil = data.isVideo ? 16 : 8\n    const flag = data.isVideo ? 2 : 0\n    let samples = []\n    let samplesLength = 0\n    if (data.isVideo) {\n      samples = data.videoSenc\n      samplesLength = data.videoSencLength\n    } else {\n      samples = data.audioSenc\n    }\n    samplesLength = samplesLength || ceil * len\n    buffer.write(\n      Buffer.writeUint32(16 + samplesLength), MP4.types.senc, this.extension(0, flag)\n    )\n    buffer.write(Buffer.writeUint32(len))\n    samples.forEach(item => {\n      for (let i = 0; i < item.InitializationVector.length; i++) {\n        buffer.write(new Uint8Array([item.InitializationVector[i]]))\n      }\n      if (item.subsamples && item.subsamples.length) {\n        buffer.write(Buffer.writeUint16(item.subsamples.length))\n        item.subsamples.forEach(value => {\n          buffer.write(Buffer.writeUint16(value.BytesOfClearData))\n          buffer.write(Buffer.writeUint32(value.BytesOfProtectedData))\n        })\n      }\n    })\n    return buffer.buffer\n    // return MP4.box(MP4.types.senc, this.extension(0, flag), buffer.buffer)\n  }\n\n  static saio (data) {\n    let length = data.samples.length * 12 + 141\n    if (!data.isVideo && data.isAudioEncryption) {\n      length = 149\n    }\n    const content = new Uint8Array([\n      0x01, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x01,\n      0x00, 0x00, 0x00, 0x00,\n      (length >> 24) & 0xff,\n      (length >> 16) & 0xff,\n      (length >> 8) & 0xff,\n      length & 0xff\n    ])\n    return MP4.box(MP4.types.saio, content)\n  }\n\n  static saiz (data) {\n    const samplesLength = data.samples.length\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, 0x00,\n      0x10, // default sample info size\n      (samplesLength >> 24) & 0xff,\n      (samplesLength >> 16) & 0xff,\n      (samplesLength >> 8) & 0xff,\n      samplesLength & 0xff\n    ])\n    return MP4.box(MP4.types.saiz, content)\n  }\n\n  static sbgp () {\n    const content = new Uint8Array([\n      0x72, 0x6F, 0x6C, 0x6C, // sgpd, grouping_type\n      0x00, 0x00, 0x00, 0x01,\n      0x00, 0x00, 0x01, 0x19,\n      0x00, 0x00, 0x00, 0x01\n    ])\n    return MP4.box(MP4.types.sbgp, this.extension(0, 0), content)\n  }\n\n  static extension (version, flag) {\n    return new Uint8Array([\n      version,\n      (flag >> 16) & 0xff,\n      (flag >> 8) & 0xff,\n      flag & 0xff\n    ])\n  }\n\n  static tfhd (id) {\n    return MP4.box(MP4.types.tfhd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags todo 0x00\n      id >> 24, (id >> 16) & 0xff, (id >> 8) & 0xff, id & 0xff // track_ID\n    ]))\n  }\n\n  static tfdt (data, baseMediaDecodeTime) {\n    const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1))\n    const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1))\n    if (data.useEME && (data.isVideoEncryption || data.isAudioEncryption)) {\n      return MP4.box(MP4.types.tfdt, new Uint8Array([\n        0x00, // version 0\n        0x00, 0x00, 0x00, // flags\n        lowerWordBaseMediaDecodeTime >> 24,\n        (lowerWordBaseMediaDecodeTime >> 16) & 0xff,\n        (lowerWordBaseMediaDecodeTime >> 8) & 0xff,\n        lowerWordBaseMediaDecodeTime & 0xff\n      ]))\n    } else {\n      return MP4.box(MP4.types.tfdt, new Uint8Array([\n        0x01, // version 1\n        0x00, 0x00, 0x00, // flags\n        upperWordBaseMediaDecodeTime >> 24,\n        (upperWordBaseMediaDecodeTime >> 16) & 0xff,\n        (upperWordBaseMediaDecodeTime >> 8) & 0xff,\n        upperWordBaseMediaDecodeTime & 0xff,\n        lowerWordBaseMediaDecodeTime >> 24,\n        (lowerWordBaseMediaDecodeTime >> 16) & 0xff,\n        (lowerWordBaseMediaDecodeTime >> 8) & 0xff,\n        lowerWordBaseMediaDecodeTime & 0xff\n      ]))\n    }\n  }\n\n  static trun (samples, offset) {\n    const sampleLen = samples.length\n    const dataLen = 12 + (16 * sampleLen)\n    offset += 8 + dataLen\n    const data = new Uint8Array(dataLen)\n    data.set([\n      0x00, // version\n      0x00, 0x0f, 0x01, // flags\n      (sampleLen >>> 24) & 0xff, (sampleLen >>> 16) & 0xff, (sampleLen >>> 8) & 0xff, sampleLen & 0xff,\n      (offset >>> 24) & 0xff, (offset >>> 16) & 0xff, (offset >>> 8) & 0xff, offset & 0xff // data_offset\n    ], 0)\n    for (let i = 0; i < sampleLen; i++) {\n      const {\n        duration, size, flag = {}, cts = 0\n      } = samples[i]\n      data.set([\n        (duration >>> 24) & 0xff, (duration >>> 16) & 0xff, (duration >>> 8) & 0xff, duration & 0xff,\n        (size >>> 24) & 0xff, (size >>> 16) & 0xff, (size >>> 8) & 0xff, size & 0xff,\n        (flag.isLeading << 2) | (flag.dependsOn === null || flag.dependsOn === undefined ? 1 : flag.dependsOn),\n        (flag.isDependedOn << 6) | (flag.hasRedundancy << 4) | (flag.paddingValue << 1) | (flag.isNonSyncSample === null || flag.isNonSyncSample === undefined ? 1 : flag.isNonSyncSample),\n        flag.degradationPriority & (0xf0 << 8), flag.degradationPriority & 0x0f, // sample_flags\n        (cts >>> 24) & 0xff, (cts >>> 16) & 0xff, (cts >>> 8) & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i)\n    }\n\n    return MP4.box(MP4.types.trun, data)\n  }\n\n  static moovMP4 (tracks) {\n    return MP4.box(MP4.types.moov,\n      MP4.mvhd(tracks[0].duration, tracks[0].timescale),\n      ...tracks.map((t) => MP4.trackMP4(t)))\n  }\n\n  static trackMP4 (track) {\n    return MP4.box(\n      MP4.types.trak,\n      MP4.tkhd(track.id, track.duration, track.width, track.height),\n      MP4.mdiaMP4(track)\n    )\n  }\n\n  static mdiaMP4 (track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.duration, track.timescale), MP4.hdlr(track.type), MP4.minfMP4(track))\n  }\n\n  static minfMP4 (track) {\n    return MP4.box(MP4.types.minf, track.type === TrackType.VIDEO ? MP4.VMHD : MP4.SMHD, MP4.DINF, MP4.stblMP4(track))\n  }\n\n  static stblMP4 (track) {\n    const { ext } = track\n    const boxes = [\n      MP4.stsd(track),\n      MP4.stts(ext.stts),\n      MP4.stsc(ext.stsc),\n      MP4.stsz(ext.stsz),\n      MP4.stco(ext.stco)\n    ]\n\n    if (ext.stss.length) {\n      boxes.push(MP4.stss(ext.stss))\n    }\n\n    if (ext.ctts.length) {\n      boxes.push(MP4.ctts(ext.ctts))\n    }\n\n    return MP4.box(MP4.types.stbl, ...boxes)\n  }\n\n  static stts (samples) {\n    const len = samples.length\n    const data = new Uint8Array(8 * len)\n    let offset = 0\n    samples.forEach(({ value, count }) => {\n      data.set([\n        count >> 24, (count >> 16) & 0xff, (count >> 8) & 0xff, count & 0xff,\n        value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff\n      ], offset)\n      offset += 8\n    })\n\n    return MP4.box(MP4.types.stts, concatUint8Array(new Uint8Array([\n      0, 0, 0, 0,\n      (len >> 24), (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n    ]), data))\n  }\n\n  static stsc (entries) {\n    const len = entries.length\n    const data = new Uint8Array(12 * len)\n    let offset = 0\n    entries.forEach(({ firstChunk, samplesPerChunk, sampleDescIndex }) => {\n      data.set([\n        firstChunk >> 24, (firstChunk >> 16) & 0xff, (firstChunk >> 8) & 0xff, firstChunk & 0xff,\n        samplesPerChunk >> 24, (samplesPerChunk >> 16) & 0xff, (samplesPerChunk >> 8) & 0xff, samplesPerChunk & 0xff,\n        sampleDescIndex >> 24, (sampleDescIndex >> 16) & 0xff, (sampleDescIndex >> 8) & 0xff, sampleDescIndex & 0xff\n      ], offset)\n      offset += 12\n    })\n    return MP4.box(MP4.types.stsc, concatUint8Array(new Uint8Array([\n      0, 0, 0, 0,\n      (len >> 24), (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n    ]), data))\n  }\n\n  static stsz (samplesSizes) {\n    const len = samplesSizes.length\n    const data = new Uint8Array(4 * len)\n    let offset = 0\n    samplesSizes.forEach((x) => {\n      data.set([\n        x >> 24, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff\n      ], offset)\n      offset += 4\n    })\n    return MP4.box(MP4.types.stsz, concatUint8Array(\n      new Uint8Array([\n        0, 0, 0, 0,\n        0, 0, 0, 0,\n        len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n      ]),\n      data\n    ))\n  }\n\n  static stco (offsets) {\n    const len = offsets.length\n    const data = new Uint8Array(4 * len)\n    let offset = 0\n    offsets.forEach((x) => {\n      data.set([\n        x >> 24, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff\n      ], offset)\n      offset += 4\n    })\n    return MP4.box(MP4.types.stco, concatUint8Array(\n      new Uint8Array([\n        0, 0, 0, 0,\n        len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n      ]),\n      data\n    ))\n  }\n\n  static stss (keyframeIndexes) {\n    const len = keyframeIndexes.length\n    const data = new Uint8Array(4 * len)\n    let offset = 0\n    keyframeIndexes.forEach((x) => {\n      data.set([\n        x >> 24, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff\n      ], offset)\n      offset += 4\n    })\n    return MP4.box(MP4.types.stss, concatUint8Array(\n      new Uint8Array([\n        0, 0, 0, 0,\n        len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n      ]),\n      data\n    ))\n  }\n\n  static ctts (samples) {\n    const len = samples.length\n    const data = new Uint8Array(8 * len)\n    let offset = 0\n    samples.forEach(({ value, count }) => {\n      data.set([\n        count >> 24, (count >> 16) & 0xff, (count >> 8) & 0xff, count & 0xff,\n        value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff\n      ], offset)\n      offset += 8\n    })\n    return MP4.box(MP4.types.ctts, concatUint8Array(new Uint8Array([\n      0, 0, 0, 0,\n      len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n    ]), data))\n  }\n\n  static styp () {\n    return MP4.box(MP4.types.styp, new Uint8Array([\n      0x6D, 0x73, 0x64, 0x68,\n      0x00, 0x00, 0x00, 0x00,\n      0x6D, 0x73, 0x64, 0x68,\n      0x6D, 0x73, 0x69, 0x78\n    ]))\n  }\n\n  // data.sampleOffset 指的是samples的序列号。_samples[0].idx\n  static sidx (data) {\n    // const buffer = new Buffer()\n    const timescale = data.timescale\n    const duration = data.samples[0].duration\n    const durationCount = duration * data.samples.length\n    const earliestTime = data.samples[0].sampleOffset * duration\n    let mdatSize = 8\n    data.samples.forEach(item => {\n      mdatSize += item.size\n    })\n    let length = 0\n    if (data.isVideo) {\n      let sencLength = 0\n      let samples\n      if (data.videoSenc) {\n        samples = data.videoSenc\n      }\n      if (data.isVideo) {\n        samples.forEach(item => {\n          sencLength = sencLength + 8\n          if (item.subsamples && item.subsamples.length) {\n            sencLength = sencLength + 2\n            sencLength = sencLength + item.subsamples.length * 6\n          }\n        })\n      }\n      data.videoSencLength = sencLength\n      length = mdatSize + 141 + data.samples.length * 16 + sencLength\n      if (data.useEME && data.isAudioEncryption && !data.isVideoEncryption) {\n        length = mdatSize + (data.samples.length * 16) + 84\n      }\n    } else {\n      length = mdatSize + 116 + data.samples.length * 12\n      if (data.useEME && data.isAudioEncryption) {\n        length = mdatSize + 169 + data.samples.length * 12 + 8 * data.audioSenc.length\n      }\n    }\n\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, data.id & 0xff, // ref_id\n      (timescale >> 24) & 0xff,\n      (timescale >> 16) & 0xff,\n      (timescale >> 8) & 0xff,\n      timescale & 0xff, // timescale\n      (earliestTime >> 24) & 0xff,\n      (earliestTime >> 16) & 0xff,\n      (earliestTime >> 8) & 0xff,\n      earliestTime & 0xff, // earliest_presentation_time\n      0x00, 0x00, 0x00, 0x00, // first_offset\n      0x00, 0x00, // reserved\n      0x00, 0x01, // ref_count\n      // 0x00, 0x04, 0x11, 0xCF, // ref_size + ref_type\n      // 0x00, 0x01, 0x0A, 0xA6, // ref_size + ref_type\n      0x00, // ref_size + ref_type ref_size = moof.size + mdat.size\n      (length >> 16) & 0xff,\n      (length >> 8) & 0xff,\n      length & 0xff,\n      (durationCount >> 24) & 0xff,\n      (durationCount >> 16) & 0xff,\n      (durationCount >> 8) & 0xff,\n      durationCount & 0xff,\n      0x90, 0x00, 0x00, 0x00\n    ])\n    return MP4.box(MP4.types.sidx, content)\n  }\n\n  static mdat (data) {\n    const mdat = MP4.box(MP4.types.mdat, data)\n    // console.log('[remux],mdat ,len ', mdat.byteLength, hashVal(mdat.toString()))\n    return mdat\n  }\n}\n","\nexport class Logger {\n  constructor (name, enable) {\n    this.name = name || ''\n    this._prefix = `[${this.name}]`\n    Logger.disabled = enable\n  }\n\n  debug (...args) {\n    if (Logger.disabled) return\n    console.debug(this._prefix, ...args)\n  }\n\n  log (...args) {\n    if (Logger.disabled) return\n    console.log(this._prefix, ...args)\n  }\n\n  warn (...args) {\n    if (Logger.disabled) return\n    console.warn(this._prefix, ...args)\n  }\n\n  error (...args) {\n    if (Logger.disabled) return\n    console.error(this._prefix, ...args)\n  }\n\n  table (...args) {\n    if (Logger.disabled) return\n    console.group(this._prefix)\n    console.table(...args)\n    console.groupEnd()\n  }\n\n  static disabled = true\n\n  static enable () {\n    Logger.disabled = false\n  }\n\n  static disable () {\n    Logger.disabled = true\n  }\n}\n","import {\n  WordArray,\n  Hasher,\n} from './core.js';\n\n// Constants table\nconst T = [];\n\n// Compute constants\nfor (let i = 0; i < 64; i += 1) {\n  T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n}\n\nconst FF = (a, b, c, d, x, s, t) => {\n  const n = a + ((b & c) | (~b & d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst GG = (a, b, c, d, x, s, t) => {\n  const n = a + ((b & d) | (c & ~d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst HH = (a, b, c, d, x, s, t) => {\n  const n = a + (b ^ c ^ d) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst II = (a, b, c, d, x, s, t) => {\n  const n = a + (c ^ (b | ~d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\n/**\n * MD5 hash algorithm.\n */\nexport class MD5Algo extends Hasher {\n  _doReset() {\n    this._hash = new WordArray([\n      0x67452301,\n      0xefcdab89,\n      0x98badcfe,\n      0x10325476,\n    ]);\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    // Swap endian\n    for (let i = 0; i < 16; i += 1) {\n      // Shortcuts\n      const offset_i = offset + i;\n      const M_offset_i = M[offset_i];\n\n      _M[offset_i] = (\n        (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff)\n          | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)\n      );\n    }\n\n    // Shortcuts\n    const H = this._hash.words;\n\n    const M_offset_0 = _M[offset + 0];\n    const M_offset_1 = _M[offset + 1];\n    const M_offset_2 = _M[offset + 2];\n    const M_offset_3 = _M[offset + 3];\n    const M_offset_4 = _M[offset + 4];\n    const M_offset_5 = _M[offset + 5];\n    const M_offset_6 = _M[offset + 6];\n    const M_offset_7 = _M[offset + 7];\n    const M_offset_8 = _M[offset + 8];\n    const M_offset_9 = _M[offset + 9];\n    const M_offset_10 = _M[offset + 10];\n    const M_offset_11 = _M[offset + 11];\n    const M_offset_12 = _M[offset + 12];\n    const M_offset_13 = _M[offset + 13];\n    const M_offset_14 = _M[offset + 14];\n    const M_offset_15 = _M[offset + 15];\n\n    // Working varialbes\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n\n    // Computation\n    a = FF(a, b, c, d, M_offset_0, 7, T[0]);\n    d = FF(d, a, b, c, M_offset_1, 12, T[1]);\n    c = FF(c, d, a, b, M_offset_2, 17, T[2]);\n    b = FF(b, c, d, a, M_offset_3, 22, T[3]);\n    a = FF(a, b, c, d, M_offset_4, 7, T[4]);\n    d = FF(d, a, b, c, M_offset_5, 12, T[5]);\n    c = FF(c, d, a, b, M_offset_6, 17, T[6]);\n    b = FF(b, c, d, a, M_offset_7, 22, T[7]);\n    a = FF(a, b, c, d, M_offset_8, 7, T[8]);\n    d = FF(d, a, b, c, M_offset_9, 12, T[9]);\n    c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n    b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n    a = FF(a, b, c, d, M_offset_12, 7, T[12]);\n    d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n    c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n    b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n    a = GG(a, b, c, d, M_offset_1, 5, T[16]);\n    d = GG(d, a, b, c, M_offset_6, 9, T[17]);\n    c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n    b = GG(b, c, d, a, M_offset_0, 20, T[19]);\n    a = GG(a, b, c, d, M_offset_5, 5, T[20]);\n    d = GG(d, a, b, c, M_offset_10, 9, T[21]);\n    c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n    b = GG(b, c, d, a, M_offset_4, 20, T[23]);\n    a = GG(a, b, c, d, M_offset_9, 5, T[24]);\n    d = GG(d, a, b, c, M_offset_14, 9, T[25]);\n    c = GG(c, d, a, b, M_offset_3, 14, T[26]);\n    b = GG(b, c, d, a, M_offset_8, 20, T[27]);\n    a = GG(a, b, c, d, M_offset_13, 5, T[28]);\n    d = GG(d, a, b, c, M_offset_2, 9, T[29]);\n    c = GG(c, d, a, b, M_offset_7, 14, T[30]);\n    b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n    a = HH(a, b, c, d, M_offset_5, 4, T[32]);\n    d = HH(d, a, b, c, M_offset_8, 11, T[33]);\n    c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n    b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n    a = HH(a, b, c, d, M_offset_1, 4, T[36]);\n    d = HH(d, a, b, c, M_offset_4, 11, T[37]);\n    c = HH(c, d, a, b, M_offset_7, 16, T[38]);\n    b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n    a = HH(a, b, c, d, M_offset_13, 4, T[40]);\n    d = HH(d, a, b, c, M_offset_0, 11, T[41]);\n    c = HH(c, d, a, b, M_offset_3, 16, T[42]);\n    b = HH(b, c, d, a, M_offset_6, 23, T[43]);\n    a = HH(a, b, c, d, M_offset_9, 4, T[44]);\n    d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n    c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n    b = HH(b, c, d, a, M_offset_2, 23, T[47]);\n\n    a = II(a, b, c, d, M_offset_0, 6, T[48]);\n    d = II(d, a, b, c, M_offset_7, 10, T[49]);\n    c = II(c, d, a, b, M_offset_14, 15, T[50]);\n    b = II(b, c, d, a, M_offset_5, 21, T[51]);\n    a = II(a, b, c, d, M_offset_12, 6, T[52]);\n    d = II(d, a, b, c, M_offset_3, 10, T[53]);\n    c = II(c, d, a, b, M_offset_10, 15, T[54]);\n    b = II(b, c, d, a, M_offset_1, 21, T[55]);\n    a = II(a, b, c, d, M_offset_8, 6, T[56]);\n    d = II(d, a, b, c, M_offset_15, 10, T[57]);\n    c = II(c, d, a, b, M_offset_6, 15, T[58]);\n    b = II(b, c, d, a, M_offset_13, 21, T[59]);\n    a = II(a, b, c, d, M_offset_4, 6, T[60]);\n    d = II(d, a, b, c, M_offset_11, 10, T[61]);\n    c = II(c, d, a, b, M_offset_2, 15, T[62]);\n    b = II(b, c, d, a, M_offset_9, 21, T[63]);\n\n    // Intermediate hash value\n    H[0] = (H[0] + a) | 0;\n    H[1] = (H[1] + b) | 0;\n    H[2] = (H[2] + c) | 0;\n    H[3] = (H[3] + d) | 0;\n  }\n  /* eslint-ensable no-param-reassign */\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n\n    const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n    const nBitsTotalL = nBitsTotal;\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n      (((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00)\n    );\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n      (((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00)\n    );\n\n    data.sigBytes = (dataWords.length + 1) * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const hash = this._hash;\n    const H = hash.words;\n\n    // Swap endian\n    for (let i = 0; i < 4; i += 1) {\n      // Shortcut\n      const H_i = H[i];\n\n      H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff)\n        | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);\n    }\n\n    // Return final computed hash\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.MD5('message');\n *     var hash = CryptoJS.MD5(wordArray);\n */\nexport const MD5 = Hasher._createHelper(MD5Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacMD5(message, key);\n */\nexport const HmacMD5 = Hasher._createHmacHelper(MD5Algo);\n","import { MP4 } from './mp4'\nimport { concatUint8Array } from '../utils'\nimport { Logger } from './logger'\n\n/**\n * @typedef {Object} RemuxResult\n * @property {Uint8Array} [videoInitSegment]\n * @property {Uint8Array} [audioInitSegment]\n * @property {Uint8Array} [videoSegment]\n * @property {Uint8Array} [audioSegment]\n */\n\nexport class FMP4Remuxer {\n  /**\n   * @param {import('../model').VideoTrack} videoTrack\n   * @param {import('../model').AudioTrack} audioTrack\n   */\n  constructor (videoTrack, audioTrack, options) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n    const browserVersions = /Chrome\\/([^.]+)/.exec(navigator.userAgent)\n    this.forceFirstIDR = browserVersions && Number(browserVersions[1]) < 50\n    this.log = new Logger('FMP4Remuxer', options && options.openLog ? !options.openLog : true)\n  }\n\n  /**\n   * @param {boolean} [createInit=false]\n   * @returns {RemuxResult}\n   */\n  remux (createInit = false, options = {}) {\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n    const hasVideo = videoTrack.exist()\n    const hasAudio = audioTrack.exist()\n\n    let videoInitSegment\n    let audioInitSegment\n\n    let initSegment\n    const tracks = []\n\n    if (createInit) {\n      if (options && options.initMerge) {\n        if (hasVideo) {\n          tracks.push(this.videoTrack)\n        }\n        if (hasAudio) {\n          tracks.push(this.audioTrack)\n        }\n        initSegment = MP4.initSegment(tracks)\n      } else {\n        if (hasVideo) videoInitSegment = MP4.initSegment([this.videoTrack])\n        if (hasAudio) audioInitSegment = MP4.initSegment([this.audioTrack])\n      }\n    }\n\n    let videoSegment\n    let audioSegment\n    if (hasVideo && videoTrack.hasSample()) {\n      videoSegment = this._remuxVideo()\n    }\n\n    if (hasAudio && audioTrack.hasSample()) {\n      audioSegment = this._remuxAudio()\n    }\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    return {\n      initSegment,\n      videoInitSegment,\n      audioInitSegment,\n      videoSegment,\n      audioSegment\n    }\n  }\n\n  _remuxVideo () {\n    const track = this.videoTrack\n    if (this.forceFirstIDR) {\n      track.samples[0].flag = { dependsOn: 2, isNonSyncSample: 0 }\n    }\n    const samples = track.samples\n    const isAV01 = /av01/.test(track.codec)\n\n    let mdatSize = 0\n\n    if (isAV01) {\n      samples.forEach((s) => {\n        mdatSize += s.data.byteLength\n      })\n    } else {\n      samples.forEach((s) => {\n        mdatSize += s.units.reduce((t, c) => (t + c.byteLength), 0)\n        mdatSize += (s.units.length * 4)\n      })\n    }\n\n    const mdata = new Uint8Array(mdatSize)\n\n    // av1没有uints，直接写入data即可\n    // todo: H.265/H.264为什么要拼接nals/uints而不直接用data？\n    if (isAV01) {\n      for (let i = 0, l = samples.length, offset = 0, sample; i < l; i++) {\n        sample = samples[i]\n        mdata.set(sample.data, offset)\n        sample.size = sample.data.byteLength\n        offset += sample.size\n      }\n    } else {\n      const mdatView = new DataView(mdata.buffer)\n      for (let i = 0, l = samples.length, offset = 0, sample; i < l; i++) {\n        sample = samples[i]\n\n        let sampleSize = 0\n        sample.units.forEach((u) => {\n          mdatView.setUint32(offset, u.byteLength)\n          offset += 4\n          mdata.set(u, offset)\n          offset += u.byteLength\n          sampleSize += (4 + u.byteLength)\n        })\n        sample.size = sampleSize\n      }\n    }\n    const mdat = MP4.mdat(mdata)\n\n    const moof = MP4.moof([track])\n    return concatUint8Array(moof, mdat)\n\n  }\n\n  _remuxAudio () {\n    const track = this.audioTrack\n    const mdata = new Uint8Array(track.samples.reduce((t, c) => (t + c.size), 0))\n    track.samples.reduce((offset, s) => {\n      mdata.set(s.data, offset)\n      return offset + s.size\n    }, 0)\n    const mdat = MP4.mdat(mdata)\n    const moof = MP4.moof([track])\n    return concatUint8Array(moof, mdat)\n  }\n\n  reset () {\n    this.videoTrack.reset()\n    this.audioTrack.reset()\n  }\n}\n","/* eslint-disable no-use-before-define */\n\n/**\n * Base class for inheritance.\n */\nexport class Base {\n  /**\n   * Extends this object and runs the init method.\n   * Arguments to create() will be passed to init().\n   *\n   * @return {Object} The new object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var instance = MyType.create();\n   */\n  static create(...args) {\n    return new this(...args);\n  }\n\n  /**\n   * Copies properties into this object.\n   *\n   * @param {Object} properties The properties to mix in.\n   *\n   * @example\n   *\n   *     MyType.mixIn({\n   *         field: 'value'\n   *     });\n   */\n  mixIn(properties) {\n    return Object.assign(this, properties);\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = instance.clone();\n   */\n  clone() {\n    const clone = new this.constructor();\n    Object.assign(clone, this);\n    return clone;\n  }\n}\n\n/**\n * An array of 32-bit words.\n *\n * @property {Array} words The array of 32-bit words.\n * @property {number} sigBytes The number of significant bytes in this word array.\n */\nexport class WordArray extends Base {\n  /**\n   * Initializes a newly created word array.\n   *\n   * @param {Array} words (Optional) An array of 32-bit words.\n   * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.create();\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n   */\n  constructor(words = [], sigBytes = words.length * 4) {\n    super();\n\n    let typedArray = words;\n    // Convert buffers to uint8\n    if (typedArray instanceof ArrayBuffer) {\n      typedArray = new Uint8Array(typedArray);\n    }\n\n    // Convert other array views to uint8\n    if (\n      typedArray instanceof Int8Array\n      || typedArray instanceof Uint8ClampedArray\n      || typedArray instanceof Int16Array\n      || typedArray instanceof Uint16Array\n      || typedArray instanceof Int32Array\n      || typedArray instanceof Uint32Array\n      || typedArray instanceof Float32Array\n      || typedArray instanceof Float64Array\n    ) {\n      typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n    }\n\n    // Handle Uint8Array\n    if (typedArray instanceof Uint8Array) {\n      // Shortcut\n      const typedArrayByteLength = typedArray.byteLength;\n\n      // Extract bytes\n      const _words = [];\n      for (let i = 0; i < typedArrayByteLength; i += 1) {\n        _words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n      }\n\n      // Initialize this word array\n      this.words = _words;\n      this.sigBytes = typedArrayByteLength;\n    } else {\n      // Else call normal init\n      this.words = words;\n      this.sigBytes = sigBytes;\n    }\n  }\n\n  /**\n   * Creates a word array filled with random bytes.\n   *\n   * @param {number} nBytes The number of random bytes to generate.\n   *\n   * @return {WordArray} The random word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.random(16);\n   */\n  static random(nBytes) {\n    const words = [];\n\n    const r = (m_w) => {\n      let _m_w = m_w;\n      let _m_z = 0x3ade68b1;\n      const mask = 0xffffffff;\n\n      return () => {\n        _m_z = (0x9069 * (_m_z & 0xFFFF) + (_m_z >> 0x10)) & mask;\n        _m_w = (0x4650 * (_m_w & 0xFFFF) + (_m_w >> 0x10)) & mask;\n        let result = ((_m_z << 0x10) + _m_w) & mask;\n        result /= 0x100000000;\n        result += 0.5;\n        return result * (Math.random() > 0.5 ? 1 : -1);\n      };\n    };\n\n    for (let i = 0, rcache; i < nBytes; i += 4) {\n      const _r = r((rcache || Math.random()) * 0x100000000);\n\n      rcache = _r() * 0x3ade67b7;\n      words.push((_r() * 0x100000000) | 0);\n    }\n\n    return new WordArray(words, nBytes);\n  }\n\n  /**\n   * Converts this word array to a string.\n   *\n   * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n   *\n   * @return {string} The stringified word array.\n   *\n   * @example\n   *\n   *     var string = wordArray + '';\n   *     var string = wordArray.toString();\n   *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n   */\n  toString(encoder = Hex) {\n    return encoder.stringify(this);\n  }\n\n  /**\n   * Concatenates a word array to this word array.\n   *\n   * @param {WordArray} wordArray The word array to append.\n   *\n   * @return {WordArray} This word array.\n   *\n   * @example\n   *\n   *     wordArray1.concat(wordArray2);\n   */\n  concat(wordArray) {\n    // Shortcuts\n    const thisWords = this.words;\n    const thatWords = wordArray.words;\n    const thisSigBytes = this.sigBytes;\n    const thatSigBytes = wordArray.sigBytes;\n\n    // Clamp excess bits\n    this.clamp();\n\n    // Concat\n    if (thisSigBytes % 4) {\n      // Copy one byte at a time\n      for (let i = 0; i < thatSigBytes; i += 1) {\n        const thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n        thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n      }\n    } else {\n      // Copy one word at a time\n      for (let i = 0; i < thatSigBytes; i += 4) {\n        thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n      }\n    }\n    this.sigBytes += thatSigBytes;\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Removes insignificant bits.\n   *\n   * @example\n   *\n   *     wordArray.clamp();\n   */\n  clamp() {\n    // Shortcuts\n    const { words, sigBytes } = this;\n\n    // Clamp\n    words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n    words.length = Math.ceil(sigBytes / 4);\n  }\n\n  /**\n   * Creates a copy of this word array.\n   *\n   * @return {WordArray} The clone.\n   *\n   * @example\n   *\n   *     var clone = wordArray.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n    clone.words = this.words.slice(0);\n\n    return clone;\n  }\n}\n\n/**\n * Hex encoding strategy.\n */\nexport const Hex = {\n  /**\n   * Converts a word array to a hex string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The hex string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const hexChars = [];\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      hexChars.push((bite >>> 4).toString(16));\n      hexChars.push((bite & 0x0f).toString(16));\n    }\n\n    return hexChars.join('');\n  },\n\n  /**\n   * Converts a hex string to a word array.\n   *\n   * @param {string} hexStr The hex string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n   */\n  parse(hexStr) {\n    // Shortcut\n    const hexStrLength = hexStr.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < hexStrLength; i += 2) {\n      words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n    }\n\n    return new WordArray(words, hexStrLength / 2);\n  },\n};\n\n/**\n * Latin1 encoding strategy.\n */\nexport const Latin1 = {\n  /**\n   * Converts a word array to a Latin1 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Latin1 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const latin1Chars = [];\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      latin1Chars.push(String.fromCharCode(bite));\n    }\n\n    return latin1Chars.join('');\n  },\n\n  /**\n   * Converts a Latin1 string to a word array.\n   *\n   * @param {string} latin1Str The Latin1 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n   */\n  parse(latin1Str) {\n    // Shortcut\n    const latin1StrLength = latin1Str.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i += 1) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n    }\n\n    return new WordArray(words, latin1StrLength);\n  },\n};\n\n/**\n * UTF-8 encoding strategy.\n */\nexport const Utf8 = {\n  /**\n   * Converts a word array to a UTF-8 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-8 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    try {\n      return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n    } catch (e) {\n      throw new Error('Malformed UTF-8 data');\n    }\n  },\n\n  /**\n   * Converts a UTF-8 string to a word array.\n   *\n   * @param {string} utf8Str The UTF-8 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n   */\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  },\n};\n\n/**\n * Abstract buffered block algorithm template.\n *\n * The property blockSize must be implemented in a concrete subtype.\n *\n * @property {number} _minBufferSize\n *\n *     The number of blocks that should be kept unprocessed in the buffer. Default: 0\n */\nexport class BufferedBlockAlgorithm extends Base {\n  constructor() {\n    super();\n    this._minBufferSize = 0;\n  }\n\n  /**\n   * Resets this block algorithm's data buffer to its initial state.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm.reset();\n   */\n  reset() {\n    // Initial values\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n\n  /**\n   * Adds new data to this block algorithm's buffer.\n   *\n   * @param {WordArray|string} data\n   *\n   *     The data to append. Strings are converted to a WordArray using UTF-8.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm._append('data');\n   *     bufferedBlockAlgorithm._append(wordArray);\n   */\n  _append(data) {\n    let m_data = data;\n\n    // Convert string to WordArray, else assume WordArray already\n    if (typeof m_data === 'string') {\n      m_data = Utf8.parse(m_data);\n    }\n\n    // Append\n    this._data.concat(m_data);\n    this._nDataBytes += m_data.sigBytes;\n  }\n\n  /**\n   * Processes available data blocks.\n   *\n   * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n   *\n   * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n   *\n   * @return {WordArray} The processed data.\n   *\n   * @example\n   *\n   *     var processedData = bufferedBlockAlgorithm._process();\n   *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n   */\n  _process(doFlush) {\n    let processedWords;\n\n    // Shortcuts\n    const { _data: data, blockSize } = this;\n    const dataWords = data.words;\n    const dataSigBytes = data.sigBytes;\n    const blockSizeBytes = blockSize * 4;\n\n    // Count blocks ready\n    let nBlocksReady = dataSigBytes / blockSizeBytes;\n    if (doFlush) {\n      // Round up to include partial blocks\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      // Round down to include only full blocks,\n      // less the number of blocks that must remain in the buffer\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n\n    // Count words ready\n    const nWordsReady = nBlocksReady * blockSize;\n\n    // Count bytes ready\n    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n    // Process blocks\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += blockSize) {\n        // Perform concrete-algorithm logic\n        this._doProcessBlock(dataWords, offset);\n      }\n\n      // Remove processed words\n      processedWords = dataWords.splice(0, nWordsReady);\n      data.sigBytes -= nBytesReady;\n    }\n\n    // Return processed words\n    return new WordArray(processedWords, nBytesReady);\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = bufferedBlockAlgorithm.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n    clone._data = this._data.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Abstract hasher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n */\nexport class Hasher extends BufferedBlockAlgorithm {\n  constructor(cfg) {\n    super();\n\n    this.blockSize = 512 / 32;\n\n    /**\n     * Configuration options.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates a shortcut function to a hasher's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to create a helper for.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n   */\n  static _createHelper(SubHasher) {\n    return (message, cfg) => new SubHasher(cfg).finalize(message);\n  }\n\n  /**\n   * Creates a shortcut function to the HMAC's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to use in this HMAC helper.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n   */\n  static _createHmacHelper(SubHasher) {\n    return (message, key) => new HMAC(SubHasher, key).finalize(message);\n  }\n\n  /**\n   * Resets this hasher to its initial state.\n   *\n   * @example\n   *\n   *     hasher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-hasher logic\n    this._doReset();\n  }\n\n  /**\n   * Updates this hasher with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {Hasher} This hasher.\n   *\n   * @example\n   *\n   *     hasher.update('message');\n   *     hasher.update(wordArray);\n   */\n  update(messageUpdate) {\n    // Append\n    this._append(messageUpdate);\n\n    // Update the hash\n    this._process();\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Finalizes the hash computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @example\n   *\n   *     var hash = hasher.finalize();\n   *     var hash = hasher.finalize('message');\n   *     var hash = hasher.finalize(wordArray);\n   */\n  finalize(messageUpdate) {\n    // Final message update\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n\n    // Perform concrete-hasher logic\n    const hash = this._doFinalize();\n\n    return hash;\n  }\n}\n\n/**\n * HMAC algorithm.\n */\nexport class HMAC extends Base {\n  /**\n   * Initializes a newly created HMAC.\n   *\n   * @param {Hasher} SubHasher The hash algorithm to use.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @example\n   *\n   *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n   */\n  constructor(SubHasher, key) {\n    super();\n\n    const hasher = new SubHasher();\n    this._hasher = hasher;\n\n    // Convert string to WordArray, else assume WordArray already\n    let _key = key;\n    if (typeof _key === 'string') {\n      _key = Utf8.parse(_key);\n    }\n\n    // Shortcuts\n    const hasherBlockSize = hasher.blockSize;\n    const hasherBlockSizeBytes = hasherBlockSize * 4;\n\n    // Allow arbitrary length keys\n    if (_key.sigBytes > hasherBlockSizeBytes) {\n      _key = hasher.finalize(key);\n    }\n\n    // Clamp excess bits\n    _key.clamp();\n\n    // Clone key for inner and outer pads\n    const oKey = _key.clone();\n    this._oKey = oKey;\n    const iKey = _key.clone();\n    this._iKey = iKey;\n\n    // Shortcuts\n    const oKeyWords = oKey.words;\n    const iKeyWords = iKey.words;\n\n    // XOR keys with pad constants\n    for (let i = 0; i < hasherBlockSize; i += 1) {\n      oKeyWords[i] ^= 0x5c5c5c5c;\n      iKeyWords[i] ^= 0x36363636;\n    }\n    oKey.sigBytes = hasherBlockSizeBytes;\n    iKey.sigBytes = hasherBlockSizeBytes;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Resets this HMAC to its initial state.\n   *\n   * @example\n   *\n   *     hmacHasher.reset();\n   */\n  reset() {\n    // Shortcut\n    const hasher = this._hasher;\n\n    // Reset\n    hasher.reset();\n    hasher.update(this._iKey);\n  }\n\n  /**\n   * Updates this HMAC with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {HMAC} This HMAC instance.\n   *\n   * @example\n   *\n   *     hmacHasher.update('message');\n   *     hmacHasher.update(wordArray);\n   */\n  update(messageUpdate) {\n    this._hasher.update(messageUpdate);\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Finalizes the HMAC computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @example\n   *\n   *     var hmac = hmacHasher.finalize();\n   *     var hmac = hmacHasher.finalize('message');\n   *     var hmac = hmacHasher.finalize(wordArray);\n   */\n  finalize(messageUpdate) {\n    // Shortcut\n    const hasher = this._hasher;\n\n    // Compute HMAC\n    const innerHash = hasher.finalize(messageUpdate);\n    hasher.reset();\n    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n    return hmac;\n  }\n}\n","import {\n  WordArray,\n} from './core.js';\n\nconst parseLoop = (base64Str, base64StrLength, reverseMap) => {\n  const words = [];\n  let nBytes = 0;\n  for (let i = 0; i < base64StrLength; i += 1) {\n    if (i % 4) {\n      const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n      const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n      const bitsCombined = bits1 | bits2;\n      words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n      nBytes += 1;\n    }\n  }\n  return WordArray.create(words, nBytes);\n};\n\n/**\n * Base64 encoding strategy.\n */\nexport const Base64 = {\n  /**\n   * Converts a word array to a Base64 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Base64 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const base64String = CryptoJS.enc.Base64.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n    const map = this._map;\n\n    // Clamp excess bits\n    wordArray.clamp();\n\n    // Convert\n    const base64Chars = [];\n    for (let i = 0; i < sigBytes; i += 3) {\n      const byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      const byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n      const byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n      const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n      for (let j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j += 1) {\n        base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n      }\n    }\n\n    // Add padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      while (base64Chars.length % 4) {\n        base64Chars.push(paddingChar);\n      }\n    }\n\n    return base64Chars.join('');\n  },\n\n  /**\n   * Converts a Base64 string to a word array.\n   *\n   * @param {string} base64Str The Base64 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Base64.parse(base64String);\n   */\n  parse(base64Str) {\n    // Shortcuts\n    let base64StrLength = base64Str.length;\n    const map = this._map;\n    let reverseMap = this._reverseMap;\n\n    if (!reverseMap) {\n      this._reverseMap = [];\n      reverseMap = this._reverseMap;\n      for (let j = 0; j < map.length; j += 1) {\n        reverseMap[map.charCodeAt(j)] = j;\n      }\n    }\n\n    // Ignore padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      const paddingIndex = base64Str.indexOf(paddingChar);\n      if (paddingIndex !== -1) {\n        base64StrLength = paddingIndex;\n      }\n    }\n\n    // Convert\n    return parseLoop(base64Str, base64StrLength, reverseMap);\n  },\n\n  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n};\n","import {\n  Base,\n  WordArray,\n} from './core.js';\nimport { MD5Algo } from './md5.js';\n\n/**\n * This key derivation function is meant to conform with EVP_BytesToKey.\n * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n */\nexport class EvpKDFAlgo extends Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.EvpKDF.create();\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(\n      new Base(),\n      {\n        keySize: 128 / 32,\n        hasher: MD5Algo,\n        iterations: 1,\n      },\n      cfg,\n    );\n  }\n\n  /**\n   * Derives a key from a password.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password, salt) {\n    let block;\n\n    // Shortcut\n    const { cfg } = this;\n\n    // Init hasher\n    const hasher = cfg.hasher.create();\n\n    // Initial values\n    const derivedKey = WordArray.create();\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const { keySize, iterations } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      if (block) {\n        hasher.update(block);\n      }\n      block = hasher.update(password).finalize(salt);\n      hasher.reset();\n\n      // Iterations\n      for (let i = 1; i < iterations; i += 1) {\n        block = hasher.finalize(block);\n        hasher.reset();\n      }\n\n      derivedKey.concat(block);\n    }\n    derivedKey.sigBytes = keySize * 4;\n\n    return derivedKey;\n  }\n}\n\n/**\n * Derives a key from a password.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.EvpKDF(password, salt);\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n */\nexport const EvpKDF = (password, salt, cfg) => EvpKDFAlgo.create(cfg).compute(password, salt);\n","/* eslint-disable no-use-before-define */\n\nimport {\n  Base,\n  WordArray,\n  BufferedBlockAlgorithm,\n} from './core.js';\nimport { Base64 } from './enc-base64.js';\nimport { EvpKDFAlgo } from './evpkdf.js';\n\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\nexport class Cipher extends BufferedBlockAlgorithm {\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  constructor(xformMode, key, cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Store transform mode and key\n    this._xformMode = xformMode;\n    this._key = key;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createEncryptor(key, cfg) {\n    return this.create(this._ENC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates this cipher in decryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createDecryptor(key, cfg) {\n    return this.create(this._DEC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates shortcut functions to a cipher's object interface.\n   *\n   * @param {Cipher} cipher The cipher to create a helper for.\n   *\n   * @return {Object} An object with encrypt and decrypt shortcut functions.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n   */\n  static _createHelper(SubCipher) {\n    const selectCipherStrategy = (key) => {\n      if (typeof key === 'string') {\n        return PasswordBasedCipher;\n      }\n      return SerializableCipher;\n    };\n\n    return {\n      encrypt(message, key, cfg) {\n        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n      },\n\n      decrypt(ciphertext, key, cfg) {\n        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n      },\n    };\n  }\n\n  /**\n   * Resets this cipher to its initial state.\n   *\n   * @example\n   *\n   *     cipher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-cipher logic\n    this._doReset();\n  }\n\n  /**\n   * Adds data to be encrypted or decrypted.\n   *\n   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.process('data');\n   *     const encrypted = cipher.process(wordArray);\n   */\n  process(dataUpdate) {\n    // Append\n    this._append(dataUpdate);\n\n    // Process available blocks\n    return this._process();\n  }\n\n  /**\n   * Finalizes the encryption or decryption process.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after final processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.finalize();\n   *     const encrypted = cipher.finalize('data');\n   *     const encrypted = cipher.finalize(wordArray);\n   */\n  finalize(dataUpdate) {\n    // Final data update\n    if (dataUpdate) {\n      this._append(dataUpdate);\n    }\n\n    // Perform concrete-cipher logic\n    const finalProcessedData = this._doFinalize();\n\n    return finalProcessedData;\n  }\n}\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\nexport class StreamCipher extends Cipher {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 1;\n  }\n\n  _doFinalize() {\n    // Process partial blocks\n    const finalProcessedBlocks = this._process(!!'flush');\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * Abstract base block cipher mode template.\n */\nexport class BlockCipherMode extends Base {\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  constructor(cipher, iv) {\n    super();\n\n    this._cipher = cipher;\n    this._iv = iv;\n  }\n\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n  static createEncryptor(cipher, iv) {\n    return this.Encryptor.create(cipher, iv);\n  }\n\n  /**\n   * Creates this mode for decryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n   */\n  static createDecryptor(cipher, iv) {\n    return this.Decryptor.create(cipher, iv);\n  }\n}\n\nfunction xorBlock(words, offset, blockSize) {\n  const _words = words;\n  let block;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Choose mixing block\n  if (iv) {\n    block = iv;\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  }\n\n  // XOR blocks\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\nexport class CBC extends BlockCipherMode {\n}\n/**\n * CBC encryptor.\n */\nCBC.Encryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // XOR and encrypt\n    xorBlock.call(this, words, offset, blockSize);\n    cipher.encryptBlock(words, offset);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\n/**\n * CBC decryptor.\n */\nCBC.Decryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    // Decrypt and XOR\n    cipher.decryptBlock(words, offset);\n    xorBlock.call(this, words, offset, blockSize);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n\n/**\n * PKCS #5/7 padding strategy.\n */\nexport const Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (data.sigBytes % blockSizeBytes);\n\n    // Create padding word\n    const paddingWord = (nPaddingBytes << 24)\n      | (nPaddingBytes << 16)\n      | (nPaddingBytes << 8)\n      | nPaddingBytes;\n\n    // Create padding\n    const paddingWords = [];\n    for (let i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n    const padding = WordArray.create(paddingWords, nPaddingBytes);\n\n    // Add padding\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad(data) {\n    const _data = data;\n\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\nexport class BlockCipher extends Cipher {\n  constructor(xformMode, key, cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    super(xformMode, key, Object.assign(\n      {\n        mode: CBC,\n        padding: Pkcs7,\n      },\n      cfg,\n    ));\n\n    this.blockSize = 128 / 32;\n  }\n\n  reset() {\n    let modeCreator;\n\n    // Reset cipher\n    super.reset.call(this);\n\n    // Shortcuts\n    const { cfg } = this;\n    const { iv, mode } = cfg;\n\n    // Reset block mode\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      modeCreator = mode.createEncryptor;\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      modeCreator = mode.createDecryptor;\n      // Keep at least one block in the buffer for unpadding\n      this._minBufferSize = 1;\n    }\n\n    this._mode = modeCreator.call(mode, this, iv && iv.words);\n    this._mode.__creator = modeCreator;\n  }\n\n  _doProcessBlock(words, offset) {\n    this._mode.processBlock(words, offset);\n  }\n\n  _doFinalize() {\n    let finalProcessedBlocks;\n\n    // Shortcut\n    const { padding } = this.cfg;\n\n    // Finalize\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize);\n\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n\n      // Unpad data\n      padding.unpad(finalProcessedBlocks);\n    }\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\nexport class CipherParams extends Base {\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  constructor(cipherParams) {\n    super();\n\n    this.mixIn(cipherParams);\n  }\n\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n  toString(formatter) {\n    return (formatter || this.formatter).stringify(this);\n  }\n}\n\n/**\n * OpenSSL formatting strategy.\n */\nexport const OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    let wordArray;\n\n    // Shortcuts\n    const { ciphertext, salt } = cipherParams;\n\n    // Format\n    if (salt) {\n      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(Base64);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse(openSSLStr) {\n    let salt;\n\n    // Parse base64\n    const ciphertext = Base64.parse(openSSLStr);\n\n    // Shortcut\n    const ciphertextWords = ciphertext.words;\n\n    // Test for salt\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n      // Remove salt from ciphertext\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({ ciphertext, salt });\n  },\n};\n\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\nexport class SerializableCipher extends Base {\n  /**\n   * Encrypts a message.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key);\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, key, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Encrypt\n    const encryptor = cipher.createEncryptor(key, _cfg);\n    const ciphertext = encryptor.finalize(message);\n\n    // Shortcut\n    const cipherCfg = encryptor.cfg;\n\n    // Create and return serializable cipher params\n    return CipherParams.create({\n      ciphertext,\n      key,\n      iv: cipherCfg.iv,\n      algorithm: cipher,\n      mode: cipherCfg.mode,\n      padding: cipherCfg.padding,\n      blockSize: encryptor.blockSize,\n      formatter: _cfg.format,\n    });\n  }\n\n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, key, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Decrypt\n    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n\n    return plaintext;\n  }\n\n  /**\n   * Converts serialized ciphertext to CipherParams,\n   * else assumed CipherParams already and returns ciphertext unchanged.\n   *\n   * @param {CipherParams|string} ciphertext The ciphertext.\n   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n   *\n   * @return {CipherParams} The unserialized ciphertext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       ._parse(ciphertextStringOrParams, format);\n   */\n  static _parse(ciphertext, format) {\n    if (typeof ciphertext === 'string') {\n      return format.parse(ciphertext, this);\n    }\n    return ciphertext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\nSerializableCipher.cfg = Object.assign(\n  new Base(),\n  { format: OpenSSLFormatter },\n);\n\n/**\n * OpenSSL key derivation function.\n */\nexport const OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute(password, keySize, ivSize, salt) {\n    let _salt = salt;\n\n    // Generate random salt\n    if (!_salt) {\n      _salt = WordArray.random(64 / 8);\n    }\n\n    // Derive key and IV\n    const key = EvpKDFAlgo.create({ keySize: keySize + ivSize }).compute(password, _salt);\n\n    // Separate key and IV\n    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4;\n\n    // Return params\n    return CipherParams.create({ key, iv, salt: _salt });\n  },\n};\n\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\nexport class PasswordBasedCipher extends SerializableCipher {\n  /**\n   * Encrypts a message using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password');\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, password, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Encrypt\n    const ciphertext = SerializableCipher.encrypt\n      .call(this, cipher, message, derivedParams.key, _cfg);\n\n    // Mix in derived params\n    ciphertext.mixIn(derivedParams);\n\n    return ciphertext;\n  }\n\n  /**\n   * Decrypts serialized ciphertext using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, password, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf\n      .execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Decrypt\n    const plaintext = SerializableCipher.decrypt\n      .call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n\n    return plaintext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, { kdf: OpenSSLKdf });\n","import {\n  BlockCipher,\n} from './cipher-core.js';\n\n// Lookup tables\nconst _SBOX = [];\nconst INV_SBOX = [];\nconst _SUB_MIX_0 = [];\nconst _SUB_MIX_1 = [];\nconst _SUB_MIX_2 = [];\nconst _SUB_MIX_3 = [];\nconst INV_SUB_MIX_0 = [];\nconst INV_SUB_MIX_1 = [];\nconst INV_SUB_MIX_2 = [];\nconst INV_SUB_MIX_3 = [];\n\n// Compute lookup tables\n\n// Compute double table\nconst d = [];\nfor (let i = 0; i < 256; i += 1) {\n  if (i < 128) {\n    d[i] = i << 1;\n  } else {\n    d[i] = (i << 1) ^ 0x11b;\n  }\n}\n\n// Walk GF(2^8)\nlet x = 0;\nlet xi = 0;\nfor (let i = 0; i < 256; i += 1) {\n  // Compute sbox\n  let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n  sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n  _SBOX[x] = sx;\n  INV_SBOX[sx] = x;\n\n  // Compute multiplication\n  const x2 = d[x];\n  const x4 = d[x2];\n  const x8 = d[x4];\n\n  // Compute sub bytes, mix columns tables\n  let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n  _SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n  _SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n  _SUB_MIX_2[x] = (t << 8) | (t >>> 24);\n  _SUB_MIX_3[x] = t;\n\n  // Compute inv sub bytes, inv mix columns tables\n  t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n  INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n  INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n  INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);\n  INV_SUB_MIX_3[sx] = t;\n\n  // Compute next counter\n  if (!x) {\n    xi = 1;\n    x = xi;\n  } else {\n    x = x2 ^ d[d[d[x8 ^ x2]]];\n    xi ^= d[d[xi]];\n  }\n}\n\n// Precomputed Rcon lookup\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n/**\n * AES block cipher algorithm.\n */\nexport class AESAlgo extends BlockCipher {\n  _doReset() {\n    let t;\n\n    // Skip reset of nRounds has been set before and key did not change\n    if (this._nRounds && this._keyPriorReset === this._key) {\n      return;\n    }\n\n    // Shortcuts\n    this._keyPriorReset = this._key;\n    const key = this._keyPriorReset;\n    const keyWords = key.words;\n    const keySize = key.sigBytes / 4;\n\n    // Compute number of rounds\n    this._nRounds = keySize + 6;\n    const nRounds = this._nRounds;\n\n    // Compute number of key schedule rows\n    const ksRows = (nRounds + 1) * 4;\n\n    // Compute key schedule\n    this._keySchedule = [];\n    const keySchedule = this._keySchedule;\n    for (let ksRow = 0; ksRow < ksRows; ksRow += 1) {\n      if (ksRow < keySize) {\n        keySchedule[ksRow] = keyWords[ksRow];\n      } else {\n        t = keySchedule[ksRow - 1];\n\n        if (!(ksRow % keySize)) {\n          // Rot word\n          t = (t << 8) | (t >>> 24);\n\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n\n          // Mix Rcon\n          t ^= RCON[(ksRow / keySize) | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n        }\n\n        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n      }\n    }\n\n    // Compute inv key schedule\n    this._invKeySchedule = [];\n    const invKeySchedule = this._invKeySchedule;\n    for (let invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {\n      const ksRow = ksRows - invKsRow;\n\n      if (invKsRow % 4) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]]\n          ^ INV_SUB_MIX_1[_SBOX[(t >>> 16) & 0xff]]\n          ^ INV_SUB_MIX_2[_SBOX[(t >>> 8) & 0xff]]\n          ^ INV_SUB_MIX_3[_SBOX[t & 0xff]];\n      }\n    }\n  }\n\n  encryptBlock(M, offset) {\n    this._doCryptBlock(\n      M, offset, this._keySchedule, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX,\n    );\n  }\n\n  decryptBlock(M, offset) {\n    const _M = M;\n\n    // Swap 2nd and 4th rows\n    let t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n\n    this._doCryptBlock(\n      _M,\n      offset,\n      this._invKeySchedule,\n      INV_SUB_MIX_0,\n      INV_SUB_MIX_1,\n      INV_SUB_MIX_2,\n      INV_SUB_MIX_3,\n      INV_SBOX,\n    );\n\n    // Inv swap 2nd and 4th rows\n    t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n  }\n\n  _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n    const _M = M;\n\n    // Shortcut\n    const nRounds = this._nRounds;\n\n    // Get input, add round key\n    let s0 = _M[offset] ^ keySchedule[0];\n    let s1 = _M[offset + 1] ^ keySchedule[1];\n    let s2 = _M[offset + 2] ^ keySchedule[2];\n    let s3 = _M[offset + 3] ^ keySchedule[3];\n\n    // Key schedule row counter\n    let ksRow = 4;\n\n    // Rounds\n    for (let round = 1; round < nRounds; round += 1) {\n      // Shift rows, sub bytes, mix columns, add round key\n      const t0 = SUB_MIX_0[s0 >>> 24]\n        ^ SUB_MIX_1[(s1 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s2 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s3 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t1 = SUB_MIX_0[s1 >>> 24]\n        ^ SUB_MIX_1[(s2 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s3 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s0 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t2 = SUB_MIX_0[s2 >>> 24]\n        ^ SUB_MIX_1[(s3 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s0 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s1 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t3 = SUB_MIX_0[s3 >>> 24]\n        ^ SUB_MIX_1[(s0 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s1 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s2 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n\n      // Update state\n      s0 = t0;\n      s1 = t1;\n      s2 = t2;\n      s3 = t3;\n    }\n\n    // Shift rows, sub bytes, add round key\n    const t0 = (\n      (SBOX[s0 >>> 24] << 24)\n        | (SBOX[(s1 >>> 16) & 0xff] << 16)\n        | (SBOX[(s2 >>> 8) & 0xff] << 8)\n        | SBOX[s3 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t1 = (\n      (SBOX[s1 >>> 24] << 24)\n        | (SBOX[(s2 >>> 16) & 0xff] << 16)\n        | (SBOX[(s3 >>> 8) & 0xff] << 8)\n        | SBOX[s0 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t2 = (\n      (SBOX[s2 >>> 24] << 24)\n        | (SBOX[(s3 >>> 16) & 0xff] << 16)\n        | (SBOX[(s0 >>> 8) & 0xff] << 8)\n        | SBOX[s1 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t3 = (\n      (SBOX[s3 >>> 24] << 24)\n        | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n\n    // Set output\n    _M[offset] = t0;\n    _M[offset + 1] = t1;\n    _M[offset + 2] = t2;\n    _M[offset + 3] = t3;\n  }\n}\nAESAlgo.keySize = 256 / 32;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n */\nexport const AES = BlockCipher._createHelper(AESAlgo);\n","/**\n * Counter block mode.\n */\nimport {\n  BlockCipherMode,\n} from './cipher-core.js';\n\nexport class CTR extends BlockCipherMode {\n}\nCTR.Encryptor = class extends CTR {\n  processBlock(words, offset) {\n    const _words = words;\n\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n    const iv = this._iv;\n    let counter = this._counter;\n\n    // Generate keystream\n    if (iv) {\n      this._counter = iv.slice(0);\n      counter = this._counter;\n\n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    }\n    const keystream = counter.slice(0);\n    cipher.encryptBlock(keystream, 0);\n\n    // Increment counter\n    counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;\n\n    // Encrypt\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n};\nCTR.Decryptor = CTR.Encryptor;\n","/**\n * A noop padding strategy.\n */\nexport const NoPadding = {\n  pad() {\n  },\n\n  unpad() {\n  },\n};\n","import { WordArray, Hex } from 'crypto-es/lib/core'\nimport { CipherParams } from 'crypto-es/lib/cipher-core'\nimport { AES } from 'crypto-es/lib/aes'\nimport { CTR } from 'crypto-es/lib/mode-ctr'\nimport { NoPadding } from 'crypto-es/lib/pad-nopadding'\nimport { formatIV } from '../../utils'\nimport Buffer from '../buffer'\n\nconst Crypto = {\n\n  decryptWordArray: function (raw, key, iv) {\n    const realKey = Hex.parse(key)\n\n    const realIV = Hex.parse(formatIV(iv))\n    const message = WordArray.create(new Uint8Array(raw))\n    const decryptWord = AES.decrypt(\n      CipherParams.create({\n        ciphertext: message\n      }),\n      realKey,\n      {\n        iv: realIV,\n        mode: CTR,\n        padding: NoPadding\n      }\n    )\n    return Crypto.wordArrayToUint8Array(decryptWord)\n  },\n  wordArrayToUint8Array: function (wordArray) {\n    const l = wordArray.sigBytes\n    const words = wordArray.words\n    const result = new Uint8Array(l)\n    let i = 0\n    let j = 0\n    while (true) {\n      if (i === l) { break }\n      const w = words[j++]\n      result[i++] = (w & 0xff000000) >>> 24\n      if (i === l) { break }\n      result[i++] = (w & 0x00ff0000) >>> 16\n      if (i === l) { break }\n      result[i++] = (w & 0x0000ff00) >>> 8\n      if (i === l) { break }\n      result[i++] = (w & 0x000000ff)\n    }\n    return result\n  },\n\n  decoderAESCTRData (videoTrack, audioTrack, customDescryptHandler) {\n    if (videoTrack.videoSenc) {\n      const key = videoTrack.kidValue\n      const senc = videoTrack.videoSenc\n      videoTrack.samples.forEach((item, index) => {\n        const sencBox = senc[index]\n        let encodeWord = item.data\n        const encodeBuffers = []\n        const decodeBuffers = []\n        const iv = sencBox.InitializationVector\n        if (sencBox.subsamples && sencBox.subsamples.length) {\n          sencBox.subsamples.forEach(function (value) {\n            const len = value.BytesOfClearData + value.BytesOfProtectedData\n            const sampleData = encodeWord.slice(0, len)\n            encodeBuffers.push(sampleData.slice(0, value.BytesOfClearData))\n            decodeBuffers.push(sampleData.slice(value.BytesOfClearData))\n            encodeWord = encodeWord.slice(len)\n          })\n        } else {\n          const len = item.size\n          encodeBuffers.push(encodeWord.slice(0, 0))\n          decodeBuffers.push(encodeWord.slice(0, len))\n          encodeWord = encodeWord.slice(len)\n        }\n        const tempBuffer = new Buffer()\n        tempBuffer.write(...decodeBuffers)\n        let decrypted = customDescryptHandler ? customDescryptHandler(tempBuffer.buffer, key, iv) : Crypto.decryptWordArray(tempBuffer.buffer, key, iv)\n        const buffer = new Buffer()\n        encodeBuffers.forEach((clearDataBuf, i) => {\n          const protectedDataLen = decodeBuffers[i].length\n          const decodeProtectedData = decrypted.slice(0, protectedDataLen)\n          buffer.write(clearDataBuf)\n          buffer.write(decodeProtectedData)\n          decrypted = decrypted.slice(protectedDataLen)\n        })\n        videoTrack.samples[index].data = buffer.buffer\n      })\n    }\n\n    if (audioTrack.audioSenc) {\n      const key = audioTrack.kidValue\n      const senc = audioTrack.audioSenc\n      audioTrack.samples.forEach((item, index) => {\n        const sencBox = senc[index]\n        const dec = customDescryptHandler ? customDescryptHandler(item.data, key, sencBox.InitializationVector) : Crypto.decryptWordArray(item.data, key, sencBox.InitializationVector)\n        audioTrack.samples[index].data = dec\n      })\n    }\n  }\n}\n\nexport default Crypto\n","import { VideoTrack, AudioTrack, MetadataTrack, AudioSample, VideoSample } from '../model'\nimport { readBig32 } from '../utils'\nimport { MP4Parser } from './mp4-parser'\nimport { Logger } from './logger'\nimport Crypto from './crypto/crypto'\nconst NEW_ARRAY_MAX_CNT = 20\nexport class MP4Demuxer {\n  _videoSamples = []\n  _audioSamples = []\n  _lastRemainBuffer = []\n  _lastRemainBufferStartPos = 0\n\n  constructor (videoSegmnents, audioSegmnents, metadataTrack, options) {\n    this.videoTrack = new VideoTrack()\n    this.audioTrack = new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n    this.log = new Logger('MP4Demuxer', options && options.openLog ? !options.openLog : true)\n\n    videoSegmnents && videoSegmnents.forEach(item => {\n      this._videoSamples.push(...item.frames)\n    })\n    audioSegmnents && audioSegmnents.forEach(item => {\n      this._audioSamples.push(...item.frames)\n    })\n  }\n\n  parseSamples (moov) {\n    if (!moov) {\n      throw new Error('moov is required')\n    }\n    if (!this.videoTrack.codec && !this.audioTrack.codec) {\n      MP4Parser.moovToTrack(moov, this.videoTrack, this.audioTrack)\n      this.videoSenc = this.videoTrack.videoSenc\n      this.audioSenc = this.audioTrack.audioSenc\n    }\n    if (!this._audioSamples.length && !this._videoSamples.length) {\n      const ret = MP4Parser.moovToSamples(moov)\n      if (!ret) throw new Error('cannot parse samples from moov box')\n      this._videoSamples = ret.videoSamples || []\n      this._audioSamples = ret.audioSamples || []\n    }\n  }\n\n  demux (data, dataStart, videoIndexRange, audioIndexRange, moov) {\n    this.parseSamples(moov)\n\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    let sample\n    let sampleData\n    let startByte\n    if (videoIndexRange) {\n      let frame\n      let nalSize = 0\n      for (let i = videoIndexRange[0], l = videoIndexRange[1]; i <= l; i++) {\n        sample = this._videoSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        startByte = sample.offset - dataStart\n        sampleData = data.subarray(startByte, startByte + sample.size)\n        frame = new VideoSample(sample.pts || sample.dts, sample.dts)\n        frame.duration = sample.duration\n        frame.gopId = sample.gopId\n        if (sample.keyframe) frame.setToKeyframe()\n        let start = 0\n        const len = sampleData.length - 1\n        while (start < len) {\n          nalSize = readBig32(sampleData, start)\n          start += 4\n          frame.units.push(sampleData.subarray(start, start + nalSize))\n          start += nalSize\n        }\n        videoTrack.samples.push(frame)\n      }\n\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n    }\n    if (audioIndexRange) {\n      for (let i = audioIndexRange[0], l = audioIndexRange[1]; i <= l; i++) {\n        sample = this._audioSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        startByte = sample.offset - dataStart\n        sampleData = data.subarray(startByte, startByte + sample.size)\n        audioTrack.samples.push(new AudioSample(sample.dts, sampleData, sample.duration))\n      }\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].dts\n    }\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  demuxPart (data, dataStart, videoIndexRange, audioIndexRange, moov, useEME, kidValue, customDescryptHandler) {\n    this.parseSamples(moov)\n\n    this.videoTrack.useEME = useEME\n    this.audioTrack.useEME = useEME\n    // this.log.debug('[demuxPart start],dataStart,', dataStart, ',dataLen,', data.byteLength, ', lastRemain,', this._lastRemainBuffer ? this._lastRemainBuffer.byteLength : 0)\n    if (this._lastRemainBuffer && this._lastRemainBuffer.byteLength > 0 && dataStart > this._lastRemainBufferStartPos && dataStart <= this._lastRemainBufferStartPos + this._lastRemainBuffer.byteLength) {\n      let tryCnt = 0\n      while (tryCnt < NEW_ARRAY_MAX_CNT) {\n        try {\n          const buffer = this._lastRemainBuffer.subarray(0, dataStart - this._lastRemainBufferStartPos)\n          const temp = new Uint8Array(data.byteLength + buffer.byteLength)\n          temp.set(buffer, 0)\n          temp.set(new Uint8Array(data), buffer.byteLength)\n          data = temp\n          dataStart -= buffer.byteLength\n          this._lastRemainBuffer = null\n          this._lastRemainBufferStartPos = 0\n          // this.log.debug('[demuxPart add lastRemain],dataStart,', dataStart, ',dataLen,', data.byteLength)\n          break\n        } catch (e) {\n          if (tryCnt < NEW_ARRAY_MAX_CNT) {\n            tryCnt++\n          } else {\n            throw new Error('new Uint8Array error:,' + e.errorMessage)\n          }\n        }\n      }\n    }\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n    videoTrack.videoSenc = null\n    audioTrack.audioSenc = null\n\n    let sample\n    let sampleData\n    let startByte\n    let videoEndByte = 0\n    let audioEndByte = 0\n    if (this._videoSamples.length > 0 && videoIndexRange.length > 0) {\n      let frame\n      const end = data.byteLength + dataStart\n      for (let i = videoIndexRange[0]; i <= videoIndexRange[1]; i++) {\n        sample = this._videoSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        if (sample.offset >= dataStart && sample.offset + sample.size <= end) {\n          startByte = sample.offset - dataStart\n          videoEndByte = startByte + sample.size\n          sampleData = data.subarray(startByte, videoEndByte)\n          frame = new VideoSample(sample.pts || sample.dts, sample.dts)\n          frame.duration = sample.duration\n          // this.log.debug('[video !!!!!!!!],frame,index，', sample.index, ',segmentIdx', segmentIdx, ', dataStart,', dataStart, ',dataEnd', end, ',Samplestart,', sample.offset, ', SampleEnd,', sample.offset + sample.size, ',size,', sample.size, 'dts,', sample.dts, ',pts,', sample.pts, ', keyframe', sample.keyframe)\n          frame.gopId = sample.gopId\n          frame.sampleOffset = sample.index\n          // frame.timeOffset = sample.timeOffset || sample.timeOffset === 0 ? sample.timeOffset : null\n          if (sample.keyframe) frame.setToKeyframe()\n          frame.data = sampleData\n          frame.size = sample.size\n          // this.log.debug('[demux video frame],frame,index，', sample.index, ', size,', sampleData.byteLength, ', hash ', hashVal(sampleData.toString()))\n          videoTrack.samples.push(frame)\n        }\n      }\n      if (videoTrack.samples.length > 0) {\n        videoTrack.gopId = videoTrack.samples[0].gopId\n        videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n        videoTrack.startPts = videoTrack.samples[0].pts / videoTrack.timescale\n        videoTrack.endPts = videoTrack.samples[videoTrack.samples.length - 1].pts / videoTrack.timescale\n        // this.log.debug('[demux video],frame,startPts，', videoTrack.startPts, ', endPts,', videoTrack.endPts)\n        if (this.videoSenc) {\n          videoTrack.videoSenc = this.videoSenc.slice(videoTrack.samples[0].sampleOffset, videoTrack.samples[0].sampleOffset + videoTrack.samples.length)\n          videoTrack.kidValue = kidValue\n        }\n      }\n    }\n    if (this._audioSamples.length > 0 && audioIndexRange.length > 0) {\n      for (let i = audioIndexRange[0]; i <= audioIndexRange[1]; i++) {\n        sample = this._audioSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        if (sample.offset >= dataStart && sample.offset + sample.size <= data.byteLength + dataStart) {\n          startByte = sample.offset - dataStart\n          audioEndByte = startByte + sample.size\n          sampleData = data.subarray(startByte, audioEndByte)\n          // this.log.debug('[audio !!!!!!!!],audio frame,index，', sample.index, ',segmentIdx', segmentIdx, ', Samplestart,', sample.offset, ', SampleEnd,', sample.offset + sample.size, ',size,', sample.size, 'dts,', sample.dts, ',pts,', sample.pts || sample.dts)\n          // frame.gopId = sample.gopId\n          // this.log.debug('[demux audio frame],index ,', sample.index, ', size,', sampleData.byteLength, ', hash,', hashVal(sampleData.toString()))\n          audioTrack.samples.push(new AudioSample(sample.dts, sampleData, sample.duration, sample.index))\n        }\n      }\n      if (audioTrack.samples.length > 0) {\n        audioTrack.gopId = audioTrack.samples[0].gopId || videoTrack.gopId\n        audioTrack.baseMediaDecodeTime = audioTrack.samples[0].dts\n        audioTrack.startPts = audioTrack.samples[0].pts / audioTrack.timescale\n        audioTrack.endPts = audioTrack.samples[audioTrack.samples.length - 1].pts / audioTrack.timescale\n        // this.log.debug('[demux audio],frame,startPts，', audioTrack.startPts, ', endPts,', audioTrack.endPts)\n        if (this.audioSenc) {\n          audioTrack.audioSenc = this.audioSenc.slice(audioTrack.samples[0].sampleOffset, audioTrack.samples[0].sampleOffset + audioTrack.samples.length)\n          audioTrack.kidValue = kidValue\n        }\n      }\n    }\n    this.decoderData(videoTrack, audioTrack, customDescryptHandler)\n    let nalSize = 0\n    for (let i = 0; i < videoTrack.samples.length; i++) {\n      let start = 0\n      const sampleData = videoTrack.samples[i].data\n      const len = sampleData.length - 1\n      while (start < len) {\n        nalSize = readBig32(sampleData, start)\n        start += 4\n        videoTrack.samples[i].units.push(sampleData.subarray(start, start + nalSize))\n        start += nalSize\n      }\n    }\n    this._lastRemainBuffer = data.subarray(Math.max(videoEndByte, audioEndByte))\n    if (this._lastRemainBuffer.byteLength > 0) {\n      this._lastRemainBufferStartPos = dataStart + data.byteLength - this._lastRemainBuffer.byteLength\n    } else {\n      this._lastRemainBufferStartPos = 0\n    }\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  reset () {\n    this._videoSamples = []\n    this._audioSamples = []\n    this._lastRemainBuffer = null\n    this._lastRemainBufferStartPos = 0\n    this.videoTrack.reset()\n    this.audioTrack.reset()\n    this.metadataTrack.reset()\n  }\n\n  decoderData (videoTrack, audioTrack, customDescryptHandler) {\n    if (videoTrack.useEME || audioTrack.useEME) return\n    Crypto.decoderAESCTRData(videoTrack, audioTrack, customDescryptHandler)\n  }\n\n  static probe (data) {\n    return MP4Parser.probe(data)\n  }\n}\n","import { TrackType } from '../model'\nimport { MP4 } from './mp4'\nimport { concatUint8Array } from '../utils'\n\nexport class MP4Remuxer {\n  /**\n   * @param {import('../model').VideoTrack} videoTrack\n   * @param {import('../model').AudioTrack} audioTrack\n   */\n  constructor (videoTrack, audioTrack) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n  }\n\n  /**\n   * @returns {import('./fmp4-remuxer').RemuxResult}\n   */\n  remux (videoTrack, audioTrack) {\n    this.videoTrack = videoTrack || this.videoTrack\n    this.audioTrack = audioTrack || this.audioTrack\n\n    const hasVideo = videoTrack?.exist() && videoTrack?.hasSample()\n    const hasAudio = audioTrack?.exist() && audioTrack?.hasSample()\n\n    let videoSegment\n    let audioSegment\n    if (hasVideo && hasAudio) {\n      videoSegment = this._remuxMix(videoTrack, audioTrack)\n    } else if (hasVideo) {\n      videoSegment = this._remuxTrack(videoTrack)\n    } else if (hasAudio) {\n      audioSegment = this._remuxTrack(audioTrack)\n    }\n\n    if (videoTrack) {\n      videoTrack.samples = []\n    }\n\n    if (audioTrack) {\n      audioTrack.samples = []\n    }\n\n    return {\n      videoSegment,\n      audioSegment\n    }\n  }\n\n  _remuxMix (videoTrack, audioTrack) {\n    const ftyp = MP4.ftyp([videoTrack, audioTrack])\n    const { mdatData: video, chunkOffset } = this._remuxData(videoTrack, ftyp.byteLength + 8)\n    const { mdatData: audio } = this._remuxData(audioTrack, chunkOffset)\n\n    const mdat = MP4.mdat(concatUint8Array(video, audio))\n    const moov = MP4.moovMP4([videoTrack, audioTrack])\n\n    videoTrack.ext = undefined\n    audioTrack.ext = undefined\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    return concatUint8Array(ftyp, mdat, moov)\n  }\n\n  _remuxTrack (track) {\n    const ftyp = MP4.ftyp([track])\n\n    const { mdatData } = this._remuxData(track, ftyp.byteLength + 8)\n    const mdat = MP4.mdat(mdatData)\n    const moov = MP4.moovMP4([track])\n\n    track.ext = undefined\n    track.samples = []\n\n    return concatUint8Array(ftyp, mdat, moov)\n  }\n\n  _remuxData (track, chunkOffset) {\n    const isVideo = track.type === TrackType.VIDEO\n    const samples = track.samples\n\n    let mdatSize = 0\n    if (isVideo) {\n      samples.forEach((s) => {\n        mdatSize += s.units.reduce((t, c) => (t + c.byteLength), 0)\n        mdatSize += (s.units.length * 4)\n      })\n    } else {\n      mdatSize = samples.reduce((t, c) => (t + c.size), 0)\n    }\n\n    const mdatData = new Uint8Array(mdatSize)\n    const mdatView = new DataView(mdatData.buffer)\n\n    const ext = track.ext = {\n      stts: [],\n      stsc: [],\n      stsz: [],\n      stco: [],\n      stss: [],\n      ctts: []\n    }\n\n    const samplesPerChunk = 1\n    let dataOffset = 0\n    let totalDuration = 0\n    let sample\n    const sampleLen = samples.length\n    for (let i = 0; i < sampleLen; i++) {\n      sample = samples[i]\n      totalDuration += sample.duration\n\n      let sampleSize = isVideo ? 0 : sample.size\n      if (isVideo) {\n        sample.units.forEach((u) => {\n          mdatView.setUint32(dataOffset, u.byteLength)\n          dataOffset += 4\n          mdatData.set(u, dataOffset)\n          dataOffset += u.byteLength\n          sampleSize += (4 + u.byteLength)\n        })\n      } else {\n        mdatData.set(sample.data, dataOffset)\n        dataOffset += sampleSize\n      }\n      sample.size = sampleSize\n      ext.stsz.push(sampleSize)\n\n      if (isVideo) this._fillCttsSamples(ext.ctts, sample.cts)\n      this._fillSttsSamples(ext.stts, sample, samples[i + 1])\n      this._fillStcoSamples(ext.stco, i, samplesPerChunk, chunkOffset)\n      chunkOffset += sampleSize\n\n      if (isVideo && sample.keyframe) {\n        ext.stss.push(i + 1)\n      }\n    }\n\n    track.duration = totalDuration\n    this._fillStscSamples(ext.stsc, sampleLen, samplesPerChunk)\n\n    return {\n      mdatData,\n      chunkOffset\n    }\n  }\n\n  _fillSttsSamples (sttsSamples, cur, next) {\n    const lastSample = sttsSamples[sttsSamples.length - 1]\n\n    if (next) {\n      if (!lastSample || lastSample.value !== cur.duration) {\n        sttsSamples.push({ value: cur.duration, count: 1 })\n      } else {\n        lastSample.count++\n      }\n      return\n    }\n\n    if (lastSample) {\n      lastSample.count++\n    } else {\n      sttsSamples.push({ value: 40, count: 1 })\n    }\n  }\n\n  _fillCttsSamples (cttsSamples, cts) {\n    const lastSample = cttsSamples[cttsSamples.length - 1]\n\n    if (!lastSample || lastSample.value !== cts) {\n      cttsSamples.push({ value: cts, count: 1 })\n    } else {\n      lastSample.count++\n    }\n  }\n\n  _fillStcoSamples (stcoSamples, index, samplePerChunk, chunkOffset) {\n    if (!(index % samplePerChunk)) {\n      stcoSamples.push(chunkOffset)\n    }\n  }\n\n  _fillStscSamples (samples, sampleCount, samplesPerChunk) {\n    if (sampleCount <= samplesPerChunk) {\n      samples.push({ firstChunk: 1, samplesPerChunk: sampleCount, sampleDescIndex: 1 })\n    } else {\n      const len = Math.floor(sampleCount / samplesPerChunk)\n      const remaining = sampleCount % samplesPerChunk\n      samples.push({ firstChunk: 1, samplesPerChunk, sampleDescIndex: 1 })\n      if (remaining) {\n        samples.push({ firstChunk: len + 1, samplesPerChunk: remaining, sampleDescIndex: 1 })\n      }\n    }\n  }\n}\n","import * as flv from './flv'\nimport * as mpegTs from './mpeg-ts'\nimport * as mp4 from './mp4'\nimport * as model from './model'\nimport { Logger } from './utils'\n\nexport default {\n  ...flv,\n  ...mpegTs,\n  ...mp4,\n  ...model,\n  Logger\n}\n"],"names":["TrackType","VIDEO","AUDIO","METADATA","VideoCodecType","AV1","AVC","HEVC","AudioCodecType","AAC","G711PCMA","G711PCMU","OPUS","MP3","WarningType","LARGE_AV_SHIFT","LARGE_VIDEO_GAP","LARGE_VIDEO_GAP_BETWEEN_CHUNK","LARGE_AUDIO_GAP","AUDIO_FILLED","AUDIO_DROPPED","VideoTrack","_classCallCheck","_defineProperty","this","undefined","_createClass","key","value","sequenceNumber","width","height","fpsDen","fpsNum","duration","baseMediaDecodeTime","timescale","codec","present","pid","pps","sps","vps","sarRatio","samples","warnings","hvcC","get","length","dts","pts","first","last","test","isVideoEncryption","AudioTrack","sampleDuration","sampleRate","channelCount","config","container","codecType","isAudioEncryption","VideoSample","units","originPts","originDts","keyframe","flag","dependsOn","isNonSyncSample","AudioSample","data","sampleOffset","size","byteLength","Sample","FlvScriptSample","_Sample","_inherits","_super","_createSuper","apply","arguments","SeiSample","_Sample2","_super2","MetadataTrack","flvScriptSamples","seiSamples","ExpGolomb","Error","_data","_bytesAvailable","_loadWord","_bitsAvailable","position","availableBytes","Math","min","workingBytes","Uint8Array","set","subarray","_word","DataView","buffer","getUint32","count","skipBytes","floor","bits","val","readBits","leadingZeroCount","skipLZ","skipBits","clz","readUEG","lastScale","nextScale","j","readEG","Logger","name","_prefix","concat","_console","disabled","_len","args","Array","_key","console","warn","UTF8","uint8array","out","input","i","push","String","fromCharCode","_checkContinuation","ucs4","_ucs2","join","start","checkLength","array","isBrowser","window","ua","navigator","userAgent","toLocaleLowerCase","isSafari","isFirefox","includes","isAndroid","concatUint8Array","arr","filter","Boolean","reduce","p","c","prevLen","forEach","d","MAX_SIZE","pow","readBig16","readBig32","readBig64","getAvcCodec","codecs","h","toString","formatIV","iv","Number","slice","toUpperCase","bufferToString","len","parse","a","isArray","parseInt","map","item","combineToFloat","integer","decimal","rate","FREQ","indexOf","skip","frames","samplingFrequencyIndex","protectionSkipBytes","frameLength","objectType","_AAC$_getConfig","_getConfig","frameIndex","getFrameDuration","remaining","originCodec","_AAC$_getConfig2","samplingIndex","originObjectType","extensionSamplingIndex","NALu","dropZerosLength","end","offset","dataLen","unit","isHevc","type","uuid","payload","uint","emulationPreventionBytesPositions","newLength","newData","sourceIndex","shift","nalUnitSize","spsParsed","spsSize","spsArr","ppsArr","spsCount","parseSPS","removeEPB","ppsSize","ppsCount","eg","readUByte","profileIdc","profileCompatibility","levelIdc","skipUEG","chromaFormat","chromaFormatIdc","readBool","scalingListCount","skipScalingList","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","fixedFrame","fps","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","aspectRatioIdc","numUnitsInTick","timeScale","ceil","vpsParsed","nalUnitType","numNalus","nalSize","vpsArr","numOfArrays","parseVPS","vpsMaxSubLayersMinus1","numTemporalLayers","max","_parseProfileTierLevel","spsMaxSubLayersMinus1","temporalIdNested","separateColourPlaneFlag","confWinLeftOffset","confWinRightOffset","confWinTopOffset","confWinBottomOffset","conformanceWindowFlag","bitDepthLumaMinus8","bitDepthChromaMinus8","subWidthC","subHeightC","maxSubLayersMinus1","generalTierFlag","generalProfileSpace","generalProfileIdc","generalProfileCompatibilityFlags","generalConstraintIndicatorFlags","generalLevelIdc","subLayerProfilePresentFlag","subLayerLevelPresentFlag","bitsAvailable","dv","byteOffset","magicSignature","fromCodePoint","log","outputGain","getInt16","BitratesMap","SamplesCoefficients","BytesInSlot","chromeVersion","MPEG","track","header","parseHeader","stamp","samplesPerFrame","sample","mpegVersion","mpegLayer","bitRateIndex","sampleRateIndex","paddingBit","channelMode","bitRate","sampleCoefficient","bytesInSlot","result","match","MAX_SILENT_FRAME_DURATION","AUDIO_EXCEPTION_LOG_EMIT_DURATION","FlvFixer","videoTrack","audioTrack","metadataTrack","_baseDts","_baseDtsInited","_audioNextPts","_videoNextDts","_audioTimestampBreak","_videoTimestampBreak","_lastVideoDuration","_keyFrameInNextChunk","_lastAudioExceptionGapDot","Infinity","_lastAudioExceptionOverlapDot","_lastAudioExceptionLargeGapDot","_lastVideoExceptionLargeGapDot","_lastVideoExceptionChunkFirstDtsDot","_this","startTime","discontinuity","contiguous","round","_videoLastSample","_calculateBaseDts","resetBaseDts","exist","_resetBaseDtsWhenStreamBreaked","_fixAudio","_fixVideo","s","time","_this2","refSampleDurationInt","x","lastSample","pop","unshift","samp0","firstSample","vDelta","abs","_samples$","nextDts","firstSampleDts","nextSampleDts","nextSample","refSampleDuration","_this3","_doFixAudioInternal","audioSamps","videoSamps","audioBasePts","videoBaseDts","baseDts","delta","isFinite","_getG711Duration","error","sampleDurationInSampleRate","nextPts","silentFrame","_getSilentFrame","silentSample","splice","sampleSize","getSilentFrame","AMF","ret","_parseValue","view","isEnd","getUint8","getFloat64","_AMF$_parseString","_parseString","terminal","_AMF$_parseObject","_parseObject","_terminal","_AMF$_parseObject2","strictArrayLength","_AMF$_parseValue","timestamp","Date","decode","getUint16","FlvSoundFormat","logger","FlvDemuxer","_fixer","_scriptDataObject$dat","seamlessLoadingSwitching","_remainingData","_headerParsed","reset","probe","tagType","dataSize","bodyData","prevTagSize","_parseAudio","_parseVideo","_parseScript","formatTimescale","hasSample","scriptDataObject","metaData","onMetaData","hasOwnProperty","fix","demux","format","soundRate","soundSize","soundType","AUDIO_RATE","G711A","_parseG711","_parseAac","_parseOpus","packetType","parseHeaderPackets","newSample","audioData","parseAudioSpecificConfig","frameType","codecId","cts","configData","parseHEVCDecoderConfigurationRecord","parseAVCDecoderConfigurationRecord","parseAvcC","_checkAddMetaNalToUnits","lastKeyFrameDts","setToKeyframe","parseSEI","_gopId","gopId","hevc","_needAddMetaBeforeKeyFrameNal","AUDIO_EXCETION_LOG_EMIT_DURATION","MAX_VIDEO_FRAME_DURATION","TsFixer","fixerConfig","_baseVideoDts","_baseAudioDts","_needForceFixLargeGap","forceFixLargeGap","_largeGapThreshold","largeGapThreshold","vSamples","aSamples","firstVideoSample","firstAudioSample","vaDelta","vDeltaToNextDts","aDeltaToNextDts","_samples$i","prevDts","second","expectFragEnd","lastAudioSample","index","largeGap","_audioLastSample","TsDemuxer","_pmtId","_remainingPacketData","_videoPesData","_audioPesData","remainingLength","videoPid","audioPid","payloadUnitStartIndicator","adaptationFiledControl","tableEnd","programInfoLength","esPid","_parseVideoData","_parseAudioData","pes","_parsePES","_toConsumableArray","parseAnnexB","_createVideoSample","spsInfo","ffByteFound","_pushVideoSample","_parseAacData","_parseMPEG","_track$samples","parseADTS","isHeader","frame","appendFrame","headerDataLen","pesLen","ptsDtsFlags","ByteReader","buf","byteNum","getFloat32","getInt8","getInt32","back","read","setUint8","setUint16","setUint32","uint8","unreadLength","str","v","concatUint8s","BitReader","byte","MP4Parser","names","headerSize","subData","findBox","box","parseBox","trackId","baseDataOffsetPresent","flags","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","baseDataOffset","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","reference_ID","version","earliest_presentation_time","first_offset","references","ref","tmp32","reference_type","referenced_size","subsegment_duration","starts_with_SAP","SAP_type","SAP_delta_time","mvhd","trak","pssh","nextTrackId","tkhd","mdia","fromUint8","matrix","int32","caculatedMatrix","readInt","rotation","scaled0","hypot","scaled1","atan2","PI","toDegree","mdhd","hdlr","minf","lang","language","handlerType","vmhd","smhd","stbl","graphicsmode","opcolor","balance","_ret$stsd$entries$","_ret$stsd$entries$$si","_ret$stsd$entries$$si2","stsd","stts","ctts","stsc","stsz","stco","co64","default_IV_size","entries","sinf","schi","tenc","stss","senc","sampleCount","InitializationVector","subsamples","subsampleCount","subsample","BytesOfClearData","BytesOfProtectedData","keyIds","systemId","toHex","numKeyIds","keyId","data_size","kid","system_id","entryCount","b","av01","avc1","hvc1","mp4a","alaw","samplesize","esds","horizresolution","vertresolution","avcC","pasp","default_IsEncrypted","default_KID","frma","data_format","colorType","readString","colorPrimaries","transferCharacteristics","matrixCoefficients","fullRangeFlag","iccProfile","readToUint8","bodyStart","parseVisualSampleEntry","av1C","colr","bitdepth","bit","fromByte","marker","seqProfile","seqLevelIdx0","seqTier0","highBitdepth","twelveBit","monochrome","chromaSubsamplingX","chromaSubsamplingY","chromaSamplePosition","reserved","initialPresentationDelayPresent","initialPresentationDelayMinusOne","configOBUs","configurationVersion","AVCProfileIndication","AVCLevelIndication","lengthSizeMinusOne","spsLength","ppsLength","tmp","generalProfileCompatibility","avgFrameRate","_ret$vps","nalus","_ret$sps","_ret$pps","hSpacing","vSpacing","parseAudioSampleEntry","byteRead","tag","substring","padStart","firstChunk","samplesPerChunk","entrySizes","mfhd","traf","t","tfhd","tfdt","trun","dataOffset","firstSampleFlags","isLeading","isDependedOn","hasRedundancy","paddingValue","degradationPriority","moov","_e$esds","_e$esds2","tracks","vTrack","find","_t$mdia","_t$mdia$hdlr","aTrack","_t$mdia2","_t$mdia2$hdlr","_vTrack$tkhd","_vTrack$mdia","_vTrack$mdia$minf","_vTrack$mdia$minf$stb","_vTrack$mdia2","_vTrack$mdia2$minf","_vTrack$mdia2$minf$st","_vTrackId","id","tkhdDuration","mvhdDurtion","mvhdTimecale","_e1$sinf","_e1$sinf$schi","_e1$sinf2","_e1$sinf2$schi","_e1$sinf3","_e1$sinf3$schi","_e1$sinf4","_e1$sinf4$frma","e1","ext","videoSenc","useEME","kidValue","encv","_aTrack$tkhd","_e$esds3","_e$esds4","_aTrack$mdia","_aTrack$mdia$minf","_aTrack$mdia$minf$stb","_aTrack$mdia2","_aTrack$mdia2$minf","_aTrack$mdia2$minf$st","_aTrackId","_e$sinf","_e$sinf$frma","_e$sinf2","_e$sinf2$schi","_e$sinf3","_e$sinf3$schi","_e$sinf4","_e$sinf4$schi","getRateIndexByRate","from","audioSenc","enca","_videoTrack$encv","_audioTrack$enca","vkid","akid","videoSampleCount","_audioTrack$samples","audioSampleCount","moof","_ref","defaultSize","defaultDuration","evaluateDefaultDuration","_t$mdia3","_t$mdia3$hdlr","_t$mdia4","_t$mdia4$hdlr","videoSamples","audioSamples","_vTrack$mdia3","_vTrack$mdia3$minf","videoStbl","getSamples","_aTrack$mdia3","_aTrack$mdia3$minf","_aTrack$mdia$mdhd","audioStbl","keyframeMap","cttsArr","cttsEntries","stscEntries","stcoEntries","stszEntrySizes","stssEntries","_ref2","pos","chunkIndex","chunkRunIndex","offsetInChunk","lastSampleInChunk","lastChunkInRun","_ref3","dataReferenceIndex","frameCount","depth","isFullBox","readBig24","pad","charstr","maxlen","chars","r","hex","FMP4Demuxer","partData","partDataStart","videoExist","audioExist","isAV01","dataStart","__lastRemainData","lastRemainDataEnd","__lastRemainDataStart","noDuplicateData","__nextMoofStart","moovBox","dataEnd","moovToTrack","moofBoxes","moofBox","w","__loadedMoofWraps","nextMoofStart","sort","n","_step","_iterator","_createForOfIteratorHelper","_loop","moofWrap","moofStart","moofToSamples","videoBaseMediaDecodeTime","audioBaseMediaDecodeTime","Object","keys","k","some","xStart","sampleData","done","err","e","f","videoData","baseOffset","Concat","ResultConstructor","totalLength","arrays","Buffer","self","_len2","_key2","UINT32_MAX","MP4","FTYPHEV1","FTYPAVC1","init","ftyp","content","types","mvex","HDLR_TYPES","VMHD","SMHD","DINF","extBox","STTS","STSC","STSZ","STCO","opus","avc1hev1","_concat$concat","avcc","btrt","charCodeAt","schm","typ","boxes","fiel","_concat$concat2","ArrayBuffer","pcf","cif","write","_ref4","_slicedToArray","opusAudioDescription","opusSpecificConfig","dOps","Opus","trex","sencLength","isVideo","videoSencLength","saiz","saio","trun1","sbgp","sdtp","extension","writeUint32","samplesLength","writeUint16","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","sampleLen","_samples$i$flag","_samples$i$cts","trackMP4","mdiaMP4","minfMP4","stblMP4","_ref5","_ref6","sampleDescIndex","samplesSizes","offsets","keyframeIndexes","_ref7","styp","durationCount","earliestTime","mdatSize","sidx","mdat","create","video","audio","dinf","dref","StblTable","enable","debug","_console2","_console3","_len3","_key3","_console4","_len4","_key4","_console5","group","table","groupEnd","FMP4Remuxer","options","browserVersions","exec","forceFirstIDR","openLog","createInit","videoInitSegment","audioInitSegment","initSegment","videoSegment","audioSegment","hasVideo","hasAudio","initMerge","_remuxVideo","_remuxAudio","mdata","l","mdatView","_offset2","_sample2","u","_offset","_sample","Base","properties","assign","clone","constructor","_construct","WordArray","_Base","words","sigBytes","call","typedArray","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","typedArrayByteLength","_words","encoder","Hex","stringify","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","clamp","thatByte","_get","_getPrototypeOf","prototype","nBytes","rcache","m_w","_m_w","_m_z","mask","random","_r","hexChars","bite","hexStr","hexStrLength","substr","Latin1","latin1Str","latin1StrLength","Utf8","utf8Str","unescape","encodeURIComponent","BufferedBlockAlgorithm","_Base2","_minBufferSize","_nDataBytes","m_data","doFlush","processedWords","blockSize","dataWords","dataSigBytes","nBlocksReady","nWordsReady","nBytesReady","_doProcessBlock","Hasher","_BufferedBlockAlgorit","_super3","cfg","_doReset","messageUpdate","_append","_process","hash","_doFinalize","SubHasher","message","finalize","HMAC","_Base3","_super4","_this4","hasher","_hasher","hasherBlockSize","hasherBlockSizeBytes","oKey","_oKey","iKey","_iKey","oKeyWords","iKeyWords","update","innerHash","hmac","Base64","_map","base64Chars","triplet","charAt","paddingChar","base64Str","base64StrLength","reverseMap","_reverseMap","paddingIndex","parseLoop","bits1","bitsCombined","T","sin","FF","GG","HH","II","MD5Algo","_Hasher","_hash","M","_M","offset_i","M_offset_i","H","M_offset_0","M_offset_1","M_offset_2","M_offset_3","M_offset_4","M_offset_5","M_offset_6","M_offset_7","M_offset_8","M_offset_9","M_offset_10","M_offset_11","M_offset_12","M_offset_13","M_offset_14","M_offset_15","nBitsTotal","nBitsLeft","nBitsTotalH","nBitsTotalL","H_i","_createHelper","_createHmacHelper","EvpKDFAlgo","keySize","iterations","password","salt","derivedKeyWords","block","derivedKey","Cipher","xformMode","_xformMode","dataUpdate","finalProcessedData","_ENC_XFORM_MODE","_DEC_XFORM_MODE","SubCipher","selectCipherStrategy","PasswordBasedCipher","SerializableCipher","encrypt","decrypt","ciphertext","ivSize","BlockCipherMode","cipher","_cipher","_iv","Encryptor","Decryptor","xorBlock","_prevBlock","CBC","_BlockCipherMode","_CBC","_class","_super5","encryptBlock","_CBC2","_class2","_super6","thisBlock","decryptBlock","Pkcs7","blockSizeBytes","nPaddingBytes","paddingWord","paddingWords","padding","unpad","BlockCipher","_Cipher2","_super7","mode","modeCreator","createEncryptor","createDecryptor","_mode","__creator","processBlock","finalProcessedBlocks","CipherParams","_super8","cipherParams","_this5","mixIn","formatter","OpenSSLFormatter","openSSLStr","ciphertextWords","_super9","_cfg","encryptor","cipherCfg","algorithm","_ciphertext","plaintext","_parse","OpenSSLKdf","execute","_salt","compute","_SerializableCipher","_super10","derivedParams","kdf","_SBOX","INV_SBOX","_SUB_MIX_0","_SUB_MIX_1","_SUB_MIX_2","_SUB_MIX_3","INV_SUB_MIX_0","INV_SUB_MIX_1","INV_SUB_MIX_2","INV_SUB_MIX_3","xi","sx","x2","x4","x8","RCON","AESAlgo","_BlockCipher","_nRounds","_keyPriorReset","keyWords","ksRows","_keySchedule","keySchedule","ksRow","_invKeySchedule","invKeySchedule","invKsRow","_doCryptBlock","SUB_MIX_0","SUB_MIX_1","SUB_MIX_2","SUB_MIX_3","SBOX","nRounds","s0","s1","s2","s3","t0","t1","t2","t3","AES","CTR","_CTR","counter","_counter","keystream","NoPadding","Crypto","decryptWordArray","raw","realKey","realIV","decryptWord","wordArrayToUint8Array","decoderAESCTRData","customDescryptHandler","sencBox","encodeWord","encodeBuffers","decodeBuffers","tempBuffer","decrypted","clearDataBuf","protectedDataLen","decodeProtectedData","dec","MP4Demuxer","videoSegmnents","audioSegmnents","_this$_videoSamples","_videoSamples","_this$_audioSamples","_audioSamples","moovToSamples","videoIndexRange","audioIndexRange","parseSamples","startByte","_lastRemainBuffer","_lastRemainBufferStartPos","tryCnt","temp","errorMessage","videoEndByte","audioEndByte","startPts","endPts","decoderData","MP4Remuxer","_remuxMix","_remuxTrack","_this$_remuxData","_remuxData","mdatData","chunkOffset","moovMP4","totalDuration","_fillCttsSamples","_fillSttsSamples","_fillStcoSamples","_fillStscSamples","sttsSamples","cur","next","cttsSamples","stcoSamples","samplePerChunk","_objectSpread","flv","mpegTs","mp4","model"],"mappings":"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"}